<html><head/><body>


	
		<title>B16722_06_Final_ASB_ePub</title>
		
	
	
		<div><h1 id="_idParaDest-88"><em class="italic"> <a id="_idTextAnchor088"/>第六章</em>:用多类逻辑回归对树进行分类</h1>
			<p>多类逻辑回归是<strong class="bold">机器学习</strong> ( <strong class="bold"> ML </strong>)算法，用于将事件、实体和行为分类到固定数量的类别中。当需要预测一个实体到多个组的分类时，它可以跨不同的行业和业务场景使用。一个典型的分类用例是希望根据公司的盈利能力和偏好对客户群进行细分，以便通过最有效的营销活动锁定正确的客户。</p>
			<p>这种技术是二元逻辑回归的扩展，它允许我们克服两个可能标签的限制，并对我们可以找到多个类别进行识别的其他环境开放适用性。</p>
			<p>在本章中，我们将看到利用BigQuery ML实现、评估和测试多类逻辑回归模型的所有必要步骤。</p>
			<p>在本章中，我们将讨论以下主题:</p>
			<ul>
				<li>介绍业务场景</li>
				<li>发现多类逻辑回归</li>
				<li>探索和理解数据集</li>
				<li>训练多类逻辑回归模型</li>
				<li>评估多类逻辑回归模型</li>
				<li>使用多类逻辑回归模型</li>
				<li>得出商业结论</li>
			</ul>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/>技术要求</h1>
			<p>本章要求您访问网络浏览器，并能够利用以下功能:</p>
			<ul>
				<li>访问谷歌云控制台的GCP帐户</li>
				<li>托管BigQuery数据集的GCP项目</li>
			</ul>
			<p>现在我们已经准备好了技术需求，让我们开始分析和开发我们的BigQuery ML逻辑回归模型。</p>
			<p>看看下面的视频，看看代码是如何运行的:<a href="https://bit.ly/3h4w7xG">https://bit.ly/3h4w7xG</a></p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor090"/>介绍业务场景</h1>
			<p>对于这个商业<a id="_idIndexMarker323"/>场景，我们可以想象自己是纽约市的一名ML专家。在城市应该开展的所有活动中，对树木进行普查并核实它们的状况是最耗时的工作之一。</p>
			<p>这些树分布在纽约市的不同地区，收集每棵树信息的过程由志愿者或纽约市员工手动完成。收集信息后，数据将存储在数据库中，并通过BigQuery公共数据集公开提供，以供进一步分析(<a href="https://console.cloud.google.com/marketplace/details/city-of-new-york/nyc-tree-census">https://console . cloud . Google . com/market place/details/city-of-new-York/NYC-tree-census</a>)。</p>
			<p>在下图中，我们可以看到一张来自中央公园的图片，中央公园是纽约市树木较多的区域之一:</p>
			<div><div><img src="img/B16722_06_001.jpg" alt="Figure 6.1 – Trees in Central Park, New York City&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图6.1-纽约市中央公园的树木</p>
			<p>为了支持<a id="_idIndexMarker324"/>并加快负责分类树木和评估其状况的人员的工作，您的一位经理可能会要求您建立一个ML模型。</p>
			<p>ML模型的目标是根据树木的特征，如位置、大小和健康状况，自动将树木分类为不同的种类。</p>
			<p>对于这个用例，我们可以只关注城市中最常见的五种树木。</p>
			<p>既然我们已经简要地解释和理解了业务场景，那么让我们来看看ML技术，我们可以用它来将对象或事件分类到多个类中。</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor091"/>发现多类逻辑回归</h1>
			<p>在这一部分，我们将<a id="_idIndexMarker325"/>学习多类逻辑回归的基础知识，以及何时可以应用这一技术。</p>
			<p><strong class="bold">多类逻辑回归</strong>是一种分类技术，可用于将事件、对象、客户或其他实体分为多个类别。与二元逻辑回归不同，这种ML算法可用于将输出值分为两个以上的离散类。</p>
			<p>为了预测多个标签中的一个，该ML算法计算每个结果的概率，并选择具有最高概率的标签。</p>
			<p>作为一种回归算法，标签的预测基于一组称为特征的自变量，这些自变量用于预测称为标签的因变量。</p>
			<p>这种ML技术可用于回答业务问题，例如:</p>
			<ul>
				<li>我的客户<em class="italic">的评论是中立</em>、<em class="italic">正面</em>还是<em class="italic">负面</em>？</li>
				<li>我的客户属于<em class="italic">黄金</em>、<em class="italic">白银</em>还是<em class="italic">青铜</em>级别？</li>
				<li>特定客户<em class="italic">流失的概率是高</em>、<em class="italic">中</em>还是<em class="italic">低</em>？</li>
				<li>图像识别算法是否识别出一只<em class="italic">猫</em>，一只<em class="italic">狗</em>，一只<em class="italic">老鼠</em>，或者一只<em class="italic">牛</em>？</li>
			</ul>
			<p>在我们的业务场景中，由于树木的种类有限，我们将只关注五个种类，所以我们可以利用多类逻辑回归。具体来说，我们感兴趣的是根据树的大小、位置和健康状况等特征将树分类为五个物种中的一个。</p>
			<p>训练多类逻辑回归模型意味着尝试查找可在输入变量(称为要素)和输出变量(称为标注)之间的方程中使用的系数值。</p>
			<p>在<a id="_idIndexMarker326"/>训练之后，我们将利用<strong class="bold">混淆矩阵</strong>来评估我们的多类逻辑回归模型的性能。在多类逻辑回归中，多行和多列构成混淆矩阵。</p>
			<p>为了评估我们的ML模型的<a id="_idIndexMarker328"/>性能，我们将再次使用曲线 ( <strong class="bold"> AUC </strong> ) <strong class="bold">下的<strong class="bold">区域接收器操作特性</strong> ( <strong class="bold"> ROC </strong>)。</strong></p>
			<p>既然我们已经学习了多类逻辑回归的基础知识，是时候看看我们将用来构建ML模型的<a id="_idIndexMarker329"/>数据集了。</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor092"/>探索和理解数据集</h1>
			<p>正如我们在前面的用例中已经做的那样，在进入ML模型的开发之前，有必要分析可以用来解决我们用例的数据。</p>
			<p>我们将从分析表结构开始，以便清楚地理解可以用于我们的业务场景的数据。</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor093"/>理解数据</h2>
			<p>在这一节中，我们将看一看数据，了解它的结构以及如何用它来构建我们的ML模型。</p>
			<p>要开始研究数据，我们需要做以下工作:</p>
			<ol>
				<li value="1">登录谷歌云控制台，从导航菜单访问<strong class="bold"> BigQuery </strong>用户界面。</li>
				<li>在我们在第2章 、<em class="italic">设置您的GCP和BigQuery环境</em>中创建的项目下创建一个新的数据集。对于这个用例，我们将使用默认选项创建数据集<code>06_nyc_trees</code>。</li>
				<li>打开GCP项目<code>new_york_trees</code>。</li>
				<li>As we can see in the following screenshot, the BigQuery public dataset contains multiple tables to host the data collected every 10 years: <div><img src="img/B16722_06_002.jpg" alt="Figure 6.2 – The New York City Trees Public dataset contains the census &#13;&#10;of the trees collected every 10 years&#13;&#10;"/></div><p class="figure-caption">图6.2-纽约市树木公共数据集包含每10年收集的树木普查数据</p></li>
				<li>我们就用<a id="_idIndexMarker333"/>最近的一个:<code>tree_census_2015</code>。此表包含了所有在纽约市种植并在2015年注册的树木的信息。</li>
				<li>Let's click on the table name <code>tree_census_2015</code> in the BigQuery navigation menu to access the schema of the table:<div><img src="img/B16722_06_003.jpg" alt="Figure 6.3 – The structure of the tree_census_2015 table lists all the fields &#13;&#10;that can be used as labels and features&#13;&#10;"/></div><p class="figure-caption">图6.3-tree _ census _ 2015表的结构列出了所有可用作标注和要素的字段</p></li>
				<li>Each field is<a id="_idIndexMarker334"/> well described in the <strong class="bold">Description </strong>column.<p>该表包含由一个<strong class="bold">字符串</strong>表示的<strong class="bold"> spc_latin </strong>列，该字符串表示每棵树的物种的学名。这个字段将是我们ML模型的标签。</p><p>为了对每棵树进行分类，我们可以利用其他领域的信息。一些列描述了树的大小。例如，<strong class="bold"> tree_dbh </strong>测量树的直径，<strong class="bold"> stump_diam </strong>表示树桩的直径。我们还可以利用关于树的健康状况的信息。我们可以想象一些物种比其他物种更健壮，更适合纽约的天气。</p><p>其他领域更多地与树在城市中的位置以及它生活的环境有关。为了训练我们的ML模型，我们可以使用树所在的zip区域:<strong class="bold"> zip_city </strong>。其他一些例子是<strong class="bold"> boroname </strong>列，它包含种植这棵树的行政区的名称，以及<strong class="bold"> nta_name </strong>，它表示这棵树所在的街区。</p><p>我们还可以假设一些物种比其他物种更具侵入性——<strong class="bold">人行道</strong>字段指示与树相邻的人行道是否被树的根部损坏、裂开或抬起。</p><p>从模式的角度来看，这个表包含了许多有用的信息，可以用来开发我们的分类模型。让我们继续分析，深入研究数据。</p></li>
			</ol>
			<p>在本节中，我们已经<a id="_idIndexMarker335"/>分析了<strong class="bold"> tree_census_2015 </strong>表的元数据，现在是时候查看实际数据并开始查询它了。</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor094"/>检查数据质量</h2>
			<p>正如我们已经从前面的用例中了解到的，数据质量是构建有效的ML模型的基础。在本节中，我们将应用一些数据质量检查，以确定要使用的正确记录:</p>
			<ol>
				<li value="1">First of all, we'll check if the table <code>tree_census_2015</code> contains records with <code>spc_latin</code> equals to NULL. This is fundamental because the field <code>spc_latin</code> will be used as label of our machine learning model:<pre>SELECT  COUNT(*) total
FROM    `bigquery-public-data.new_york_trees.tree_census_2015`
WHERE
         spc_latin is NULL;</pre><p>代码块将计算字段<code>spc_latin</code>为空的表“<code>bigquery-public-data.new_york_trees.tree_census_2015</code>”中的所有记录。</p><p>在下面的屏幕截图中，您可以看到查询结果，其中我们得到了一个大于31000的值:</p><div><img src="img/B16722_06_004.jpg" alt="Figure 6.4 – The result of the query shows that some rows contain empty labels&#13;&#10;"/></div><p class="figure-caption">图6.4-查询结果显示一些行包含空标签</p><p>因此，在接下来的查询中，我们将排除字段<code>spc_latin</code>为空的记录。</p></li>
				<li>Focusing only on the rows where the field <code>spc_latin</code> is <code>NOT NULL</code>, we can check the presence of empty values on all the other fields that are potential features of our ML model:<pre>SELECT  COUNT(*)
FROM    `bigquery-public-data.new_york_trees.tree_census_2015`
WHERE
         spc_latin is NOT NULL
         AND (
            zip_city is NULL OR
            tree_dbh is NULL OR
            boroname is NULL OR
            nta_name is NULL OR
            nta_name is NULL OR
            health is NULL OR
            sidewalk is NULL) ;</pre><p>此外，在这种情况下，查询结果不为零。事实上，我们可以很容易地识别出在<code>health</code>和<code>sidewalk</code>字段中呈现<code>NULL</code>值的三条记录。</p><p>我们将在ML模型生命周期的以下阶段过滤这些记录。</p></li>
			</ol>
			<p>现在我们已经对我们的数据集进行了一些质量检查，并且我们已经了解了应该过滤哪些记录<a id="_idIndexMarker338"/>,让我们将重点放在分割我们的数据集上，以将我们的BigQuery ML模型的创建集中在五个最常见的树种上。</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>分割数据集</h2>
			<p>在此<a id="_idIndexMarker339"/>部分，我们将准备用于训练、评估和测试ML模型的表格。</p>
			<p>出于我们的目的，我们将提取数据集中出现频率最高的五个物种。之后，我们将创建BigQuery表，用于训练、评估和测试我们的ML模型:</p>
			<ol>
				<li value="1">First of all, we'll identify only the five most frequent species in the <code>tree_census_2015</code> table with the following query:<pre>SELECT   spc_latin,
         COUNT(*) total
FROM    `bigquery-public-data.new_york_trees.tree_census_2015`
WHERE
         spc_latin is NOT NULL
         AND zip_city is NOT NULL
         AND tree_dbh is NOT NULL
         AND boroname is NOT NULL
         AND nta_name is NOT NULL
         AND health is NOT NULL
         AND sidewalk is NOT NULL
GROUP BY
         spc_latin
ORDER BY
         total desc
LIMIT 5;</pre><p>SQL <a id="_idIndexMarker340"/>语句使用<code>GROUP BY spc_latin</code>子句和<code>COUNT(*)</code>运算符计算每个物种在<code>tree_census_2015</code>表中出现的次数。</p><p>该查询根据字段<code>total</code>的值以降序方式对记录进行排序，该字段包含<code>COUNT</code>的结果。最后，查询的结果集被限制为结果集的前五条记录，查询的末尾有一个<code>LIMIT 5</code>子句。</p><p>SQL语句基于BigQuery公共表<code>tree_census_2015</code>,该表通过我们在前面的<em class="italic">检查数据质量</em>小节中确定的数据质量检查进行了适当的过滤。</p><p>在下面的屏幕截图中，我们可以看到查询结果和数据集中最常见的树种:</p><div><img src="img/B16722_06_005.jpg" alt="Figure 6.5 – The result of the query shows the most common trees in New York City&#13;&#10;"/></div><p class="figure-caption">图6.5-查询结果显示了纽约市最常见的树</p><p>从<a id="_idIndexMarker341"/>查询结果中，我们可以很容易地读出从最常见到最不常见排序的树的拉丁名称。</p></li>
				<li>Since we'll use this subset of five species in the next SQL queries, we can add a <code>CREATE TABLE</code> statement at the beginning of our <code>SELECT</code> statement in order to materialize the results in the <code>top5_species</code> table:<pre>CREATE OR REPLACE TABLE `06_nyc_trees.top5_species` AS
      SELECT   spc_latin,
         COUNT(*) total
      FROM    `bigquery-public-data.new_york_trees.tree_census_2015`
      WHERE
               spc_latin is NOT NULL
               AND zip_city is NOT NULL
               AND tree_dbh is NOT NULL
               AND boroname is NOT NULL
               AND nta_name is NOT NULL
               AND health is NOT NULL
               AND sidewalk is NOT NULL
      GROUP BY
               spc_latin
      ORDER BY
               total desc
      LIMIT 5;</pre><p>通过执行<a id="_idIndexMarker342"/>查询，我们将创建一个只包含两个字段和五条记录的新表。<code>spc_latin</code>表示树的种类，而<code>total</code>统计每个种类在原始数据集中出现的次数。</p></li>
				<li>Now, we can leverage the <code>top5_species</code> table to filter only the species on which we're focusing and create the training table:<pre>CREATE OR REPLACE TABLE `06_nyc_trees.training_table` AS 
SELECT  *
FROM    `bigquery-public-data.new_york_trees.tree_census_2015`
WHERE
         zip_city is NOT NULL
         AND tree_dbh is NOT NULL
         AND boroname is NOT NULL
         AND nta_name is NOT NULL
         AND health is NOT NULL
         AND sidewalk is NOT NULL
         AND spc_latin in 
         (SELECT spc_latin from  `06_nyc_trees.top5_species`)
         AND MOD(tree_id,11)&lt;=8;</pre><p>该查询通过<code>SELECT *</code>语句创建一个包含原始数据集中所有可用列的表。它应用所有必要的过滤器来获取<code>spc_latin</code>标签和所有其他潜在特征的非空值。</p><p>通过使用<code>IN</code>子句，<code>training_table</code>将只包含与数据集中最常见的五个物种相关的记录。</p><p>带有子句<code>MOD(tree_id,11)&lt;=8</code>的查询的最后一行<a id="_idIndexMarker343"/>，只允许我们从整个记录集中选取80%的记录。<code>MOD</code>代表模，返回<code>tree_id</code>除以11的余数。</p></li>
				<li>With a similar approach, we can create the table that will be used for the evaluation of our ML model:<pre>CREATE OR REPLACE TABLE `06_nyc_trees.evaluation_table` AS 
SELECT  *
FROM    `bigquery-public-data.new_york_trees.tree_census_2015`
WHERE
         zip_city is NOT NULL
         AND tree_dbh is NOT NULL
         AND boroname is NOT NULL
         AND nta_name is NOT NULL
         AND health is NOT NULL
         AND sidewalk is NOT NULL
         AND spc_latin in 
         (SELECT spc_latin from `06_nyc_trees.top5_species`) 
         AND MOD(tree_id,11)=9;</pre><p>对于<code>evaluation_table</code>，我们将使用过滤器<code>MOD(tree_id,11)=9</code>只选取10%的记录。</p></li>
				<li>Finally, we'll execute the following SQL statement in order to create the table that will be <a id="_idIndexMarker344"/>used to apply our multiclass classification model:<pre>CREATE OR REPLACE TABLE `06_nyc_trees.classification_table` AS 
SELECT  *
FROM    `bigquery-public-data.new_york_trees.tree_census_2015`
WHERE
         zip_city is NOT NULL
         AND tree_dbh is NOT NULL
         AND boroname is NOT NULL
         AND nta_name is NOT NULL
         AND health is NOT NULL
         AND sidewalk is NOT NULL
         AND spc_latin in 
         (SELECT spc_latin from `06_nyc_trees.top5_species`) 
         AND MOD(tree_id,11)=10;</pre><p><code>classification_table</code>与前面的数据集片段非常相似，但是由于<code>MOD</code>函数将包含数据集剩余的10%。</p></li>
			</ol>
			<p>在这一节中，我们分析了<code>new_york_trees</code>数据集，它包含关于纽约市树木的信息。我们应用了一些数据质量检查来排除空值。然后，我们将数据分段，重点关注表格中出现的五种最常见的物种。现在我们已经完成了准备步骤，是时候继续前进，开始训练我们的BigQuery ML模型了。</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor096"/>训练多类逻辑回归模型</h1>
			<p>既然我们已经清楚地<a id="_idIndexMarker346"/>理解了数据的结构，并且我们已经将它分割成多个表以支持ML模型生命周期的不同阶段，那么让我们将注意力集中在我们的多类逻辑回归模型的训练上。我们将执行SQL查询来创建多类逻辑回归模型:</p>
			<ol>
				<li value="1">Let's start creating the first version of our ML model:<pre>CREATE OR REPLACE MODEL `06_nyc_trees.classification_model_version_1`
OPTIONS
  ( model_type='LOGISTIC_REG',
    auto_class_weights=TRUE
  ) AS
SELECT
  zip_city,
  tree_dbh,
  spc_latin as label
FROM
  `06_nyc_trees.training_table` ;</pre><p>用于创建<code>classification_model_version_1</code>模型的查询只基于两个特征:邮政编码区域和树的直径。</p><p>SQL语句以用于运行训练的关键字<code>CREATE OR REPLACE MODEL</code>开始，后面是<code>OPTIONS</code>子句。在选项中，我们可以指定型号类型等于<code>LOGISTIC_REG</code>和<code>auto_class_weights=TRUE</code>。当我们面对不平衡的训练数据集，其中一些标签比其他标签出现得更频繁时，此选项会特别有用。在我们的例子中，最常见物种的出现次数是第五种的两倍多。为此，我们应用了<a id="_idIndexMarker347"/>这种调整。</p><p class="callout-heading">重要说明</p><p class="callout">BigQuery ML语法不区分二元逻辑回归和多类逻辑回归。在这两种情况下，BigQuery ML模型类型都是<code>LOGISTIC_REG</code>。这种差异是由出现在定型数据集的列标签中的不同值的数量造成的。如果标签只显示两个值，BigQuery ML将训练一个二元逻辑回归。如果标签包含两个以上不同的值，模型将被训练为多类逻辑回归。</p></li>
				<li>After the execution of the training, we can access the information of our first ML model by clicking on <strong class="bold">classification_model_version_1</strong> from the navigation menu and selecting the <strong class="bold">Evaluation</strong> tab.<p>下面的屏幕截图展示了我们第一次尝试的关键性能指标:</p><div><img src="img/B16722_06_006.jpg" alt="Figure 6.6 – The Evaluation tab shows the performance metrics related &#13;&#10;to the selected BigQuery ML model&#13;&#10;"/></div><p class="figure-caption">图6.6–评估选项卡显示了与所选BigQuery ML模型相关的性能指标</p><p>为了对我们的ML模型的有效性有一个<a id="_idIndexMarker348"/>概念，我们可以看一下<strong class="bold"> ROC AUC </strong>值<strong class="bold"> 0.7383 </strong>。</p><p>通过在<strong class="bold">评估</strong>标签中向下滚动鼠标，我们可以看到我们的多类逻辑回归模型的混淆矩阵。</p><p>在下图中，混淆矩阵显示了训练数据集中预测标签和实际标签的百分比:</p><div><img src="img/B16722_06_007.jpg" alt="Figure 6.7 – The Evaluation tab shows the confusion matrix related to the selected BigQuery ML model&#13;&#10;"/></div><p class="figure-caption">图6.7–评估选项卡显示了与所选BigQuery ML模型相关的混淆矩阵</p><p>查看混淆矩阵，我们可以直观地注意到我们的ML模型对一些物种工作得很好，但对另一些物种表现很差。例如，当实际的标签是<strong class="bold">沼泽栎</strong>时，在40%的情况下，ML模型建议不同的物种:<strong class="bold">悬铃木</strong>。</p></li>
				<li>Let's try to improve our model by adding new features with the following BigQuery ML SQL statement:<pre>CREATE OR REPLACE MODEL `06_nyc_trees.classification_model_version_2`
OPTIONS
  ( model_type='LOGISTIC_REG',
    auto_class_weights=TRUE
  ) AS
SELECT
  zip_city,
  tree_dbh,
  boroname,
  nta_name,
  spc_latin as label
FROM
  `06_nyc_trees.training_table` ;</pre><p>与第一次尝试相比，我们在模型的训练中加入了额外的功能。事实上，我们已经将包含在<code>boroname</code>字段和<code>nta_name</code>中的行政区名称添加到了特性列表中。</p><p>在执行SQL语句之后，让我们访问新模型的<strong class="bold">评估</strong>选项卡，看看我们是否正在改进它的性能。看一下<strong class="bold"> ROC AUC </strong>值<strong class="bold"> 0.7667 </strong>，我们可以看到我们模型的性能略有提高。</p></li>
				<li>As a last attempt, we'll enrich our ML model with additional features. The new fields are related to the health of the tree and to the size of the roots:<pre>CREATE OR REPLACE MODEL `06_nyc_trees.classification_model_version_3`
OPTIONS
  ( model_type='LOGISTIC_REG',
    auto_class_weights=TRUE
  ) AS
SELECT
  zip_city,
  tree_dbh,
  boroname,
  nta_name,
  health,
  sidewalk,
  spc_latin as label
FROM
  `06_nyc_trees.training_table`;</pre><p>与<a id="_idIndexMarker351"/>之前的ML模型相比，在<code>classification_model_version_3</code>中，我们包含了描述我们的树的健康状态的字段<code>health</code>，以及用于指定树根是否正在损害相邻路面的字段<code>sidewalk</code>。</p></li>
				<li>Looking at the performance of our last ML model in the <code>0.7696</code>.<p class="callout-heading">小费</p><p class="callout">尽管更多特征的使用可以增加BigQuery ML分类模型的ROC AUC值，但是我们需要考虑性能改进和实现它所花费的资源之间的平衡。在实际场景中，尤其是当数据量非常大时，我们需要只选择对BigQuery ML模型性能影响最大的特性。</p></li>
			</ol>
			<p>在本节中，我们创建了不同的ML模型，试图在我们的数据集中使用不同的特征。在接下来的部分中，我们将使用具有最高ROC AUC值的模型:<code>classification_model_version_3</code>。</p>
			<p>接下来，让我们<a id="_idIndexMarker352"/>利用评估数据集评估我们的ML模型的性能。</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor097"/>评估多类逻辑回归模型</h1>
			<p>在本节中，我们将<a id="_idIndexMarker353"/>执行查询来检查多类逻辑回归模型的性能。</p>
			<p>对于我们的BigQuery ML模型的评估阶段，我们将使用<code>ML.EVALUATE</code>函数和<code>evaluation_table</code>表，专门创建它们来存放评估记录。</p>
			<p>正如我们所见，评估是在模型训练阶段使用的相同字段上执行的，但这些字段是从与训练数据集完全分离的<code>evaluation_table</code>表中提取的。</p>
			<p>外部<code>SELECT</code>语句提取由<code>ML.EVALUATE</code>函数返回的<code>roc_auc</code>值。它还提供了对模型质量的有意义的描述，该模型从<code>'POOR'</code>开始，经过<code>'NEEDS IMPROVEMENTS'</code>和<code>'GOOD'</code>等中间阶段，上升到<code>'EXCELLENT'</code>等级。</p>
			<p>让我们执行以下查询来提取ML模型的关键性能指标:</p>
			<pre>SELECT
  roc_auc,
  CASE
    WHEN roc_auc &gt; .9 THEN 'EXCELLENT'
    WHEN roc_auc &gt; .8 THEN 'VERY GOOD'
    WHEN roc_auc &gt; .7 THEN 'GOOD'
    WHEN roc_auc &gt; .6 THEN 'FINE'
    WHEN roc_auc &gt; .5 THEN 'NEEDS IMPROVEMENTS'
  ELSE
  'POOR'
END
  AS model_quality
FROM 
  ML.EVALUATE(MODEL `06_nyc_trees.classification_model_version_3`,
    (
    SELECT
       zip_city,
       tree_dbh,
       boroname,
       nta_name,
       health,
       sidewalk,
       spc_latin as label
     FROM `06_nyc_trees.evaluation_table`));</pre>
			<p>从下面的<a id="_idIndexMarker354"/>截图中，我们可以看到查询的结果——<strong class="bold">roc _ AUC</strong>值达到了0.77以上。我们的BigQuery ML模型的结果可以被认为是好的:</p>
			<div><div><img src="img/B16722_06_008.jpg" alt="Figure 6.8 – The query extracts the ROC AUC value of the BigQuery ML model &#13;&#10;and a short description of the model quality&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图6.8–该查询提取BigQuery ML模型的ROC AUC值和模型质量的简短描述</p>
			<p>既然我们已经验证了ML模型在不相交评估数据集<a id="_idIndexMarker355"/>上也保持了它的性能，我们可以开始使用它来对我们的<code>classification_table</code>表中的树进行分类。</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/>使用多类逻辑回归模型</h1>
			<p>在这个<a id="_idIndexMarker356"/>部分，我们将测试我们的ML模型并分析结果。</p>
			<p>为了使用我们的BigQuery ML模型，我们将使用<code>ML.PREDICT</code>函数和<code>classification_table</code>表来测试我们的模型，如下面的代码块所示:</p>
			<pre>SELECT
  tree_id,
  actual_label,
  predicted_label_probs,
  predicted_label
FROM
  ML.PREDICT (MODEL `06_nyc_trees.classification_model_version_3`,
    (
    SELECT
       tree_id,
       zip_city,
       tree_dbh,
       boroname,
       nta_name,
       health,
       sidewalk,
       spc_latin as actual_label
    FROM
      `06_nyc_trees.classification_table`
     ));</pre>
			<p>查询语句由<code>SELECT</code>关键字组成，提取<code>tree_id</code>、字段中物种的实际值<code>actual_label</code>以及预测字段<code>predicted_label_probs</code>和<code>predicted_label</code>。</p>
			<p><code>ML.PREDICT</code>函数应用于<code>SELECT</code>语句，从<code>classification_table</code>中提取特征和实际物种。<code>actual_label</code>字段<a id="_idIndexMarker357"/>将仅用作我们预测的基准，而不是在预测阶段。</p>
			<p>在下面的屏幕截图中，我们可以看到通过执行前面的查询获得的记录的结构:</p>
			<div><div><img src="img/B16722_06_009.jpg" alt="Figure 6.9 – A record of the output dataset generated by the classification model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图6.9–分类模型生成的输出数据集的记录</p>
			<p>在这种情况下，<strong class="bold"> tree_id </strong>等于<strong class="bold"> 857 </strong>，树是<strong class="bold"> Quercus palustris </strong>，由于<strong class="bold"> predicted_label </strong>完全相同，被BigQuery ML模型正确分类。<strong class="bold"> predicted_label_probs </strong>表示最高分类标签的置信度为45%。所有其他可能的物种的特点是概率较低。</p>
			<p>现在，我们已经<a id="_idIndexMarker358"/>应用了我们的模型，让我们制定一些关于我们的分类用例的最终考虑。</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor099"/>得出商业结论</h1>
			<p>使用我们从上一节得到的<a id="_idIndexMarker359"/>结果，<em class="italic">使用多类逻辑回归模型</em>，我们将得出一些关于我们的ML模型的有效性的结论。</p>
			<p>用父<code>SELECT COUNT</code>语句丰富前面的查询，我们可以计算与记录总数相比有多少预测是正确的。</p>
			<p>让我们执行以下查询来计算我们的BigQuery ML模型能够正确分类<code>classification_table</code>表中的树的频率:</p>
			<pre>SELECT COUNT(*)
FROM (
      SELECT
        tree_id,
        actual_label,
        predicted_label_probs,
        predicted_label
      FROM
        ML.PREDICT (MODEL `06_nyc_trees.classification_model_version_3`,
          (
          SELECT
             tree_id,
             zip_city,
             tree_dbh,
             boroname,
             nta_name,
             health,
             sidewalk,
             spc_latin as actual_label
          FROM
            `06_nyc_trees.classification_table`
           )
        )
)
WHERE
      actual_label = predicted_label;</pre>
			<p><a id="_idIndexMarker360"/>的结果<code>SELECT COUNT</code>查询返回13，323个带有正确预测标签的预测值。</p>
			<p>考虑到<code>classification_table</code>表的总大小是27，182，我们可以宣布，在49%的情况下，我们的ML模型能够根据树的特征和位置来预测正确的树种。</p>
			<p>这似乎是一个糟糕的结果，但我们需要考虑到多类逻辑回归比二元逻辑回归更复杂，因为有多个选项可能会欺骗我们模型的结果。</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor100"/>总结</h1>
			<p>在这一章中，我们已经建立了第一个多类分类模型。在简单介绍了用例之后，我们发现了什么是多类逻辑回归，以及如何使用它根据事件、行为和对象的特征将它们分成两个以上的类别。</p>
			<p>在深入开发ML模型之前，我们分析了与纽约市的树相关的数据集的模式，并应用了一些必要的数据质量检查来构建有效的ML模型。</p>
			<p>在训练阶段，我们使用不同的功能训练了三个不同的ML模型，以逐步提高BigQuery ML模型的性能。</p>
			<p>然后，我们选择第三个ML模型，并根据评估数据集对其进行评估。在这一阶段，我们注意到ML模型也能够在新记录上保持其性能，并准备进入下一阶段。</p>
			<p>在最后一步中，我们使用ML模型将纽约市的树木分为五个不同的类别，并利用它们的特征，如大小、健康状况和在城市中的位置。</p>
			<p>我们还计算出，我们的分类模型能够在49%的情况下对正确的树种进行分类。</p>
			<p>在下一章，我们将介绍无监督的最大似然法和K-均值聚类技术。</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor101"/>更多资源</h1>
			<ul>
				<li><strong class="bold">纽约市树木普查公共数据集</strong>:<a href="https://console.cloud.google.com/marketplace/product/city-of-new-york/nyc-tree-census">https://console . cloud . Google . com/market place/product/city-of-new York/NYC-tree-Census</a></li>
				<li><strong class="bold"> BigQuery ML创建模型</strong>:<a href="https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-create">https://cloud . Google . com/big query-ML/docs/reference/standard-SQL/bigqueryml-syntax-Create</a></li>
				<li><strong class="bold"> BigQuery ML评估模型</strong>:<a href="https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-evaluate">https://cloud . Google . com/big query-ML/docs/reference/standard-SQL/bigqueryml-syntax-Evaluate</a></li>
				<li><strong class="bold">big query ML Predict</strong>:<a href="https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-predict">https://cloud . Google . com/big query-ML/docs/reference/standard-SQL/bigqueryml-syntax-Predict</a></li>
				<li><strong class="bold"> BigQuery ML多类逻辑示例</strong>:<a href="https://cloud.google.com/bigquery-ml/docs/logistic-regression-prediction">https://cloud . Google . com/big query-ML/docs/Logistic-regression-prediction</a></li>
			</ul>
		</div>
	

</body></html>