<html><head/><body>


	
		<title>B16783_01_Final_SB_epub</title>
		
	
	
		<div><h1 id="_idParaDest-15"><a id="_idTextAnchor014"/> <a id="_idTextAnchor015"/> <em class="italic">第1章【MLflow简介</em></h1>
			<p><strong class="bold"> MLflow </strong>是<strong class="bold">机器学习</strong> ( <strong class="bold"> ML </strong>)生命周期的开源平台，重点是<em class="italic">再现性</em>、<em class="italic">训练</em>、以及<em class="italic">部署</em>。它基于开放接口设计，能够与任何语言或平台、Python和Java客户端一起工作，并可通过REST API访问。可伸缩性也是ML开发者可以利用MLflow的一个重要优势。</p>
			<p>在本书的这一章中，我们将借助示例和样本代码来看看MLflow是如何工作的。这将为本书的其余部分建立必要的基础，以便使用这个概念来设计一个端到端的ML项目。</p>
			<p>具体来说，我们将了解本章的以下部分:</p>
			<ul>
				<li>什么是MLflow？</li>
				<li>MLflow入门</li>
				<li>探索MLflow模块</li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/>技术要求</h1>
			<p>对于本章，您将需要以下先决条件:</p>
			<ul>
				<li>最新版本的Docker安装在您的机器上。如果您没有最新版本，请按照以下网址的说明进行操作:<a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a>。</li>
				<li>访问bash终端(Linux或Windows)。</li>
				<li>访问浏览器。</li>
				<li>Python 3.5以上版本已安装。</li>
				<li>PIP已安装。</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>什么是MLflow？</h1>
			<p>实现基于ML的产品可能是一项艰巨的任务。人们普遍需要减少ML开发生命周期不同步骤之间的摩擦，以及参与该过程的数据科学家和工程师团队之间的摩擦。</p>
			<p>ML从业者，比如数据科学家和ML工程师，使用不同的系统、标准和工具。虽然数据科学家将大部分时间花在使用Jupyter Notebooks等工具开发模型上，但在生产环境中运行时，模型是在软件应用程序的环境中部署的，该环境在规模和可靠性方面要求更高。</p>
			<p>ML项目中常见的情况是由工程团队重新实现模型，创建一个定制的系统来服务于特定的模型。遵循定制方法的团队在模型开发方面面临一系列常见的挑战:</p>
			<ul>
				<li>由于需要创建定制的软件基础设施来开发和服务模型而超出预算的ML项目</li>
				<li>重新实现数据科学家制作的模型时出现翻译错误</li>
				<li>提供预测时的可伸缩性问题</li>
				<li>由于缺乏标准环境，数据科学家之间在复制培训流程方面存在摩擦</li>
			</ul>
			<p>利用ML的公司倾向于创建他们自己的(通常非常费力的)内部系统，以确保ML开发的平稳和结构化的过程。被广泛记录的ML平台包括诸如分别来自优步和脸书的米开朗基罗和FBLearner这样的系统。</p>
			<p>正是在越来越多地采用ML的背景下，MLflow最初在Databricks上创建，并作为一个平台开源，以帮助ML系统的实施。</p>
			<p>MLflow使日常从业者能够在一个平台上管理ML生命周期，从模型开发的迭代到与现代软件系统需求兼容的可靠和可扩展环境中的部署。<a id="_idTextAnchor018"/> <a id="_idTextAnchor019"/></p>
			<h1 id="_idParaDest-18">【MLflow入门</h1>
			<p>接下来，我们将在您的机器上安装MLflow，并准备在本章中使用它。在安装MLflow时，您将有两种选择。第一种选择是通过本书的存储库中提供的基于Docker容器的菜谱:<a href="https://github.com/PacktPublishing/Machine-Learning-Engineering-with-Mlflow.git">https://github . com/packt publishing/Machine-Learning-Engineering-with-ml flow . git</a>。</p>
			<p>要安装它，请遵循以下说明:</p>
			<ol>
				<li>使用以下命令安装软件:<pre>$ git clone https://github.com/PacktPublishing/Machine-Learning-Engineering-with-Mlflow.git $ cd Machine-Learning-Engineering-with-Mlflow $ cd Chapter01</pre></li>
				<li>Docker映像在这个阶段非常简单:它只包含MLflow和sklearn，这是本书这一章要使用的主要工具。为了便于说明，您可以看看<code>Dockerfile</code> : <pre>FROM jupyter/scipy-notebook RUN pip install mlflow RUN pip install sklearn</pre>的内容</li>
				<li>要构建映像，您现在应该运行以下命令:<pre>docker build -t chapter_1_homlflow</pre></li>
				<li>Right after building the image, you can run the <code>./run.sh</code> command:<pre>./run.sh</pre><p class="callout-heading">重要说明</p><p class="callout">确保您的机器上安装了最新版本的Docker非常重要。</p></li>
				<li>打开浏览器到<a href="http://localhost:888"> http://localhost:888 </a>，你应该可以导航到<code>Chapter01</code>文件夹。</li>
			</ol>
			<p>在接下来的<a id="_idIndexMarker002"/>部分中，我们将在之前的步骤中创建的Jupyter环境中使用MLflow开发我们的第一个模型。</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor021"/>使用MLflow开发您的第一个模型</h2>
			<p>从简单的角度来看，在本节中，我们将使用sklearn中的内置样本数据集，这是一个ML <a id="_idIndexMarker003"/>库，我们最初将使用它来探索MLflow特性。对于这一部分，我们将选择著名的<code>Iris</code>数据集来使用MLflow训练多类分类器。</p>
			<p>虹膜<a id="_idIndexMarker004"/>数据集(可从<a href="https://scikit-learn.org/stable/datasets/toy_dataset.html">https://scikit-learn.org/stable/datasets/toy_dataset.html</a>获得的sklearn内置数据集之一)包含以下元素作为特征:萼片长度、萼片宽度、花瓣长度和花瓣宽度。目标变量是鸢尾的种类:鸢尾、鸢尾或海滨鸢尾:</p>
			<ol>
				<li value="1">加载样本数据集:<pre>from sklearn import datasets from sklearn.model_selection import train_test_split dataset = datasets.load_iris() X_train, X_test, y_train, y_test = train_test_split(dataset.data, dataset.target, test_size=0.4)</pre></li>
				<li>Next, let's train your model.<p>用scikit-learn这样的框架训练一个简单的机器模型包括实例化一个估算器，如<code>LogisticRegression</code>并调用<code>fit</code>命令来对scikit-learn中构建的<code>Iris</code>数据集执行训练:</p><pre>from sklearn.linear_model import LogisticRegression
clf = LogisticRegression()
clf.fit(X_train, y_train)</pre><p>前面几行代码只是ML <strong class="bold">工程</strong>过程的一小部分。正如将要展示的，为了生产和确保前面的训练代码可用和可靠，需要创建大量的代码<a id="_idIndexMarker005"/>。MLflow的主要目标之一是帮助建立ML系统<a id="_idIndexMarker006"/>和项目。在接下来的部分中，我们将演示如何使用MLflow来使您的解决方案健壮可靠。</p></li>
				<li>Then, we will add MLflow.<p>再编写几行代码，您就应该能够开始您的第一个MLflow交互了。在下面的代码清单中，我们首先导入<code>mlflow</code>模块，然后导入scikit-learn中的<code>LogisticRegression</code>类。您可以使用随附的Jupyter笔记本运行下一部分:</p><pre>import mlflow
from sklearn.linear_model import LogisticRegression
mlflow.sklearn.autolog()
with mlflow.start_run():
    clf = LogisticRegression()
    clf.fit(X_train, y_train)</pre><p><code>mlflow.sklearn.autolog()</code>指令使您能够自动将实验记录在本地目录<a id="_idIndexMarker007"/>中。它捕获使用中的底层ML库产生的指标。<strong class="bold"> MLflow Tracking </strong>是负责处理指标和日志的模块。默认情况下，MLflow运行的元数据存储在本地文件系统中。</p></li>
				<li>If you run the following excerpt on the accompanying notebook's root document, you should now have the following files in your home directory as a result of running the following command:<pre>$ ls -l 
total 24
-rw-r--r-- 1 jovyan users 12970 Oct 14 16:30 chapther_01_introducing_ml_flow.ipynb
-rw-r--r-- 1 jovyan users    53 Sep 30 20:41 Dockerfile
drwxr-xr-x 4 jovyan users   128 Oct 14 16:32 mlruns
-rwxr-xr-x 1 jovyan users    97 Oct 14 13:20 run.sh</pre><p>这个<code>mlruns</code>文件夹是在你的笔记本文件夹旁边生成的，包含了你的代码在当前上下文中执行的所有实验<a id="_idIndexMarker008"/>。</p><p><code>mlruns</code>文件夹将包含一个带有序列号的文件夹，用于识别您的实验。文件夹的轮廓将如下所示:</p><pre>├── 46dc6db17fb5471a9a23d45407da680f
│   ├── artifacts
│   │   └── model
│   │       ├── MLmodel
│   │       ├── conda.yaml
│   │       ├── input_example.json
│   │       └── model.pkl
│   ├── meta.yaml
│   ├── metrics
│   │   └── training_score
│   ├── params
│   │   ├── C
│   │   …..
│   └── tags
│       ├── mlflow.source.type
│       └── mlflow.user
└── meta.yaml</pre><p>因此，只需很少的努力，我们就有很多可追溯性可用，并且有一个很好的基础来改进。</p></li>
			</ol>
			<p>您的实验<a id="_idIndexMarker009"/>被<code>46dc6db17fb5471a9a23d45407da680f</code>识别为前一个样本上的<code>UUID</code>。在该目录的根目录下，有一个名为<code>meta.yaml</code>的<code>yaml</code>文件，其中包含以下内容:</p>
			<pre>artifact_uri: file:///home/jovyan/mlruns/0/518d3162be7347298abe4c88567ca3e7/artifacts
end_time: 1602693152677
entry_point_name: ''
experiment_id: '0'
lifecycle_stage: active
name: ''
run_id: 518d3162be7347298abe4c88567ca3e7
run_uuid: 518d3162be7347298abe4c88567ca3e7
source_name: ''
source_type: 4
source_version: ''
start_time: 1602693152313
status: 3
tags: []
user_id: jovyan</pre>
			<p>这是您的实验的基本元数据，信息包括开始时间、结束时间、运行的标识(<code>run_id</code>和<code>run_uuid</code>)、生命周期阶段的假设以及执行实验的<a id="_idIndexMarker010"/>用户。这些设置基本上基于默认运行，但提供了与您的实验相关的有价值且可读的信息:</p>
			<pre>├── 46dc6db17fb5471a9a23d45407da680f
│   ├── artifacts
│   │   └── model
│   │       ├── MLmodel
│   │  ^   ├── conda.yaml
│   │       ├── input_example.json
│   │       └── model.pkl</pre>
			<p><code>model.pkl</code>文件包含了模型的一个序列化版本。对于scikit-learn模型，有该模型的Python代码的二进制版本。在自动记录时，从正在使用的底层机器库中利用度量。默认的打包策略是基于一个<code>conda.yaml</code>文件的，具有能够序列化模型的正确的依赖关系。</p>
			<p><code>MLmodel</code>文件是来自MLflow项目的项目的主要定义，其中包含关于如何在当前模型上运行推理的信息。</p>
			<p><code>metrics</code>文件夹包含训练过程的这一特定运行的训练得分值，该值可用于随着模型的进一步改进而对模型进行基准测试。</p>
			<p><a id="_idIndexMarker011"/>上的<code>params</code>文件夹第一个文件夹列表包含逻辑回归模型的默认参数，不同的默认可能性以透明方式列出并自动存储。</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor022"/>探索MLflow模块</h1>
			<p>MLflow模块是提供核心功能的软件组件，可在ML生命周期的不同阶段<a id="_idIndexMarker012"/>提供帮助。MLflow功能通过模块提供，模块是可扩展的组件，用于组织平台中的相关功能。</p>
			<p>以下是MLflow中的内置模块:</p>
			<ul>
				<li><strong class="bold">ML流跟踪</strong>:提供一种机制和UI来处理由ML执行(训练和推理)产生的度量和工件</li>
				<li><strong class="bold"> Mlflow项目</strong>:标准化ML项目的包格式</li>
				<li><strong class="bold"> Mlflow Models </strong>:一种部署到不同类型环境的机制，包括内部环境和云中环境</li>
				<li><strong class="bold"> Mlflow模型注册表</strong>:处理Mlflow中模型及其生命周期管理的模块，包括状态</li>
			</ul>
			<p>为了探索不同的模块，我们将使用以下命令在您的本地环境中安装MLflow:</p>
			<pre>pip install mlflow</pre>
			<p class="callout-heading">重要说明</p>
			<p class="callout">将技术要求正确地安装在您的本地机器上以允许您遵循是至关重要的。您也可以使用具有所需权限的<code>pip</code>命令。</p>
			<h2 id="_idParaDest-21">探索ML <a id="_idTextAnchor023"/>流程项目</h2>
			<p>MLflow项目代表ML项目的基本组织单位。MLflow项目支持三种不同的<a id="_idIndexMarker013"/>环境:Conda环境、Docker和本地系统。</p>
			<p class="callout-heading">重要说明</p>
			<p class="callout">MLProject文件中可用的不同参数的模型细节可在官方文档中查阅，该文档位于<a href="https://www.mlflow.org/docs/latest/projects.html#running-projects">https://www . ml flow . org/docs/latest/projects . html # running-projects</a>。</p>
			<p>以下是一个<code>conda</code>环境的<code>MLproject</code>文件示例:</p>
			<pre>name: condapred
conda_env:
  image: conda.yaml
entry_points:
  main:
    command: "python mljob.py"</pre>
			<p>在<code>conda</code>选项中，假设有一个<code>conda.yaml</code>文件包含所需的依赖项。当要求MLflow运行项目时，它将使用指定的依赖项启动环境。</p>
			<p>基于系统的环境将如下所示:其实很简单:</p>
			<pre>name: syspred
entry_points:
  main:
    command: "python mljob.py"</pre>
			<p>假设底层操作系统包含所有的依赖项，前面的系统变体将基本上依赖于本地环境依赖项。这种方法特别容易与底层操作系统发生库冲突；在已经存在适合项目的操作系统环境的情况下，这可能是有价值的。</p>
			<p>下面的<a id="_idIndexMarker015"/>是基于Docker环境的<code>MLproject</code>文件:</p>
			<pre>name: syspred
docker_env:
  image: stockpred-docker
entry_points:
  main:
    command: "python mljob.py"</pre>
			<p>一旦<a id="_idIndexMarker016"/>有了自己的环境，定义项目外观的主文件就是<code>MLProject</code>文件。MLflow使用该文件来了解它应该如何运行您的项目。</p>
			<h3>在MLflow中开发您的第一个端到端管道</h3>
			<p>我们将在本节中使用MLflow构建一个简单的股票预测项目的原型，并将记录解决方案的不同文件和阶段。您将使用本地安装的MLflow和Docker在您的本地系统中开发它。</p>
			<p class="callout-heading">重要说明</p>
			<p class="callout">在本节中，我们假设MLflow和Docker安装在本地，因为本节中的步骤将在您的本地环境中执行。</p>
			<p>在这个说明性项目中的任务是创建一个基本的MLflow项目，并产生一个工作基线ML模型，以根据一定天数内的市场信号来预测股票市场是上涨还是下跌。</p>
			<p>在本节中，我们将使用一个可用的雅虎金融数据集，在三个月的时间内对https://finance.yahoo.com/quote/BTC-USD/<a href="https://finance.yahoo.com/quote/BTC-USD/">的BTC-美元对进行报价。我们将训练一个模型来预测某一天报价是否会上涨。REST API将通过MLflow进行预测。</a></p>
			<p>我们将一步一步地演示MLflow项目的创建，该项目使用Yahoo API来训练股票数据的分类器，该API用于使用软件包的pandas数据阅读器检索金融信息:</p>
			<ol>
				<li value="1">Add your <code>MLProject</code> file:<pre>name: stockpred
docker_env:
  image: stockpred-docker
entry_points:
  main:
    command: "python train.py"</pre><p>前面的<code>MLProject</code>文件指定依赖项将在Docker中用一个特定的映像名来管理。MLflow将尝试使用您系统上安装的Docker版本来提取图像。如果它没有找到它，它将尝试从Docker Hub检索<a id="_idIndexMarker019"/>它。对于本章的目标，在您的本地机器上运行MLflow是完全可以的。</p><p>我们添加到项目中的第二个<a id="_idIndexMarker020"/>配置是主入口点命令。要执行的命令将在Docker环境中调用<code>train.py</code> Python文件，该文件包含我们项目的代码。</p></li>
				<li>Add a Docker file to the project.<p>此外，您可以指定图像的Docker注册表URL。运行Docker的好处是你的项目不绑定Python语言，这一点我们会在本书的高级部分看到。MLflow API在Rest接口中与官方客户端一起提供:Python、Java和R:</p><pre>FROM continuumio/miniconda:4.5.4
RUN pip install mlflow==1.11.0 \
    &amp;&amp; pip install numpy==1.14.3 \
    &amp;&amp; pip install scipy \
    &amp;&amp; pip install pandas==0.22.0 \
    &amp;&amp; pip install scikit-learn==0.20.4 \
    &amp;&amp; pip install cloudpickle \
    &amp;&amp; pip install pandas_datareader&gt;=0.8.0</pre><p>前面的Docker映像文件是基于开源包Miniconda的，Miniconda是一个免费的最小安装程序，包含一组最小的数据科学包，允许我们控制我们环境中所需的包的细节。</p><p>我们将<a id="_idIndexMarker021"/>指定MLflow(我们的ML平台)<a id="_idIndexMarker022"/>、<code>numpy</code>和<code>scipy</code>的版本用于数值计算。<code>Cloudpickle</code>允许我们轻松地序列化对象。我们将使用<code>pandas</code>来管理数据帧，使用<code>pandas_datareader</code>来方便地从公共资源中检索数据。</p></li>
				<li>Import the packages required for the project.<p>在下面的清单中，我们显式地导入了我们将在训练脚本的执行过程中使用的所有库:读取数据的库，以及与所选择的初始ML模型相关的不同的<code>sklearn</code>模块:</p><pre>import numpy as np
import datetime
import pandas_datareader.data as web
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
import mlflow.sklearn</pre><p>我们明确地为股票市场运动检测问题选择了一个<code>RandomForestClassifier</code>，因为它是一个非常通用的、被广泛接受的分类问题基线模型。</p></li>
				<li>Acquire <a id="_idIndexMarker023"/>your training data.<p>获取Yahoo Finance股票数据集的代码的<a id="_idIndexMarker024"/>部分故意很小，因此我们选择3个月的特定间隔来训练我们的分类器。</p><p><code>acquire_training_data</code>方法返回一个带有相关数据集的<code>pandas</code>数据框:</p><pre>def acquire_training_data():
    start = datetime.datetime(2019, 7, 1)
    end = datetime.datetime(2019, 9, 30)
    df = web.DataReader("BTC-USD", 'yahoo', start, end)
    return df</pre><p>获取的数据格式是exchange APIs中金融证券的经典格式。对于该期间的每一天，我们都检索以下数据:股票的最高价、最低价、开盘价和收盘价，以及成交量。最后一列表示调整后的收盘价，即股息和拆分后的价值:</p><div><img src="img/image001.jpg" alt="Figure 1.1 – Excerpt from the acquired data&#13;&#10;"/></div><p class="figure-caption">图1.1-采集数据摘录</p><p><em class="italic">图1.2 </em>说明了我们希望通过当前数据准备过程实现的目标变量:</p><div><img src="img/image002.jpg" alt="Figure 1.2 – Excerpt from the acquired data with the prediction column&#13;&#10;"/></div><p class="figure-caption">图1.2-从带有预测栏的采集数据中摘录</p></li>
				<li>Make <a id="_idIndexMarker025"/>the data usable by scikit-learn.<p>在前面步骤中获得的数据<a id="_idIndexMarker026"/>显然不能被<code>RandomForestAlgorithm</code>直接使用，它依赖于分类特征。为了便于执行，我们将使用滚动窗口技术将原始数据转换成特征向量。</p><p>基本上，每天的特征向量成为当前和<a id="_idIndexMarker027"/>前一窗口<a id="_idIndexMarker028"/>天之间的增量。在这种情况下，我们使用前一天的市场走势(1表示股票上涨，0表示股票下跌):</p><pre>def digitize(n):
    if n &gt; 0:
        return 1
    return 0
def rolling_window(a, window):
    """
        Takes np.array 'a' and size 'window' as parameters
        Outputs an np.array with all the ordered sequences of values of 'a' of size 'window'
        e.g. Input: ( np.array([1, 2, 3, 4, 5, 6]), 4 )
             Output:
                     array([[1, 2, 3, 4],
                           [2, 3, 4, 5],
                           [3, 4, 5, 6]])
    """
    shape = a.shape[:-1] + (a.shape[-1] - window + 1, window)
    strides = a.strides + (a.strides[-1],)
    return np.lib.stride_tricks.as_strided(a, shape=shape, strides=strides)
def prepare_training_data(data):
    data['Delta'] = data['Close'] - data['Open']
    data['to_predict'] = data['Delta'].apply(lambda d: digitize(d))
    return data</pre><p>以下示例说明了使用前几天的二值化起伏生成的数据帧输出:</p><div><img src="img/image003.jpg" alt="Figure 1.3 – Feature vector with binarized market ups and downs &#13;&#10;"/></div><p class="figure-caption">图1.3–二值化市场涨跌的特征向量</p></li>
				<li>Train and <a id="_idIndexMarker029"/>store your model in MLflow.<p>下面代码清单中的这一部分<a id="_idIndexMarker030"/>调用之前声明的数据准备方法，并执行预测过程。</p><p>主执行还在MLflow环境中显式地记录在当前执行中训练的ML模型。</p><pre>if __name__ == "__main__":
    with mlflow.start_run():
    training_data = acquire_training_data()
    prepared_training_data_df = prepare_training_data(training_data)
    btc_mat = prepared_training_data_df.as_matrix()
    WINDOW_SIZE = 14
    X = rolling_window(btc_mat[:, 7], WINDOW_SIZE)[:-1, :]
    Y = prepared_training_data_df['to_predict'].as_matrix()[WINDOW_SIZE:]
    X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.25, random_state=4284, stratify=Y)
    clf = RandomForestClassifier(bootstrap=True, criterion='gini', min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=50, random_state=4284, verbose=0)
    clf.fit(X_train, y_train)
    predicted = clf.predict(X_test)
    mlflow.sklearn.log_model(clf, "model_random_forest")
    mlflow.log_metric("precision_label_0", precision_score(y_test, predicted, pos_label=0))
    mlflow.log_metric("recall_label_0", recall_score(y_test, predicted, pos_label=0))
    mlflow.log_metric("f1score_label_0", f1_score(y_test, predicted, pos_label=0))
    mlflow.log_metric("precision_label_1", precision_score(y_test, predicted, pos_label=1))
    mlflow.log_metric("recall_label_1", recall_score(y_test, predicted, pos_label=1))
    mlflow.log_metric("f1score_label_1", f1_score(y_test, predicted, pos_label=1))</pre><p><code>mlflow.sklearn.log_model(clf, "model_random_forest")</code>方法负责在训练时保持模型。与前面的例子相反，我们<a id="_idIndexMarker031"/>明确地要求MLflow记录<a id="_idIndexMarker032"/>我们发现相关的模型和指标。记录项目的灵活性允许一个程序将多个模型记录到MLflow中。</p><p>最后，基于之前创建的文件，您的项目布局应该如下所示:</p><pre>├── Dockerfile
├── MLproject
├── README.md
└── train.py</pre></li>
				<li>Build your project's Docker image.<p>为了构建Docker映像，您应该运行以下命令:</p><pre><code>stockpred</code> tag. This image will be usable in MLflow in the subsequent steps as the model is now logged into your local registry. <p>执行该命令后，您应该会看到一个成功的Docker构建:</p><pre>---&gt; 268cb080fed2
Successfully built 268cb080fed2
Successfully tagged stockpred:latest</pre></pre></li>
				<li>Run your project.<p>为了让<a id="_idIndexMarker033"/>运行您的项目，您现在可以运行MLflow项目:</p><pre><strong class="bold">mlflow run .</strong></pre><p>您的输出<a id="_idIndexMarker034"/>应该类似于这里的摘录:</p><pre>MLFLOW_EXPERIMENT_ID=0 stockpred:3451a1f python train.py' in run with ID '442275f18d354564b6259a0188a12575' ===
              precision    recall  f1-score   support
           0       0.61      1.00      0.76        11
           1       1.00      0.22      0.36         9
    accuracy                           0.65        20
   macro avg       0.81      0.61      0.56        20
weighted avg       0.79      0.65      0.58        20
2020/10/15 19:19:39 INFO mlflow.projects: === Run (ID '442275f18d354564b6259a0188a12575') succeeded ===</pre><p>这包含您的模型的打印输出、您的实验的ID以及在当前运行期间捕获的指标。</p></li>
			</ol>
			<p>在这个阶段，您使用MLflow获得了一个简单、可重复的股票预测管道基线，您可以对其进行改进，并轻松地与他人分享。</p>
			<h3>重新运行实验</h3>
			<p>MLflow的另一个非常有用的特性是能够使用与最初运行时相同的<a id="_idIndexMarker035"/>参数重新运行特定的实验。</p>
			<p>例如，您应该能够通过指定项目的GitHub URL来运行您以前的项目:</p>
			<pre>mlflow run https://github.com/PacktPublishing/Machine-Learning-Engineering-with-MLflow/tree/master/Chapter01/stockpred</pre>
			<p>基本上，前面的命令所发生的事情是MLflow将存储库克隆到一个临时目录中，并根据MLProject上的方法执行它。</p>
			<p>实验ID(或名称)允许您使用原始参数运行项目，从而实现项目的完全再现性。</p>
			<p>MLflow项目功能允许您的项目在Kubernetes和Databricks等高级云环境中运行。无缝扩展您的ML工作是MLflow等平台的主要卖点之一。</p>
			<p>正如您在当前章节中看到的，<strong class="bold"> MLflow项目</strong>模块允许执行被视为独立项目的可重复ML作业。</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor024"/>探索物流跟踪</h2>
			<p><strong class="bold">ml流量跟踪</strong>组件<a id="_idIndexMarker036"/>负责可观察性。这个模块<a id="_idIndexMarker038"/>的主要<a id="_idIndexMarker037"/>特性是记录MLflow执行的度量、工件和参数。它提供了可视化和工件管理特性。</p>
			<p>在生产环境中，它被用作在Python中实现的集中式跟踪服务器，可以由组织中的一组ML实践者共享。这使得ML模型的改进能够在组织内共享。</p>
			<p>在<em class="italic">图1.4 </em>中，您可以看到一个记录您的模型的所有运行的界面，并允许您记录您的实验的可观察值(指标、文件、模型和工件)。对于每次运行，您可以查看和比较模块的不同指标和参数。</p>
			<p>它解决了当模型开发人员在不同的参数和设置上比较他们的模型的不同迭代时的常见问题。</p>
			<p>下面的<a id="_idIndexMarker039"/>屏幕截图展示了我们上次运行之前模型的不同<a id="_idIndexMarker040"/>指标:</p>
			<div><div><img src="img/image004.jpg" alt="Figure 1.4 – Sample of the MLFlow interface/UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图1.4–ml flow界面/UI示例</p>
			<p>MLflow允许检查与每个模型及其相关元数据相关的任意工件，允许比较不同运行的度量。您可以看到生成您的实验的特定运行的代码的运行id和Git散列:</p>
			<div><div><img src="img/image005.jpg" alt="Figure 1.5 – Inspecting logged model artifacts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图1.5–检查记录的模型工件</p>
			<p>在<code>stockpred</code>的<a id="_idIndexMarker041"/>当前目录中，您可以<a id="_idIndexMarker042"/>运行以下命令来访问您的运行结果:</p>
			<pre>mlflow ui</pre>
			<p>在本地运行MLflow UI将使其在以下URL可用:<a href="http://127.0.0.1:5000/"> http://127.0.0.1:5000/ </a>。</p>
			<p>在下面的屏幕截图中显示的运行的特殊情况下，我们有一个命名的实验，其中调整了前一个示例中的窗口大小参数。在F1分数方面，可以看到算法性能之间的明显差异:</p>
			<div><div><img src="img/image006.jpg" alt="Figure 1.6 – Listing of MLflow runs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图1.6–ml flow运行列表</p>
			<p>MLFlow <a id="_idIndexMarker044"/>跟踪的另一个非常有用的特性是能够在不同的作业运行之间进行比较:</p>
			<div><div><img src="img/image007.jpg" alt="Figure 1.7 – Comparison of F1 metrics of job runs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图1.7–作业运行的F1指标对比</p>
			<p>这个预先的可视化允许从业者决定在产品中使用哪个模型，或者是否进一步迭代。</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor025"/>探索物流模型</h2>
			<p><strong class="bold"> MLflow模型</strong>是<a id="_idIndexMarker045"/>核心组件，处理MLflow中支持的不同模型<a id="_idIndexMarker046"/>风格，并在不同的执行环境中进行部署。</p>
			<p>我们现在将<a id="_idIndexMarker047"/>深入研究MLflow最新版本中支持的不同模型。</p>
			<p>如<em class="italic">MLflow入门</em>部分所示，ml flow模型有一个特定的序列化方法，用于模型以其内部格式持久化。例如，在<code>stockpred</code>项目中实现的模型的序列化文件夹如下所示:</p>
			<pre>├── MLmodel
├── conda.yaml
└── model.pkl</pre>
			<p>在内部，MLflow sklearn模型与运行时的<code>conda</code>文件及其依赖关系以及源代码记录的pickled模型一起保存:</p>
			<pre>artifact_path: model_random_forest
flavors:
  python_function:
    env: conda.yaml
    loader_module: mlflow.sklearn
    model_path: model.pkl
    python_version: 3.7.6
  sklearn:
    pickled_model: model.pkl
    serialization_format: cloudpickle
    sklearn_version: 0.23.2
run_id: 22c91480dc2641b88131c50209073113
utc_time_created: '2020-10-15 20:16:26.619071'
~</pre>
			<p>默认情况下，MLflow支持以两种方式提供模型，即以<code>python_function</code>或<code>s</code> <code>klearn</code>格式。这些风格基本上是服务于模型的工具或环境使用的一种格式。</p>
			<p>使用上述方法的一个很好的<a id="_idIndexMarker048"/>例子是<a id="_idIndexMarker049"/>能够通过执行下面的命令来服务您的模型，而不需要任何额外的代码:</p>
			<pre>mlflow models serve -m ./mlruns/0/b9ee36e80a934cef9cac3a0513db515c/artifacts/model_random_forest/</pre>
			<p>您可以访问一个非常简单的web服务器来运行您的模型。您的模型预测界面可以通过运行以下命令来执行:</p>
			<pre>curl http://127.0.0.1:5000/invocations -H 'Content-Type: application/json' -d '{"data":[[1,1,1,1,0,1,1,1,0,1,1,1,0,0]]}' [1]%</pre>
			<p>对我们模型的API调用的响应是<code>1</code>；正如我们的预测变量所定义的，这意味着在下一次读数中，股票将会上涨。</p>
			<p>最后几个步骤概述了MLflow作为模型开发的端到端工具是多么强大，包括ML服务的基于REST的API原型。</p>
			<p>MLflow模型组件允许创建定制的Python模块，只要遵循预测接口，这些模块将具有与内置模型相同的优势。</p>
			<p>一些受支持的著名模型类型将在接下来的章节中探讨，包括以下内容:</p>
			<ul>
				<li>XGBoost模型格式</li>
				<li>r函数</li>
				<li>H2O模型</li>
				<li>克拉斯</li>
				<li>PyTorch</li>
				<li>Sklearn</li>
				<li>火花MLib</li>
				<li>张量流</li>
				<li>法斯泰</li>
			</ul>
			<p>支持<a id="_idIndexMarker050"/>最流行的ML类型的<a id="_idIndexMarker051"/>模型，结合其内部和云部署的内置功能，是MLflow模型的最强特性之一。我们将在与部署相关的章节中对此进行更详细的探讨。</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor026"/>探索MLflow模型注册表</h2>
			<p>MLflow中的模型注册组件为ML开发人员提供了模型生命周期管理的抽象。它是一个组织或功能的<a id="_idIndexMarker053"/>集中存储，允许组织中的模型被协作地共享、创建和归档。</p>
			<p>可以使用MLflow的不同API和UI来管理模型。<em class="italic">图1.7 </em>展示了可用于注册模型的跟踪<a id="_idTextAnchor027"/>服务器中的工件UI:</p>
			<div><div><img src="img/image008.jpg" alt="Figure 1.8 – Registering a model as an artifact&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图1.8–将模型注册为工件</p>
			<p>注册模型后，您可以用相关的元数据对注册的模型进行注释，并管理其生命周期。一个例子是将模型放在试生产环境中，并通过将模型发送到生产环境来管理生命周期:</p>
			<div><div><img src="img/image009.jpg" alt="Figure 1.9 – Managing different model versions and stages&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图1.9–管理不同的模型版本和阶段</p>
			<p>模型<a id="_idIndexMarker054"/>注册模块将在本书<a id="_idIndexMarker055"/>中进一步探讨，详细介绍如何建立一个中央服务器和管理ML模型生命周期，从概念到逐步淘汰一个模型。</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor028"/>总结</h1>
			<p>在这一章中，我们介绍了MLflow，并探讨了采用ML平台以减少ML开发中从模型开发到生产的时间背后的一些动机。有了本章中获得的知识和经验，你可以开始改进并使你的ML开发工作流程可重复和可跟踪。</p>
			<p>我们深入研究了平台的每个重要模块:项目、模型、跟踪器和模型注册。特别强调的是用实际例子来说明每个核心功能，让您有一个动手操作平台的方法。MLflow提供了多种开箱即用的特性，这些特性将通过最少的代码和配置减少ML开发生命周期中的摩擦。MLflow提供了现成的指标管理、模型管理和再现性。</p>
			<p>在接下来的章节中，我们将在这些介绍性知识的基础上，扩展我们在构建实用的ML平台方面的技能和知识。</p>
			<p>我们在本章简要介绍了股市预测的用例，这将在本书的其余部分使用。在下一章中，我们将集中讨论股票市场预测的ML问题的严格定义。</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor029"/>延伸阅读</h1>
			<p>为了增强您的知识，您可以参考以下链接中的文档:</p>
			<ul>
				<li>MLflow的参考信息可在此处获得:<a href="https://www.mlflow.org/docs/latest/">https://www.mlflow.org/docs/latest/</a></li>
				<li>ML平台复习笔记:<a href="https://medium.com/nlauchande/review-notes-of-ml-platforms-uber-michelangelo-e133eb6031da">https://medium . com/nlauchande/review-notes-of-ML-platforms-Uber-Michelangelo-e 133 EB 6031 da</a></li>
				<li>MLflow技术论文:<a href="https://www-cs.stanford.edu/people/matei/papers/2018/ieee_mlflow.pdf">https://www-cs . Stanford . edu/people/matei/papers/2018/IEEE _ ml flow . pdf</a></li>
			</ul>
		</div>
	

</body></html>