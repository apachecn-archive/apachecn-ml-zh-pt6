<html><head/><body>





<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style>
<div><div><h1 id="_idParaDest-101"><em class="italic"> <a id="_idTextAnchor102"/>第9章</em>:在生产中使用已部署的TPOT模型</h1>
			<p>你已经进入了最后一章，祝贺你！到目前为止，您已经通过解决分类和回归任务学习了TPOT的基础知识，TPOT如何使用Dask和神经网络，以及如何在本地和云中部署机器学习模型。</p>
			<p>这一章将起到锦上添花的作用，因为您将学习如何与您部署的模型进行通信，以构建一个甚至5岁孩子都可以使用的东西。更准确地说，您将学习如何通过笔记本环境和简单的GUI web应用程序与API通信。</p>
			<p>本章将涵盖以下主题:</p>
			<ul>
				<li>在笔记本环境中进行预测</li>
				<li>开发一个简单的GUI web应用程序</li>
				<li>在GUI环境中进行预测</li>
			</ul>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor103"/>技术要求</h1>
			<p>这是本书的最后一章，所以假设了一些先验知识。你需要知道如何用TPOT构建基本的机器学习模型来部署它们。假设您的模型被部署到在第8章  <em class="italic">、TPOT模型部署</em>中创建的AWS虚拟机。如果不是这样，请重温那一章。</p>
			<p>这一章代码会相当多，如果卡住了可以参考官方的GitHub资源库:<a href="https://github.com/PacktPublishing/Machine-Learning-Automation-with-TPOT/tree/main/Chapter09">https://GitHub . com/packt publishing/Machine-Learning-Automation-with-TPOT/tree/main/chapter 09</a>。</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor104"/>在笔记本环境中进行预测</h1>
			<p>如果你在前一章之后休息了一天(或几天)，很可能你与远程虚拟机的连接就结束了。因此，您需要重新连接并再次启动API。有很多方法可以让你的API一直运行，但是这超出了本书的范围。此外，如果您已经将<code>TPOT_Book_KeyPair.pem</code>文件移动到其他文件夹，您必须重置权限:</p>
			<ol>
				<li>记住这一点，仅当您必须重置权限时，才执行下面代码片段中的第一个命令行:<pre><strong class="bold">&gt; chmod 400 TPOT_Book_KeyPair.pem</strong> <strong class="bold">&gt; ssh -i "TPOT_Book_KeyPair.pem" ubuntu@ec2-18-220-113-224.us-east-2.compute.amazonaws.com</strong> <strong class="bold">&gt; cd api</strong> <strong class="bold">&gt; python3 app.py</strong></pre></li>
				<li>Your API is running now. The next step is to open a JupyterLab or Jupyter Notebook environment and make a request. You'll need the <code>requests</code> library to do so, so here's how to import it:<pre>import requests</pre><p>接下来让我们声明几个变量。这些将保存主机名、端口和端点的值:</p><pre>HOST ='http://ec2-18-220-113-224.us-east-2.compute.amazonaws.com'
PORT = '8000'
ENDPOINT = '/predict'</pre><p>由此，我们可以轻松地将这三个变量连接成一个URL:</p><pre>URL = f'{HOST}:{PORT}{ENDPOINT}'
URL</pre><p>它应该是这样的:</p><div><img src="img/B16954_09_1.jpg" alt="Figure 9.1 – URL connection string&#13;&#10;" width="1128" height="40"/></div><p class="figure-caption">图9.1–URL连接字符串</p><p>由于主机名的不同，您的名称会有所不同。</p></li>
				<li>Next, we'll <a id="_idIndexMarker539"/>declare a dictionary that will serve as input data. It will be identical to the data sent in the previous chapter through Postman. Here's the code snippet:<pre>in_data = {
    'SepalLength': 0.4,
    'SepalWidth': 3.1,
    'PetalLength': 0.1,
    'PetalWidth': 14
}</pre><p>这就是我们提出请求的全部内容。让我们接下来做那件事。</p></li>
				<li>You can use the <code>post()</code> function from the <code>requests</code> package to make a POST request. Two parameters are required – the URL and the data in JSON format:<pre>req = requests.post(url=URL, json=in_data)
req</pre><p>结果显示在下图中:</p><pre>response = req.content
response</pre><p>下面是回应的样子:</p><div><img src="img/B16954_09_3.jpg" alt="Figure 9.3 – API response as a string&#13;&#10;" width="1379" height="66"/></div><p class="figure-caption">图9.3–字符串形式的API响应</p><p>如您所见，预测成功返回，但默认情况下不是期望的格式。</p></li>
				<li>To change that, you'll <a id="_idIndexMarker540"/>need to transform the response string to a JSON object. You can use the <code>loads()</code> function from the <code>json</code> package to do so:<pre>import json
response_json = json.loads(response)
response_json</pre><p>结果如下:</p><div><img src="img/B16954_09_4.jpg" alt="Figure 9.4 – API response as a JSON object&#13;&#10;" width="558" height="184"/></div><p class="figure-caption">图9.4–作为JSON对象的API响应</p></li>
				<li>You can access the <a id="_idIndexMarker541"/>predicted class (or any other property) just as you would for a normal dictionary object. Here's an example:<pre>response_json['Prediction']</pre><p>以下是返回的内容:</p></li>
			</ol>
			<div><div><img src="img/B16954_09_5.jpg" alt="Figure 9.5 – API predicted class&#13;&#10;" width="175" height="37"/>
				</div>
			</div>
			<p class="figure-caption">图9.5–API预测类</p>
			<p>这就是用Python从部署的REST API中获得预测的基本方法！在下一节中，您将围绕这个API构建一个基本的交互式web应用程序，使它对任何人来说都非常简单。</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor105"/>开发一个简单的GUI web应用程序</h1>
			<p>本节旨在展示如何使用<code>Flask</code>框架来开发一个简单的web应用程序。焦点转移到构建一个捕捉表单数据的应用程序，然后将表单数据传递给我们部署的机器学习API:</p>
			<ol>
				<li value="1">To start, create the following directory structure:<div><img src="img/B16954_09_6.jpg" alt="Figure 9.6 – Web application directory structure&#13;&#10;" width="385" height="163"/></div><p class="figure-caption">图9.6-Web应用程序目录结构</p><p>大部分逻辑在<code>app.py</code>中处理，<code>templates</code>文件夹用于存储应用程序的HTML文件——稍后会详细介绍。</p></li>
				<li>This time we'll organize the code a bit better, so you'll need to create an additional file for storing the environment variables. Inside the root directory (<code>webapp</code>), create a file called <code>.env</code> – and populate it with the following:<pre>SECRET_KEY=SecretKey
HOST=0.0.0.0
PORT=9000
API_ENDPOINT=http://ec2-18-220-113-224.us-east-2.compute.amazonaws.com:8000/predict</pre><p>在开发任何类型的web应用程序时，创建这样一个单独的文件被认为是最佳实践。</p><p>要使用这些<a id="_idIndexMarker543"/>环境变量，您必须在您的虚拟环境中安装一个额外的包:</p><pre><strong class="bold">&gt; pip install python-dotenv</strong></pre></li>
				<li>Let's build the basic structure of the application now. Open the <code>app.py</code> file and write the following code:<pre>import os
from flask import Flask, render_template
from dotenv import load_dotenv
load_dotenv('.env')
app = Flask(__name__)
@app.route('/')
def index():
    return render_template('index.html')
if __name__ == '__main__':
    app.run(host=os.getenv('HOST'), port=os.getenv('PORT'))</pre><p>如果您现在运行这个应用程序，您不会得到一个错误，但是屏幕上不会显示任何东西。原因很简单——我们还没有处理<code>index.html</code>文件。在此之前，让我们讨论一下代码中唯一可能不熟悉的部分:<code>render_template()</code>函数。简单地说，这个函数将显示一个HTML文件，而不仅仅是显示一个字符串或函数返回的值。有一种传递参数的方法，稍后会详细介绍。</p></li>
				<li>Onto the <code>index.html</code> now – here's <a id="_idIndexMarker544"/>the code you can paste inside the file:<pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Iris Predictioner&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Welcome to Iris Predictioner&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</pre><p>如果你以前没有写过一行HTML，不要担心——它是一种简单的标记语言。把你在这里看到的一切都当成样板。我们感兴趣的是标签里面的内容。</p><p>如果您现在运行您的应用程序，它看起来会是这样的:</p><div><img src="img/B16954_09_7.jpg" alt="Figure 9.7 – Iris prediction application (v1)&#13;&#10;" width="812" height="266"/></div><p class="figure-caption">图9.7–虹膜预测应用程序(v1)</p><p>这是一个简单而无聊的网络应用程序，但至少它是有效的。</p></li>
				<li>如前所述，我们的<a id="_idIndexMarker545"/> web应用程序必须以某种方式处理表单数据，所以让我们开始着手这项工作。有一个专门用来处理表单数据的包叫做<code>Flask-WTF</code>。你可以这样安装:<pre><code>forms.py</code> file in the root directory – /<code>webapp/forms.py</code>. Let's take a look at the code this file contains and explain it:<pre>from flask_wtf import FlaskForm from wtforms import FloatField, SubmitField from wtforms.validators import DataRequired class IrisForm(FlaskForm):     sepal_length = FloatField(         label='Sepal Length', validators=[DataRequired()]     )     sepal_width = FloatField(         label='Sepal Width', validators=[DataRequired()]     )     petal_length = FloatField(         label='Petal Length', validators=[DataRequired()]     )     petal_width = FloatField(         label='Petal Width', validators=[DataRequired()]     )     submit = SubmitField(label='Predict')</pre> <p>好了，那么<a id="_idIndexMarker546"/>这个文件里发生了什么？简而言之，<code>Flask-WTF</code>允许我们以类的形式轻松地为<code>Flask</code>应用程序声明表单。我们可以使用任何内置的字段类型和验证器。对于这个简单的例子，我们只需要float和submit字段(对于flower measurements和submit按钮)。就验证而言，我们只希望没有字段留空。</p> <p>你要做的就是这些，剩下的就交给<code>Flask</code>了。</p> </pre></li>
				<li>现在到了<code>app.py</code>上。需要做一些改变:<ul><li><code>Flask-WTF</code>表单需要配置密钥才能工作。您可以通过访问<code>.env</code>文件来添加它。你声明的值完全是任意的。</li><li>Our index route now needs to allow for both POST and GET methods since it will handle forms. Inside the <code>index()</code> function, you'll have to instantiate the previously written <code>IrisForm</code> class and return relevant results if there are no validation errors once the submit button is clicked.<p>您可以使用<code>validate_on_submit()</code>功能进行检查。如果检查通过，输入数据将以标题格式返回(稍后我们将看到如何显示预测)。如果不是，则返回<code>index.html</code>模板。</p></li><li>A call to <code>render_template()</code> now passes a <a id="_idIndexMarker547"/>parameter to our HTML file – <code>iris_form</code>. This gives access to form data to our HTML file. You'll see how to deal with it in a minute.<p>更改完成后，您的文件应该是这样的:</p><pre>import os
from flask import Flask, render_template
from forms import IrisForm
from dotenv import load_dotenv
load_dotenv('.env')
app = Flask(__name__)
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY')
@app.route('/', methods=['GET', 'POST'])
def index():
    iris_form = IrisForm()
    if iris_form.validate_on_submit():
        return f'''
                &lt;h3&gt;
                    Sepal Length: {iris_form.sepal_length.data}&lt;br&gt;
                    Sepal Width: {iris_form.sepal_width.data}&lt;br&gt;
                    Petal Length: {iris_form.petal_length.data}&lt;br&gt;
                    Petal Width: {iris_form.petal_width.data}
                &lt;/h3&gt;
            '''
    return render_template('index.html', iris_form=iris_form)
if __name__ == '__main__':
    app.run(host=os.getenv('HOST'), port=os.getenv('PORT'))</pre><p>我们快到了。接下来让我们调整一下<code>index.html</code>文件。</p></li></ul></li>
				<li><code>index.html</code> is the <a id="_idIndexMarker548"/>last file you'll need to tweak to have a working application. The only thing we need inside it is a form that displays the fields declared earlier. It's also <a id="_idIndexMarker549"/>mandatory to protect your app from <strong class="bold">Cross-Site Request Forgery</strong> (<strong class="bold">CSRF</strong>) attacks. To do so, you'll have to place a token before the form fields.<p>HTML文件应该是这样的:</p><pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Iris Predictioner&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Welcome to Iris Predictioner&lt;/h1&gt;
    &lt;form method="POST" action="{{ url_for('index') }}"&gt;
        {{ iris_form.csrf_token }}
        {{ iris_form.sepal_length.label }} {{ iris_form.sepal_length(size=18) }}
        &lt;br&gt;
        {{ iris_form.sepal_width.label }} {{ iris_form.sepal_width(size=18) }}
        &lt;br&gt;
        {{ iris_form.petal_length.label }} {{ iris_form.petal_length(size=18) }}
        &lt;br&gt;
        {{ iris_form.petal_width.label }} {{ iris_form.petal_width(size=18) }}
        &lt;br&gt;
        &lt;input type="submit" value="Predict"&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</pre><p>如您所见，要访问从Python文件发送的参数，您必须用双花括号将代码括起来。</p></li>
				<li>如果你现在启动这个应用程序，你会在屏幕上看到以下内容:</li>
			</ol>
			<div><div><img src="img/B16954_09_8.jpg" alt="Figure 9.8 – Iris prediction application&#13;&#10;" width="824" height="527"/>
				</div>
			</div>
			<p class="figure-caption">图9.8–虹膜预测应用</p>
			<p>这就是你的机器学习应用的前端！有点丑，不过以后再做造型。让我们先测试一下功能。</p>
			<p>如果任何输入值为空，我们不希望表单被提交。如果立即按下按钮，会发生以下情况:</p>
			<div><div><img src="img/B16954_09_9.jpg" alt="Figure 9.9 – Iris prediction application form validation (1)&#13;&#10;" width="802" height="526"/>
				</div>
			</div>
			<p class="figure-caption">图9.9–Iris预测申请表验证(1)</p>
			<p>验证测试1–检查。让我们看看如果只有一个输入字段为空会发生什么:</p>
			<div><div><img src="img/B16954_09_10.jpg" alt="Figure 9.10 – Iris prediction application form validation (2)&#13;&#10;" width="731" height="531"/>
				</div>
			</div>
			<p class="figure-caption">图9.10–Iris预测申请表验证(2)</p>
			<p>正如您所料，会出现相同的<a id="_idIndexMarker551"/>消息。总之，如果任何输入字段为空，就不能提交表单。</p>
			<p>要继续，请填写所有字段，如下图所示:</p>
			<div><div><img src="img/B16954_09_11.jpg" alt="Figure 9.11 – Iris prediction application form values&#13;&#10;" width="770" height="501"/>
				</div>
			</div>
			<p class="figure-caption">图9.11–Iris预测应用程序表单值</p>
			<p>如果您现在单击该按钮，您会看到以下结果:</p>
			<div><div><img src="img/B16954_09_12.jpg" alt="Figure 9.12 – Iris prediction application results&#13;&#10;" width="764" height="343"/>
				</div>
			</div>
			<p class="figure-caption">图9.12–虹膜预测应用结果</p>
			<p>到目前为止，一切正常，但在将应用程序连接到我们的虹膜预测API之前，我们还需要做一步——样式化。这一步是可选的，因为如果您决定立即跳转到API连接部分，应用程序仍将工作。</p>
			<p>为你的Flask应用程序设置适当的样式需要一些工作和重构。你可以在这里找到所有的步骤。请记住，这本书假设没有HTML和CSS知识。您可以自由复制和粘贴这些文件的内容，但我们鼓励您自己进一步探索:</p>
			<ol>
				<li value="1">Let's start with <code>app.py</code>. Instead of returning an <code>H2</code> tag with input values printed as a single long string, we'll return an HTML template that will show a table. For now, we'll fill out the input data only and set dummy values for prediction and prediction probability.<p>更改后的文件应该是这样的:</p><pre>import os
from flask import Flask, render_template
from forms import IrisForm
from dotenv import load_dotenv
load_dotenv('.env')
app = Flask(__name__)
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY')
@app.route('/', methods=['GET', 'POST'])
def index():
    iris_form = IrisForm()
    if iris_form.validate_on_submit():
        <strong class="bold">return render_template(</strong>
<strong class="bold">            'predicted.html',</strong>
<strong class="bold">            sepal_length=iris_form.sepal_length.data,</strong>
<strong class="bold">            sepal_width=iris_form.sepal_width.data,</strong>
<strong class="bold">            petal_length=iris_form.petal_length.data,</strong>
<strong class="bold">            petal_width=iris_form.petal_width.data,</strong>
<strong class="bold">            prediction='Prediction',</strong>
<strong class="bold">            probability=100000</strong>
<strong class="bold">        )</strong>
    return render_template('index.html', iris_form=iris_form)
if __name__ == '__main__':
    app.run(host=os.getenv('HOST'), port=os.getenv('PORT'))</pre></li>
				<li>Let's create a <a id="_idIndexMarker553"/>template file while we're at it. Under <code>/templates</code>, create a <code>predicted.html</code> file. As mentioned earlier, this file will contain a table showing the API response (once we implement it).<p>文件应该是这样的:</p><pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}"&gt;
    &lt;title&gt;Iris Predictioner&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;h1&gt;Predictions:&lt;/h1&gt;
        &lt;table&gt;
            &lt;thead&gt;
              &lt;tr&gt;&lt;th&gt;Attribute&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
              &lt;tr&gt;&lt;td&gt;Sepal Length&lt;/td&gt;&lt;td&gt;{{ sepal_length }}&lt;/td&gt;&lt;/tr&gt;
              &lt;tr&gt;&lt;td&gt;Sepal Width&lt;/td&gt;&lt;td&gt;{{ sepal_width }}&lt;/td&gt;&lt;/tr&gt;
              &lt;tr&gt;&lt;td&gt;Petal Length&lt;/td&gt;td&gt;{{ petal_length }}&lt;/td&gt;&lt;/tr&gt;
              &lt;tr&gt;&lt;td&gt;Petal Width&lt;/td&gt;&lt;td&gt;{{ petal_width }}&lt;/td&gt;&lt;/tr&gt;
              &lt;tr&gt;&lt;td&gt;Prediction&lt;/td&gt;&lt;td&gt;{{ prediction }}&lt;/td&gt;&lt;/tr&gt;
              &lt;tr&gt;&lt;td&gt;Probability&lt;/td&gt;&lt;td&gt;{{ probability }}&lt;/td&gt;&lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre><p>如您所见，我们利用了参数传递的能力来显示进出预测模型的数据。如果你想知道文档头中的CSS文件链接是怎么回事——现在不用担心。在处理CSS之前，我们还需要做一件事情。</p></li>
				<li>最后，让我们把<a id="_idIndexMarker554"/>重新格式化<code>index.html</code>。这个文件只需要很小的改动——几个CSS类和几个<code>div</code>元素。下面是重新格式化版本的完整代码片段:<pre>&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt;     &lt;meta charset="UTF-8"&gt;     &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;     &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; <strong class="bold">    &lt;link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}"&gt;</strong>     &lt;title&gt;Iris Predictioner&lt;/title&gt; &lt;/head&gt; &lt;body&gt;     <strong class="bold">&lt;div class="container"&gt;</strong>         &lt;h1&gt;Welcome to Iris Predictioner&lt;/h1&gt;         &lt;form method="POST" action="{{ url_for('index') }}"&gt;             {{ iris_form.csrf_token }}             <strong class="bold">&lt;div class="single-input"&gt;</strong>                 {{ iris_form.sepal_length.label }} {{ iris_form.sepal_length(size=18) }}             <strong class="bold">&lt;/div&gt;</strong> <strong class="bold">            &lt;div class="single-input"&gt;</strong>                 {{ iris_form.sepal_width.label }} {{ iris_form.sepal_width(size=18) }}             <strong class="bold">&lt;/div&gt;</strong> <strong class="bold">            &lt;div class="single-input"&gt;</strong>                 {{ iris_form.petal_length.label }} {{ iris_form.petal_length(size=18) }}             <strong class="bold">&lt;/div&gt;</strong> <strong class="bold">            &lt;div class="single-input"&gt;</strong>                 {{ iris_form.petal_width.label }} {{ iris_form.petal_width(size=18) }}             <strong class="bold">&lt;/div&gt;</strong> <strong class="bold">            &lt;input class="btn-submit" type="submit" value="Predict"&gt;</strong>         &lt;/form&gt;     <strong class="bold">&lt;/div&gt;</strong> &lt;/body&gt; &lt;/html&gt;</pre></li>
				<li>We're almost <a id="_idIndexMarker555"/>there. So far, you've refactored every file that needed refactoring, and now you'll create an additional folder and file. Inside the root directory, create a folder named <code>static</code>. Once created, make an additional folder inside it called <code>css</code>. This folder will contain all stylings for our application. Inside the <code>css</code> folder, create a file called <code>main.css</code>.<p>总而言之，一旦创建了这些文件夹和文件，目录结构应该是这样的:</p><div><img src="img/B16954_09_13.jpg" alt="Figure 9.13 – New directory structure&#13;&#10;" width="460" height="368"/></div><pre>@import url('https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&amp;display=swap');
* { margin: 0; padding: 0; box-sizing: border-box;
    font-family: 'Open Sans', sans-serif; }
body { background-color: #f2f2f2; }
.container { width: 800px; height: 100vh; margin: 0 auto;
    background-color: #ffffff; padding: 0 35px; }
.container &gt; h1 { padding: 35px 0; font-size: 36px;
    font-weight: 600; }
.single-input { display: flex; flex-direction: column;
    margin-bottom: 20px; }
.single-input label { font-weight: 600; }
.single-input label::after { content: ":" }
.single-input input { height: 35px; line-height: 35px;
    padding-left: 10px; }
.btn-submit { width: 100%; height: 35px;
    background-color: #f2f2f2; font-weight: 600;
    cursor: pointer; border: 2px solid #dddddd;
    border-radius: 8px; }
table { font-size: 18px; width: 100%; text-align: left; }</pre><p>我们结束了。让我们运行应用程序，看看它现在是什么样子。</p></li>
				<li>如果您现在重新运行<a id="_idIndexMarker556"/>应用程序，您会看到样式生效。下图显示了输入表单的外观:</li>
			</ol>
			<div><div><img src="img/B16954_09_14.jpg" alt="Figure 9.14 – Styled Iris prediction application&#13;&#10;" width="1173" height="782"/>
				</div>
			</div>
			<p class="figure-caption">图9.14–风格化虹膜预测应用程序</p>
			<p>这个应用程序现在看起来一点也不完美，但它至少是一个像样的形式。让我们按照下图所示进行填写:</p>
			<div><div><img src="img/B16954_09_15.jpg" alt="Figure 9.15 – Styled Iris prediction application (2)&#13;&#10;" width="1185" height="778"/>
				</div>
			</div>
			<p class="figure-caption">图9.15–风格化虹膜预测应用程序(2)</p>
			<p>最后，让我们<a id="_idIndexMarker557"/>点击<strong class="bold">预测</strong>按钮，看看另一个页面看起来如何:</p>
			<div><div><img src="img/B16954_09_16.jpg" alt="Figure 9.16 – Iris prediction application predictions&#13;&#10;" width="1178" height="542"/>
				</div>
			</div>
			<p class="figure-caption">图9.16–虹膜预测应用预测</p>
			<p>我们姑且称之为<a id="_idIndexMarker558"/>日时尚。这个应用程序现在已经相当不错了，但是您可以自由地对它进行进一步的调整。</p>
			<p>这样你就知道了——如何围绕机器学习模型构建一个<code>Flask</code>应用程序并设计其风格。下一节将把应用程序连接到我们的API，使应用程序功能齐全。在那里见。</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor106"/>在图形用户界面环境中进行预测</h1>
			<p>欢迎来到本书的最后一部分。这一节将把我们简单的web应用程序与已经部署的机器学习API联系起来。这非常类似于生产环境，其中部署了一个或多个机器学习模型，应用程序开发团队希望在他们的应用程序中使用它们。唯一的区别是你既是数据科学团队又是应用程序开发团队。</p>
			<p>同样，我们必须对应用程序结构进行一些更改:</p>
			<ol>
				<li value="1">Let's start with the simpler part. Inside the root directory, create a Python file called <code>predictor.py</code>. This file will hold a single function that implements the logic discussed at the beginning of this chapter when we made predictions in the notebook environment.<p>简单地说，这个函数必须向API发出POST请求，并以JSON格式返回响应。</p><p>以下是该文件的完整代码片段:</p><pre>import os
import json
import requests
from dotenv import load_dotenv
load_dotenv('.env')
def predict(sepal_length, sepal_width, petal_length, petal_width):
    URL = os.getenv('API_ENDPOINT')
    req = requests.post(
        url=URL,
        json={
            'SepalLength': sepal_length,
            'SepalWidth': sepal_width,
            'PetalLength': petal_length,
            'PetalWidth': petal_width
        }
    )
    response = json.loads(req.content)
    return response</pre><p>请记住，URL参数的值在您的机器上会有所不同，因此请相应地进行更改。</p><p>没有必要在<a id="_idIndexMarker560"/>中进一步解释这个代码片段，因为它与你之前看到和编写的代码几乎相同。</p></li>
				<li>Let's make a couple of changes in <code>app.py</code> now. We'll import this file and call the <code>predict()</code> function right after the input fields are validated. Once the response is returned, its values are passed as parameters to the corresponding field of the <code>return</code> statement.<p>以下是<code>app.py</code>文件的完整代码片段:</p><pre><strong class="bold">import os</strong>
<strong class="bold">import numpy as np</strong>
from flask import Flask, render_template
from forms import IrisForm
<strong class="bold">from predictor import predict</strong>
from dotenv import load_dotenv
load_dotenv('.env')
app = Flask(__name__)
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY')
@app.route('/', methods=['GET', 'POST'])
def index():
    iris_form = IrisForm()
    if iris_form.validate_on_submit():
<strong class="bold">        pred_response = predict(</strong>
<strong class="bold">            sepal_length=iris_form.sepal_length.data,</strong>
<strong class="bold">            sepal_width=iris_form.sepal_width.data,</strong>
<strong class="bold">            petal_length=iris_form.petal_length.data,</strong>
<strong class="bold">            petal_width=iris_form.petal_width.data</strong>
<strong class="bold">        )</strong>
        return render_template(
            'predicted.html',
            sepal_length=pred_response['In_PetalLength'],
            sepal_width=pred_response['In_PetalWidth'],
            petal_length=pred_response['In_SepalLength'],
            petal_width=pred_response['In_SepalWidth'],
            <strong class="bold">prediction=pred_response['Prediction'],</strong>
<strong class="bold">            probability=f"{np.round((pred_response['Probability'] * 100), 2)}%"</strong>
<strong class="bold">        )</strong>
    return render_template('index.html', iris_form=iris_form)
if __name__ == '__main__':
    app.run(host=os.getenv('HOST'), port=os.getenv('PORT'))</pre><p>如您所见，<a id="_idIndexMarker561"/>预测概率被转换为百分比并四舍五入到小数点后两位。这样做的唯一原因是为了在应用程序中获得格式更好的输出。</p></li>
				<li>现在是有趣的部分——测试。打开应用程序，在表单中输入一些数据。这里有一个例子:</li>
			</ol>
			<div><div><img src="img/B16954_09_17.jpg" alt="Figure 9.17 – Iris prediction application final test&#13;&#10;" width="1172" height="768"/>
				</div>
			</div>
			<p class="figure-caption">图9.17–虹膜预测应用最终测试</p>
			<p>一旦您<a id="_idIndexMarker562"/>点击<strong class="bold">预测</strong>按钮，您将在屏幕上看到以下结果:</p>
			<div><div><img src="img/B16954_09_18.jpg" alt="Figure 9.18 – Iris prediction application final results&#13;&#10;" width="1169" height="537"/>
				</div>
			</div>
			<p class="figure-caption">图9.18–虹膜预测应用最终结果</p>
			<p>这就是你所拥有的——一个基于部署的机器学习模型的完整且完全可用的GUI web应用程序。</p>
			<p>不包括下面的总结，这是本章的最后一节，也是整本书。您现在知道了如何部署机器学习模型，并围绕已部署的模型构建简单的web应用程序。恭喜你！</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor107"/>总结</h1>
			<p>这一章属于大量实践章节的范畴，但是我希望你已经设法跟上了。如果你有，你已经学到了很多——从如何在笔记本环境中进行预测到在一个简单的定制web应用程序中进行预测。</p>
			<p>不仅如此，你还完成了整本书。恭喜你！通过这九章你学到了很多。我们从机器学习的基础开始，通过基本的回归和分类例子，并从那里慢慢建立我们的TPOT知识。您还了解了TPOT如何处理平行训练和神经网络。但是可能你学到的最重要的新技能是模型部署。没有它，你的模型是没有用的，因为没有人能用它们来创造价值。</p>
			<p>像往常一样，你可以自由探索TPOT和它所提供的每一个令人惊叹的功能。这本书应该为你提供一个很好的起点，因为它只用了几百页就让你从零开始围绕你部署的自动化机器学习模型构建web应用程序。这才是你值得骄傲的地方！</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor108"/>问&amp;答</h1>
			<ol>
				<li value="1">您可以使用哪个Python库向部署的REST APIs发出请求？</li>
				<li>发出POST请求时，数据以何种格式提供？</li>
				<li>命名用于构建和处理表单的Flask扩展。</li>
				<li>如果我们在讨论进入机器学习模型的数据，为什么验证web应用程序表单很重要？</li>
				<li>可以通过Flask向HTML模板文件传递参数吗？如果是，如何在HTML中显示它们的值？</li>
				<li>解释链接CSS文件到Flask应用程序的过程。</li>
				<li>解释为什么让机器学习模型闲置在你的电脑上没有意义。</li>
			</ol>
		</div>
	</div>
</body></html>