<html><head/><body>





<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style>
<div><div><h1 id="_idParaDest-92"><em class="italic"> <a id="_idTextAnchor093"/>第八章</em> : TPOT车型部署</h1>
			<p>在这一章中，你将学习如何部署任何自动化的机器学习模型，包括本地主机和云。如果你的目标是制造机器学习驱动的软件，你将了解为什么部署步骤是必要的。假设你知道如何用TPOT训练基本的回归和分类模型。不需要了解最后几章的主题(Dask和神经网络),因为我们在这里不会涉及这些。</p>
			<p>在本章中，您将了解到将您的模型包装在API中并向其他不一定是数据科学家的用户展示其预测能力是多么容易。您还将了解哪些云提供商是让您完全免费入门的最佳选择。</p>
			<p>本章将涵盖以下主题:</p>
			<ul>
				<li>为什么我们需要模型部署？</li>
				<li>介绍<code>Flask</code>和<code>Flask-RESTful</code></li>
				<li>部署自动化模型的最佳实践</li>
				<li>将机器学习模型部署到本地主机</li>
				<li>将机器学习模型部署到云中</li>
			</ul>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor094"/>技术要求</h1>
			<p>如前所述，你需要知道如何用TPOT建立基本的机器学习模型。如果您对这个库还不太适应，请不要担心，因为我们将从头开始开发这个模型。如果你对TPOT完全陌生，请参考<a href="B16954_02_Final_SK_ePub.xhtml#_idTextAnchor036"> <em class="italic">第二章</em></a><em class="italic">深入TPOT</em><a href="B16954_03_Final_SK_ePub.xhtml#_idTextAnchor051"><em class="italic">第三章</em></a><em class="italic">探索回归与TPOT</em><a href="B16954_04_Final_SK_ePub.xhtml#_idTextAnchor058"><em class="italic">第四章</em></a><em class="italic">探索分类与TPOT </em>。</p>
			<p>这一章代码会相当多，如果卡住了可以参考官方的GitHub资源库:<a href="https://github.com/PacktPublishing/Machine-Learning-Automation-with-TPOT/tree/main/Chapter08">https://GitHub . com/packt publishing/Machine-Learning-Automation-with-TPOT/tree/main/chapter 08</a>。</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor095"/>为什么我们需要模型部署？</h1>
			<p>如果你已经在经历训练和优化机器学习模型的麻烦，为什么不更进一步，部署它，让每个人都可以使用它？</p>
			<p>也许你想在web应用程序中使用模型的预测能力。也许你是一名移动应用程序开发人员，想要将机器学习引入Android和iOS。选项层出不穷且各不相同，但所有选项都有一个共同点，即需要部署。</p>
			<p>现在，机器学习模型部署与机器学习无关。目标是编写一个简单的REST API(最好用Python，因为这是整本书使用的语言),并向外界公开任何形式的调用<code>predict()</code>函数的端点。您希望将参数以JSON格式发送到您的应用程序，然后将它们用作模型的输入。一旦做出预测，您可以简单地将它返回给用户。</p>
			<p>是的，这就是机器学习模型部署的全部内容。当然，事情可能会变得更加技术化，但是保持事情的简单性将会让我们达到95%的目标，并且你总是可以进一步探索来挤压那额外的5%。</p>
			<p>当涉及到模型部署的技术方面时，Python为您提供了许多选择。您可以使用<code>Flask</code>和<code>Flask-RESTful</code>、<code>FastAPI</code>、<code>Django</code>或<code>Pyramid</code>。当然，还有其他选择，但它们的“市场份额”或多或少可以忽略不计。从下一节开始，您将使用本章中的第一个选项。</p>
			<p>接下来的部分旨在通过几个基本的实践示例向您介绍这些库。之后我们将深入研究机器学习。</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor096"/>引入烧瓶和烧瓶-RESTful</h1>
			<p><code>Flask</code>是一个用于构建web应用的轻量级框架。它使您能够在需要时开始简单和<a id="_idIndexMarker446"/>规模。<code>Flask-RESTful</code>是对<code>Flask</code>的扩展，它允许你立刻构建REST APIs。</p>
			<p>要开始使用这两个软件，你需要安装它们。您可以从终端执行以下行:</p>
			<pre>&gt; pip install flask flask-restful</pre>
			<p>这就是你开始工作所需要的一切。让我们先来探索一下<code>Flask</code>的基础知识:</p>
			<ol>
				<li>Believe it or not, you'll need only seven lines of code to create your first web application with <code>Flask</code>. It won't do anything useful, but it's still a step in the right direction. <p>首先，您需要导入库并创建一个应用程序实例。然后你必须创建一个函数，返回你想要在网站上显示的内容，并用一个<code>@app.route(route_url)</code>装饰器来装饰这个函数。请记住，您应该用函数应该显示结果的URL字符串替换<code>route_url</code>。如果您传入一个正斜杠(<code>/</code>)，结果将显示在根页面上——但稍后会详细介绍。</p><p>最后，您将使用<a id="_idIndexMarker448"/>通过<code>if __name__ == '__main__'</code>检查使Python文件可运行。应用程序将在本地主机的端口<code>8000</code>上运行。</p><p>请参考您的第一个<code>Flask</code>应用程序的以下代码片段:</p><pre>from flask import Flask 
app = Flask(__name__)
@app.route('/')
def root():
    return 'Your first Flask app!'
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8000)</pre><p>要运行应用程序，您必须从终端执行Python文件。这个文件在我的机器上被命名为<code>flask_basics.py</code>，所以要运行它，请执行以下命令:</p><pre><code>Running on http://0.0.0.0:8000/</code> message, you can see where the application <a id="_idIndexMarker450"/>is running, ergo which URL you need to visit to see your <a id="_idIndexMarker451"/>application. Just so you know, the <code>0.0.0.0</code> part can be replaced with <code>localhost</code>.<p>在那里，您将看到显示以下内容，表明一切工作正常:</p><div><img src="img/B16954_08_2.jpg" alt="Figure 8.2 – Your first Flask application&#13;&#10;" width="393" height="122"/></div><p class="figure-caption">图8.2–您的第一个烧瓶应用</p><p>这就是用<code>Flask</code>构建你的第一个web应用程序有多容易。接下来，您将学习如何让事情变得更复杂。</p></pre></li>
				<li>By now, you know how to build the simplest application with <code>Flask</code> – but that's not why you're here. We want to make APIs instead of apps, and that's a bit of a different story. The difference between them is quite obvious – APIs don't come with a user interface (except for the documentation page), whereas web apps do. APIs are just a service. As it turns out, you can build APIs with <code>Flask</code> out of the box. We'll explore how to do so and explain why it isn't the best option.<p>首先，创建一个新的Python文件。该文件将被称为<code>flask_basics2.py</code>。在其中，我们将为两种可能的API调用类型提供一个单一的路由。两者都有将两个数相加并返回结果的任务，但它们的方式不同。让我们列出不同之处:</p><p>a) <code>/adding</code> (GET)依赖于前面实现的逻辑。更准确地说，GET请求是在端点被调用时发出的。唯一不同的是<a id="_idIndexMarker453"/>这一次，参数是在URL中传递的。例如，调用<code>/adding?num1=3&amp;num2=5</code>应该在屏幕上显示<code>8</code>。参数值直接从URL中提取。您将看到这一点在起作用，因此一切将立即变得清晰。</p><p>b) <code>/adding</code> (POST)与第一个端点非常相似，但是发出POST请求。这是一种更安全的通信方法，因为参数值不是直接在URL中传递，而是在请求正文中传递。这个端点将总和作为JSON返回，所以您需要将结果包装在<code>flask.jsonify()</code>函数中。</p><p>两个函数都旨在完成相同的任务——将两个数相加并返回结果。下面是一个如何实现这种逻辑的例子:</p><pre>from flask import Flask, request, jsonify
app = Flask(__name__)
@app.route('/adding')
def add_get():
    num1 = int(request.args.get('num1'))
    num2 = int(request.args.get('num2'))
    return f'&lt;h3&gt;{num1} + {num2} = {num1 + num2}&lt;/h3&gt;'
@app.route('/adding', methods=['POST'])
def add_post():
    data = request.get_json()
    num1 = data['num1']
    num2 = data['num2']
    return jsonify({'result': num1 + num2})
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8000)</pre><p>如您所见，<code>add_get()</code>函数返回一个HTML格式的字符串。如果你想的话，你可以返回整个HTML文档，但是这不是我们现在感兴趣的事情，所以我们不会深入研究。</p><p>要运行应用程序，您必须从终端执行Python文件。这个文件在我的机器上被命名为<code>flask_basics2.py</code>，所以要运行它，请执行以下命令:</p><pre><code>/adding</code> for GET first:<div><img src="img/B16954_08_3.jpg" alt="Figure 8.3 – The GET endpoint without parameter values&#13;&#10;" width="984" height="178"/></div><pre>import requests
req = requests.post(
    url='http://localhost:8000/adding',
    json={'num1': 3, 'num2': 5}
)
res = req.content
print(res)</pre><p>如果您现在运行这段代码，您会看到以下输出:</p><div><img src="img/B16954_08_6.jpg" alt="Figure 8.6 – The POST endpoint with parameters (Python)&#13;&#10;" width="208" height="28"/></div><p class="figure-caption">图8.6–带参数的POST端点(Python)</p><p>这本质上是一个字符串，所以在您可以处理返回值之前，到JSON的一些转换将是强制性的。稍后，在第九章<em class="italic">的<a href="B16954_09_Final_SK_ePub.xhtml#_idTextAnchor102"> <em class="italic">中，将部署的TPOT车型用于生产</em>。</a></em></p><p>到目前为止，您已经看到了如何使用<code>Flask</code>库来开发web应用程序和web服务(API)。这是很好的第一个选择，但是如果您只对构建API感兴趣，还有一个更好的方法。接下来就来探索一下。</p></pre></li>
				<li>You already have <code>Flask-RESTful</code> installed. The syntax when using it is a bit different. It uses the <code>get()</code>, <code>post()</code>, and <code>put()</code>, which represent what happens when a request of a particular type is made.<p>所有API类都继承自<code>Flask-RESTful.Resource</code>类，每个端点必须通过<code>add_resource()</code>方法手动绑定到特定的URL字符串。</p><p>总而言之，我们将拥有<code>Add</code>类，它有两个方法:<code>get()</code>和<code>post()</code>。这些方法中的所有逻辑都与我们之前的相同，只有一个例外——我们不会在任何地方返回HTML。</p><p>下面是整个代码片段:</p><pre>from flask import Flask, request, jsonify
from flask_restful import Resource, Api 
app = Flask(__name__)
api = Api(app)
class Adding(Resource):
    @staticmethod
    def get():
        num1 = int(request.args.get('num1'))
        num2 = int(request.args.get('num2'))
        return num1 + num2
    @staticmethod
    def post():
        data = request.get_json()
        num1 = data['num1']
        num2 = data['num2']
        return jsonify({'result': num1 + num2})
api.add_resource(Adding, '/adding')
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8000)</pre><p>在<code>/adding</code>端点上可以获得<code>Adding</code>类中的所有内容。</p><p>正如你<a id="_idIndexMarker468"/>所看到的，这个API将运行在不同的端口上，只是为了让<a id="_idIndexMarker469"/>容易区分这个API和之前的那个。</p><p>如果你现在打开<code>http://localhost:8000/adding</code>，你会看到下面的消息:</p></li>
			</ol>
			<div><div><img src="img/B16954_08_7.jpg" alt="Figure 8.7 – Flask-RESTful GET without parameters&#13;&#10;" width="383" height="119"/>
				</div>
			</div>
			<p class="figure-caption">图8.7–不带参数的Flask-RESTful GET</p>
			<p>我们现在有了与默认的<code>Flask</code> API相同的错误，原因是URL中没有给出参数值。如果您要更改它并调用<code>http://localhost:8000/adding?num1=5&amp;num2=10</code>，您将在浏览器窗口中看到以下内容:</p>
			<div><div><img src="img/B16954_08_8.jpg" alt="Figure 8.8 – Flask-RESTful GET with parameters&#13;&#10;" width="412" height="122"/>
				</div>
			</div>
			<p class="figure-caption">图8.8–带参数的Flask-RESTful GET</p>
			<p>正如前面提到的<a id="_idIndexMarker470"/>，直接从浏览器与API通信<a id="_idIndexMarker471"/>被认为不是一个好的实践，但是你仍然可以用GET请求类型来做。你最好使用诸如Postman这样的工具，而且你已经知道怎么做了。</p>
			<p>至于POST方法，可以调用与前面相同的URL，<code>http://localhost:8000/adding</code>，并在请求体中以JSON的形式传递参数。以下是使用Postman的方法:</p>
			<div><div><img src="img/B16954_08_9.jpg" alt="Figure 8.9 – Flask-RESTful POST with Postman&#13;&#10;" width="622" height="422"/>
				</div>
			</div>
			<p class="figure-caption">图8.9–带邮递员的Flask-RESTful帖子</p>
			<p>您可以通过Python做同样的事情，但是现在您应该已经知道如何做了。</p>
			<p>现在<a id="_idIndexMarker472"/>你已经知道了用Python、<code>Flask</code>和<code>Flask-RESTful</code>开发REST API的基础。这是一个相对快速的动手部分，为接下来的内容做了铺垫<a id="_idIndexMarker473"/>。在下一节中，我们将回顾一些部署机器学习模型的最佳实践，在最后两节中，我们将探索如何分别训练和部署模型到本地主机和云中。</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor097"/>部署自动化模型的最佳实践</h1>
			<p>自动化模型的部署<a id="_idIndexMarker474"/>或多或少与普通机器学习模型的部署相同。归结起来就是首先训练模型，然后以某种格式保存模型。在正常机器学习模型的情况下，你可以很容易地将模型保存到一个<code>.model</code>或<code>.h5</code>文件中。没有理由不对TPOT模型做同样的事情。</p>
			<p>如果你还记得前面的章节，TPOT可以将最好的管道导出到Python文件中，这样如果这个管道还没有被训练过，它就可以被用来训练这个模型，并且这个模型可以在以后被保存。如果模型已经定型，则只获得预测。</p>
			<p>通过检查文件是否存在，可以检查<a id="_idIndexMarker475"/>模型是否被训练过。如果模型文件存在，我们可以假设该模型已经过训练，因此我们可以加载它并进行预测。否则要先对模型进行训练和保存，然后才能进行预测。</p>
			<p>在连接到机器学习API时，使用POST请求类型也是一个好主意。这是一个比GET更好的选择，因为参数值不直接在URL中传递。您可能知道，参数值可能很敏感，因此尽可能隐藏它们是个好主意。</p>
			<p>例如，在进行预测之前，您可能需要使用API进行身份验证。很容易理解为什么在URL中直接发送您的用户名和密码凭证不是一个好主意。POST已经覆盖了你，这一章的其余部分将很好地利用它。</p>
			<p>简而言之，在进行预测之前，您应该始终检查模型是否经过训练，并在需要时对其进行训练。另一个要点是，在我们的情况下，POST比GET更好。现在，您已经知道了一些部署机器学习模型的基本最佳实践。在下一节中，我们将训练模型并将其部署到本地主机。</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor098"/>将机器学习模型部署到本地主机</h1>
			<p>在部署之前，我们必须训练一个模型。你已经知道了和TPOT一起训练的一切，所以我们不会在这里花太多时间。目标是训练一个简单的虹膜分类器，并以某种方式输出预测功能。让我们一步一步地完成这个过程:</p>
			<ol>
				<li value="1">As always, the first step is to load in the libraries and the dataset. You can use the following piece of code to do so:<pre>import pandas as pd
df = pd.read_csv('data/iris.csv')
df.head()</pre><p>这是前几行的样子:</p><div><img src="img/B16954_08_10.jpg" alt="Figure 8.10 – The first few rows of the Iris dataset&#13;&#10;" width="858" height="312"/></div><p class="figure-caption">图8.10–Iris数据集的前几行</p></li>
				<li>The next <a id="_idIndexMarker478"/>step is to separate <a id="_idIndexMarker479"/>the features from the target variable. This time, we won't split the dataset into training and testing subsets, as we don't intend to evaluate the model's performance. In other words, we know the model performs well, and now we want to retrain it on the entire dataset. Also, string values in the target variables will be remapped to their integer representation as follows:<p>a)Setosa–0</p><p>b)Virginica–1</p><p>c)变色–2</p><p>下面几行代码完成了描述的所有工作:</p><pre>X = df.drop('species', axis=1)
y = df['species']
y = y.replace({'setosa': 0, 'virginica': 1, 'versicolor': 2})
y</pre><p>下面是目标变量现在的样子:</p><div><img src="img/B16954_08_11.jpg" alt="Figure 8.11 – The target variable after value remapping&#13;&#10;" width="652" height="363"/></div><p class="figure-caption">图8.11-值重新映射后的目标变量</p></li>
				<li>Next stop – model training. We'll train the model with TPOT for 15 minutes. This part <a id="_idIndexMarker480"/>should be familiar to you, as <a id="_idIndexMarker481"/>we're not using any parameters that weren't used or described in previous chapters.<p>以下代码将在整个数据集上训练模型:</p><pre>from tpot import TPOTClassifier
clf = TPOTClassifier(
    scoring='accuracy',
    max_time_mins=15,
    random_state=42,
    verbosity=2
)
clf.fit(X, y)</pre><p>在训练过程中，您会看到许多输出，但达到100%的准确率应该不会花太长时间，如下图所示:</p><div><img src="img/B16954_08_12.jpg" alt="Figure 8.12 – TPOT training process&#13;&#10;" width="1036" height="579"/></div><p class="figure-caption">图8.12-TPOT培训流程</p><p>在15分钟的时间框架内，<a id="_idIndexMarker483"/>会经过多少代取决于您的硬件，但是一旦完成，您应该会看到类似下面的内容:</p><div><img src="img/B16954_08_13.jpg" alt="Figure 8.13 – TPOT output after training&#13;&#10;" width="1372" height="309"/></div><p class="figure-caption">图8.13-培训后的TPOT输出</p></li>
				<li>Once the training process is complete, you'll have access to the <code>fitted_pipeline_</code> property:<pre>clf.fitted_pipeline_</pre><p>它是一个管道对象，可以导出供以后使用。它应该是这样的(请记住，您可能会在您的机器上看到一些不同的东西):</p><div><img src="img/B16954_08_14.jpg" alt="Figure 8.14 – TPOT fitted pipeline&#13;&#10;" width="1231" height="342"/></div><p class="figure-caption">图8.14-TPOT装配管道</p></li>
				<li>To <a id="_idIndexMarker484"/>demonstrate how this <a id="_idIndexMarker485"/>pipeline works, please take a look at the following code snippet. It calls the <code>predict()</code> function of the <code>fitted_pipeline_</code> property with a 2D array of input data, representing a single flower species:<pre>clf.fitted_pipeline_.predict([[5.1, 3.5, 0.2, 3.4]])</pre><p>结果显示在下图中:</p><div><img src="img/B16954_08_15.jpg" alt="Figure 8.15 – TPOT prediction&#13;&#10;" width="159" height="36"/></div><p class="figure-caption">图8.15-TPOT预测</p><p>还记得几页前我们的重新映射策略吗？<code>0</code>表示该物种被归为<code>setosa</code>。</p></li>
				<li>The final step we have to do is save the predictive capabilities of this model to a file. The <code>joblib</code> library makes this step easy to do, as you just have to call the <code>dump()</code> function to save the model and the <code>load()</code> function to load the model.<p>这里有一个快速演示。目标是将<code>fitted_pipeline_</code>属性保存到一个名为<code>iris.model</code>的文件中。您可以使用以下代码来实现这一点:</p><pre>import joblib
joblib.dump(clf.fitted_pipeline_, 'iris.model')</pre><p>这就是全部了！一旦模型保存到文件中，您将看到以下输出:</p></li>
			</ol>
			<div><div><img src="img/B16954_08_16.jpg" alt="Figure 8.16 – Saving TPOT models&#13;&#10;" width="1026" height="34"/>
				</div>
			</div>
			<p class="figure-caption">图8.16–保存TPOT模型</p>
			<p>仅仅为了<a id="_idIndexMarker486"/>验证模型<a id="_idIndexMarker487"/>是否仍然有效，您可以使用<code>load()</code>函数将模型加载到一个新变量中:</p>
			<pre>loaded_model = joblib.load('iris.model')
loaded_model.predict([[5.1, 3.5, 0.2, 3.4]])</pre>
			<p>上述代码的输出如下图所示:</p>
			<div><div><img src="img/B16954_08_17.jpg" alt="Figure 8.17 – Prediction of a saved model&#13;&#10;" width="995" height="33"/>
				</div>
			</div>
			<p class="figure-caption">图8.17–已保存模型的预测</p>
			<p>这就是保存机器学习模型以备后用是多么容易。我们现在已经具备了部署该模型所需的一切，接下来让我们开始吧。</p>
			<p>模型部署过程将与我们之前用<code>Flask</code>和<code>Flask-RESTful</code>所做的非常相似。在进入分步指南之前，您应该使用以下目录/文件结构为您的API创建一个目录:</p>
			<div><div><img src="img/B16954_08_18.jpg" alt="Figure 8.18 – API directory structure&#13;&#10;" width="746" height="107"/>
				</div>
			</div>
			<p class="figure-caption">图8.18–API目录结构</p>
			<p>如你所见，根文件夹叫做<code>api</code>，里面有两个Python文件——<code>app.py</code>和<code>helpers.py</code>。该文件夹还具有用于存储先前训练的模型的另一个文件夹。</p>
			<p>接下来让我们一步一步地构建API:</p>
			<ol>
				<li value="1">Let's start <a id="_idIndexMarker489"/>with the <code>helpers.py</code> file. The goal of this Python file is to remove all calculations and data operations from <code>app.py</code>. The ladder is used only to declare and manage the API itself, and everything else is performed elsewhere.<p><code>helpers.py</code>文件将有两个功能——<code>int_to_species(in_species)</code>和<code>predict_single(model, X)</code>。</p><p>第一个函数的目标是反转我们之前声明的映射，并返回给定整数表示的实际花卉种类名称。下面是给定整数输入时返回的字符串的具体列表:</p><p>a)0—<code>setosa</code></p><p>b)1—<code>virginica</code></p><p>c)2—<code>versicolor</code></p><p>如果传递了其他数字，则返回一个空字符串。您可以找到该函数的代码，如下所示:</p><pre>def int_to_species(in_species):
    if in_species == 0:
        return 'setosa'
    if in_species == 1:
        return 'virginica'
    if in_species == 2:
        return 'versicolor'</pre><p>现在转到<code>predict_single(model, X)</code>功能。它的目的是在给定模型和输入值列表的情况下，返回预测及其概率。该函数还进行以下检查:</p><p>a)<code>X</code>是列表吗？如果不是，则引发一个异常。</p><p>b)<code>X</code>是否有四项(萼片长度、萼片宽度、花瓣长度、花瓣宽度)？如果不是，则引发一个异常。</p><p>这些<a id="_idIndexMarker490"/>检查是必需的<a id="_idIndexMarker491"/>,因为我们不希望坏的或格式错误的数据进入我们的模型并使API崩溃。</p><p>如果所有检查都通过，预测和概率将作为一个字典返回给用户，旁边是为每个参数输入的数据。下面是实现这个函数的方法:</p><pre>def predict_single(model, X):
    if type(X) is not list:
        raise Exception('X must be of list data type!')
    if len(X) != 4:
        raise Exception('X must contain 4 values - \
sepal_length, sepal_width, petal_length, petal_width')
    prediction = model.predict([X])[0]
    prediction_probability =\
model.predict_proba([X])[0][prediction]
    return {
        'In_SepalLength': X[0],
        'In_SepalWidth': X[1],
        'In_PetalLength': X[2],
        'In_PetalWidth': X[3],
        'Prediction': int_to_species(prediction),
        'Probability': prediction_probability
    }</pre><p>这里有一个调用<code>predict_single()</code>函数的例子:</p><pre>predict_single(
    model=joblib.load('api/model/iris.model'), 
    X=[5.1, 3.5, 0.2, 3.4]
)</pre><p><a id="_idIndexMarker493"/>结果如下图所示:</p><div><img src="img/B16954_08_19.jpg" alt="Figure 8.19 – Results of calling the predict_single() function&#13;&#10;" width="546" height="100"/></div><p class="figure-caption">图8.19–调用predict_single()函数的结果</p></li>
				<li>On to <code>app.py</code> now. If you have been following along from the beginning of this chapter, coding out this file will be a piece of cake. The goal is to have the model loaded at all times and to trigger the <code>post()</code> method of the <code>PredictSpecies</code> class when a <code>/predict</code> endpoint is called. You'll have to implement both the class and the method yourself.<p>用户必须以JSON的形式传递输入数据。更准确地说，每个flower测量值都是单独传递的，因此用户必须指定总共四个参数的值。</p><p>如果一切顺利，调用<code>helpers.py</code>中的<code>predict_single()</code>函数，并将结果返回给用户。</p><p>让我们来看看<code>app.py</code>的实现:</p><pre>import joblib 
import warnings
from flask import Flask, request, jsonify
from flask_restful import Resource, Api
from helpers import predict_single
warnings.filterwarnings('ignore')
app = Flask(__name__)
api = Api(app)
model = joblib.load('model/iris.model')
class PredictSpecies(Resource):
    @staticmethod
    def post():
        user_input = request.get_json()
        sl = user_input['SepalLength']
        sw = user_input['SepalWidth']
        pl = user_input['PetalLength']
        pw = user_input['PetalWidth']
        prediction =\
predict_single(model=model, X=[sl, sw, pl, pw])
        return jsonify(prediction)
api.add_resource(PredictSpecies, '/predict')
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8000)</pre></li>
				<li>You now <a id="_idIndexMarker496"/>have everything <a id="_idIndexMarker497"/>needed to run the API. You can do so the same way that you did with the previous APIs, and that is by executing the following line in the terminal:<pre><strong class="bold">&gt; python app.py</strong></pre><p>如果一切顺利，您将得到以下消息:</p><div><img src="img/B16954_08_20.jpg" alt="Figure 8.20 – Running the API&#13;&#10;" width="679" height="117"/></div><p class="figure-caption">图8.20–运行API</p></li>
				<li>The API is now running on <code>http://localhost:8000</code>. We'll use the Postman application to test the API.<p>下面是第一个例子:</p></li>
			</ol>
			<div><div><img src="img/B16954_08_21.jpg" alt="Figure 8.21 – API testing example 1&#13;&#10;" width="670" height="533"/>
				</div>
			</div>
			<p class="figure-caption">图8.21–API测试示例1</p>
			<p>正如你所看到的，这个模型100%确信这个物种属于<code>setosa</code>类。让我们试试另一个:</p>
			<div><div><img src="img/B16954_08_22.jpg" alt="Figure 8.22 – API testing example 2&#13;&#10;" width="620" height="532"/>
				</div>
			</div>
			<p class="figure-caption">图8.22–API测试示例2</p>
			<p>这具有相同的置信水平，但是不同的预测类别。让我们将事情混在一起，传递与训练集中的任何内容稍有不同的值:</p>
			<div><div><img src="img/B16954_08_23.jpg" alt="Figure 8.23 – API testing example 3&#13;&#10;" width="624" height="534"/>
				</div>
			</div>
			<p class="figure-caption">图8.23–API测试示例3</p>
			<p>如您所见，该模型这次不是100%有信心，因为输入数据与培训时看到的数据有很大不同。</p>
			<p>现在<a id="_idIndexMarker502"/>您已经有了——部署到本地主机的TPOT模型<a id="_idIndexMarker503"/>!本章剩下要做的唯一一件事是将模型带到云中，并使它可以从任何地方访问。让我们接下来做那件事。</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor099"/>将机器学习模型部署到云</h1>
			<p>云<a id="_idIndexMarker504"/>机器学习<a id="_idIndexMarker505"/>模型的部署就是创建一个云虚拟机，把我们的API转移给它，然后运行它。这是一个乏味的过程，随着重复变得容易，因为涉及到许多步骤。如果你完全按照这一部分的每一步来做，一切都会好的。请确保不要错过任何小细节:</p>
			<ol>
				<li value="1">To start, head over to <a href="https://portal.aws.amazon.com/billing/signup#/start">https://portal.aws.amazon.com/billing/signup#/start</a> and create an account (assuming you don't already have one). Here's what the website currently looks like (as of February 2021):<div><img src="img/B16954_08_24.jpg" alt="Figure 8.24 – AWS registration website&#13;&#10;" width="730" height="691"/></div><p class="figure-caption">图8.24–AWS注册网站</p><p>注册<a id="_idIndexMarker506"/>过程将<a id="_idIndexMarker507"/>花费一些时间，你必须输入你的信用卡信息。不用担心；我们将创建完全免费的虚拟机实例，因此不会向您收取任何费用。</p></li>
				<li>Once the registration process is complete, click on the <code>ubuntu</code> in the search bar:<div><img src="img/B16954_08_26.jpg" alt="Figure 8.26 – Ubuntu Server 20.04&#13;&#10;" width="1194" height="286"/></div><p class="figure-caption">图8.26–Ubuntu Server 20.04</p><p>一旦<a id="_idIndexMarker508"/>点击<strong class="bold">选择</strong>，你将<a id="_idIndexMarker509"/>必须指定类型。如果您不想付费，请确保选择免费版本:</p><div><img src="img/B16954_08_27.jpg" alt="Figure 2.27 – Ubuntu instance type&#13;&#10;" width="1159" height="389"/></div><p class="figure-caption">图2.27–Ubuntu实例类型</p><p>接下来，点击<strong class="bold">查看并启动</strong>按钮。您将进入以下屏幕:</p><div><img src="img/B16954_08_28.jpg" alt="Figure 2.28 – Ubuntu instance confirmation&#13;&#10;" width="1150" height="469"/></div><p class="figure-caption">图2.28-Ubuntu实例确认</p><p>一旦<a id="_idIndexMarker510"/>你点击<strong class="bold">发射</strong>，下面的<a id="_idIndexMarker511"/>窗口就会出现。确保选择相同的选项，但密钥对名称由您决定:</p><div><img src="img/B16954_08_29.jpg" alt="Figure 8.29 – Ubuntu key pair&#13;&#10;" width="939" height="455"/></div><p class="figure-caption">图8.29-Ubuntu密钥对</p><p>输入详细信息后，点击<strong class="bold">下载密钥对</strong>按钮。下载完成后，您可以点击<strong class="bold">启动实例</strong>按钮:</p><div><img src="img/B16954_08_30.jpg" alt="Figure 8.30 – Launching the Ubuntu instance&#13;&#10;" width="1242" height="317"/></div><p class="figure-caption">图8.30-启动Ubuntu实例</p><p>最后，在<a id="_idIndexMarker512"/>一切完成后，您<a id="_idIndexMarker513"/>可以点击<strong class="bold">查看实例</strong>按钮:</p><div><img src="img/B16954_08_31.jpg" alt="Figure 8.31 – View Instances&#13;&#10;" width="260" height="82"/></div><p class="figure-caption">图8.31–查看实例</p><p>您将立即看到您创建的实例。可能需要一些时间才能看到实例正在运行，所以请耐心等待:</p><div><img src="img/B16954_08_32.jpg" alt="Figure 8.32 – Running instance&#13;&#10;" width="1142" height="228"/></div><p class="figure-caption">图8.32–运行实例</p></li>
				<li>To obtain the connection parameter, click on the instance row and select the <code>.ppk</code> file in the <strong class="bold">Key file</strong> option. After the <strong class="bold">Connect</strong> button is pressed, you'll see the following:<div><img src="img/B16954_08_36.jpg" alt="Figure 8.36 – FileZilla host key&#13;&#10;" width="1013" height="447"/></div><p class="figure-caption">图8.36–FileZilla主机密钥</p><p>只需<a id="_idIndexMarker520"/>按下<strong class="bold"> OK </strong>即可<a id="_idIndexMarker521"/>运行。连接成功，如下图所示:</p><div><img src="img/B16954_08_37.jpg" alt="Figure 8.37 – FileZilla successful connection&#13;&#10;" width="1303" height="466"/></div><p class="figure-caption">图8.37–FileZilla成功连接</p><p>现在您可以将<strong class="bold"> api </strong>文件夹拖到远程虚拟机上的<strong class="bold"> ubuntu </strong>文件夹中，如下所示:</p><div><img src="img/B16954_08_38.jpg" alt="Figure 8.38 – Transferring API data to a remote virtual machine&#13;&#10;" width="721" height="304"/></div><p class="figure-caption">图8.38–将API数据传输到远程虚拟机</p><p>在进一步配置和启动API之前，让我们探索一下如何通过终端获得连接。</p></li>
				<li>打开<a id="_idIndexMarker522"/>一个新的终端窗口<a id="_idIndexMarker523"/>就在你的<code>.pem</code>文件存储的地方。在那里，执行下面的命令来改变权限:<pre><code>TPOT_Book_KeyPair.pem</code> with your filename and also make sure to write your instance name after <code>ubuntu@</code>. If you did everything correctly, you should see the following in your terminal:<div><img src="img/B16954_08_39.jpg" alt="Figure 8.39 – Accessing the Ubuntu virtual machine through the terminal&#13;&#10;" width="535" height="80"/></div><pre><strong class="bold">&gt; sudo apt-get update &amp;&amp; sudo apt-get install python3-pip</strong></pre> <p>最后，让我们安装每个需要的库。下面是在虚拟环境中这样做的命令:</p> <pre><strong class="bold">&gt; pip3 install virtualenv</strong> <strong class="bold">&gt; virtualenv tpotapi_env</strong> <strong class="bold">&gt; source tpotapi_env/bin/activate</strong> <strong class="bold">&gt; pip3 install joblib flask flask-restful sklearn tpot</strong></pre> <p>在启动API之前，您还需要完成一些步骤，比如管理安全性。</p>T29】</pre></li>
				<li>If you <a id="_idIndexMarker524"/>were to run the API now, no errors <a id="_idIndexMarker525"/>would be raised, but you wouldn't be able to access the API in any way. That's because we need to "fix" a couple of permissions first. Put simply, our API needs to be accessible from anywhere, and it isn't by default.<p>首先，导航到边栏上的<strong class="bold">网络&amp;安全</strong> | <strong class="bold">安全组</strong>:</p><div><img src="img/B16954_08_40.jpg" alt="Figure 8.40 – Security Groups&#13;&#10;" width="190" height="180"/></div><p class="figure-caption">图8.40-安全组</p><p>您应该会在浏览器窗口的右上角看到<strong class="bold">创建安全组</strong>按钮:</p><div><img src="img/B16954_08_41.jpg" alt="Figure 8.41 – The Create security group button&#13;&#10;" width="590" height="41"/></div><p class="figure-caption">图8.41–创建安全组按钮</p><p>一旦<a id="_idIndexMarker526"/>新窗口弹出，你将<a id="_idIndexMarker527"/>必须指定几样东西。<strong class="bold">安全组名称</strong>和<strong class="bold">描述</strong>字段完全是任意的。另一方面，<strong class="bold">入站规则</strong>组不是任意的。您必须添加一个具有以下选项的新规则:</p><p>a) <strong class="bold">类型</strong> : <strong class="bold">所有流量</strong></p><p>b) <strong class="bold">来源</strong> : <strong class="bold">任何地方</strong></p><p>请参考下图了解更多信息:</p><div><img src="img/B16954_08_42.jpg" alt="Figure 8.42 – Creating a security group&#13;&#10;" width="1025" height="528"/></div><p class="figure-caption">图8.42–创建安全组</p><p>指定正确的值后，您必须向下滚动到屏幕的末尾，并单击<strong class="bold">创建安全组</strong>选项:</p><div><img src="img/B16954_08_43.jpg" alt="Figure 8.43 – Verifying a security group&#13;&#10;" width="741" height="50"/></div><p class="figure-caption">图8.43–验证安全组</p><p>我们还没完呢。下一步是去侧边栏上的<strong class="bold">网络&amp;安全</strong> | <strong class="bold">网络接口</strong>选项:</p><div><img src="img/B16954_08_44.jpg" alt="Figure 8.44 – The Network Interfaces option&#13;&#10;" width="648" height="286"/></div><p class="figure-caption">图8.44–网络接口选项</p><p>一旦<a id="_idIndexMarker528"/>出现，右键单击唯一可用的<a id="_idIndexMarker529"/>网络接口(假设这是您第一次进入AWS控制台)并选择<strong class="bold">更改安全组</strong>选项:</p><div><img src="img/B16954_08_45.jpg" alt="Figure 8.45 – Changing security groups&#13;&#10;" width="820" height="399"/></div><p class="figure-caption">图8.45–更改安全组</p><p>这样做的目的是将“从任何地方访问”规则分配给我们的虚拟机。弹出窗口后，从下拉选项中选择之前声明的安全组:</p><div><img src="img/B16954_08_46.jpg" alt="Figure 8.46 – Selecting the security group&#13;&#10;" width="575" height="152"/></div><p class="figure-caption">图8.46–选择安全组</p><p>添加<a id="_idIndexMarker530"/>后，点击<strong class="bold">保存</strong>按钮<a id="_idIndexMarker531"/>保存该关联:</p><div><img src="img/B16954_08_47.jpg" alt="Figure 8.47 – Saving security associations&#13;&#10;" width="818" height="239"/></div><p class="figure-caption">图8.47–保存安全关联</p></li>
				<li>Configuring our virtual machine was quite a lengthy process, but you can now finally start the <code>Flask</code> application (REST API). To do so, navigate to the <code>/api</code> folder and execute the following:<pre><strong class="bold">&gt; python3 app.py</strong></pre><p>您应该会看到下面这条熟悉的消息:</p><div><img src="img/B16954_08_48.jpg" alt="Figure 8.48 – Starting the REST API through the terminal&#13;&#10;" width="1508" height="292"/></div><p class="figure-caption">图8.48–通过终端启动REST API</p><p>就是这样！API现在正在运行，我们可以测试它是否正常工作。</p></li>
				<li>在<a id="_idIndexMarker532"/>通过Postman发出请求之前，我们首先需要找到远程虚拟机的完整URL。你可以通过右击<strong class="bold">实例</strong>下的实例并点击<strong class="bold">连接</strong>选项来<a id="_idIndexMarker533"/>找到你的实例。在那里，您将看到<strong class="bold"> SSH客户端</strong>选项卡:</li>
			</ol>
			<div><div><img src="img/B16954_08_49.jpg" alt="Figure 8.49 – Virtual machine URL&#13;&#10;" width="705" height="433"/>
				</div>
			</div>
			<p class="figure-caption">图8.49–虚拟机URL</p>
			<p>现在我们知道了完整的网址:<code>http://ec2-18-220-113-224.us-east-2.compute.amazonaws.com:8000/predict</code>。从现在开始的过程与在localhost上的过程相同，如下图所示:</p>
			<div><div><img src="img/B16954_08_50.jpg" alt="Figure 8.50 – Testing our deployed API&#13;&#10;" width="1242" height="1055"/>
				</div>
			</div>
			<p class="figure-caption">图8.50–测试我们部署的API</p>
			<p>正如您<a id="_idIndexMarker534"/>所看到的，连接<a id="_idIndexMarker535"/>通过了，API返回了一个响应，就像对待本地部署的版本一样。</p>
			<p>这就是将机器学习模型部署到AWS虚拟机的完整过程。如果这是你的第一次，这个过程会很乏味，甚至很棘手。随着你部署越来越多的机器学习模型，这将变得更容易，因为程序是相同的。</p>
			<p>如果你不希望你的API被任何人从任何地方访问，你可以考虑权限，但是这超出了本书的范围。这一章差不多结束了——伟大的作品！接下来是对所学内容的总结，以及另一个有趣的动手操作章节。</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor100"/>总结</h1>
			<p>这一章是迄今为止最长的一章，包含了大量的实践任务。你很有希望能够继续学习，并了解如何在本地和云端部署用TPOT构建的机器学习模型。</p>
			<p>现在，您可以部署任何用Python构建的机器学习模型。此外，如果您对前端技术(如HTML、CSS和JavaScript)有必要的了解，您还知道如何部署基本的Python web应用程序。我们没有深入这个领域，因为它超出了本书的范围。</p>
			<p>在接下来的章节中，<a href="B16954_09_Final_SK_ePub.xhtml#_idTextAnchor102"> <em class="italic">第9章</em> </a>，<em class="italic">在生产中使用部署的TPOT模型</em>，您将学习如何围绕这个REST API构建一个基本的应用程序。更准确地说，您将学习如何创建一个简单、美观的web界面，根据输入数据预测花卉种类。但在此之前，您将练习用Python向我们的API发出请求。</p>
			<p>和往常一样，请随意更详细地研究模型部署，因为AWS不是唯一的选择。有许多云提供商提供某种形式的免费层，而AWS只是池塘中的一条鱼。</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor101"/>提问</h1>
			<ol>
				<li value="1">为什么我们需要(并且想要)模型部署？</li>
				<li>REST APIs在模型部署中的作用是什么？</li>
				<li>列举几个可以用来部署机器学习模型的Python库。</li>
				<li>GET和POST请求类型之间有什么区别？</li>
				<li>Python中的<code>joblib</code>库背后的大致思路是什么？</li>
				<li>用自己的话解释什么是虚拟机。</li>
				<li>哪个免费工具可以用来测试REST APIs？</li>
			</ol>
		</div>
	</div>
</body></html>