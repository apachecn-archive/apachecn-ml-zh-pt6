<html><head/><body>





<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style>
<div><div><h1 id="_idParaDest-64"><em class="italic"> <a id="_idTextAnchor065"/>第五章</em>:与TPOT和达斯克平行训练</h1>
			<p>在这一章中，你将深入到一个更高级的话题；也就是自动机器学习。通过在Dask集群上分配工作，您将学习如何以并行方式处理机器学习任务。这一章将比前两章更理论化，但是你仍然会学到很多有用的东西。</p>
			<p>我们将讨论Python中并行性背后的基本主题和思想，并且您将了解如何以几种不同的方式实现并行性。然后，我们将深入Dask库，探索它的基本功能，看看如何将它与TPOT联系起来。</p>
			<p>本章将涵盖以下主题:</p>
			<ul>
				<li>Python中的并行性介绍</li>
				<li>Dask库简介</li>
				<li>用TPOT和达斯克训练机器学习模型</li>
			</ul>
			<p>我们开始吧！</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor066"/>技术要求</h1>
			<p>阅读和理解这一章不需要事先接触Dask甚至并行编程。以前的经验是有帮助的，因为把这么大的一个概念装进几页纸几乎是不可能的。你应该仍然能够跟上并完全理解这里写的一切，因为所有的概念都将被解释。</p>
			<p>你可以在这里下载本章的源代码和数据集:<a href="https://github.com/PacktPublishing/Machine-Learning-Automation-with-TPOT/tree/main/Chapter05">https://github . com/packt publishing/Machine-Learning-Automation-with-TPOT/tree/main/chapter 05</a>。</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor067"/>Python中的并行性介绍</h1>
			<p>在<a id="_idIndexMarker290"/>某些情况下需要顺序执行任务(第一个任务完成后第二个任务开始)。例如，<a id="_idIndexMarker291"/>第二个函数的输入可能依赖于第一个函数的输出。如果是那样的话，这两个函数(进程)就不能同时执行了。</p>
			<p>但更多时候，情况并非如此。想象一下，在显示仪表板之前，您的程序连接到三个不同的API端点。第一个API返回当前的天气状况，第二个返回股票价格，最后一个返回今天的汇率。一个接一个地调用API是没有意义的。它们互不依赖，因此按顺序运行它们会浪费大量时间。</p>
			<p>不仅如此，它还会浪费CPU内核。大多数现代电脑至少有四个CPU核心。如果你按顺序运行，你只使用一个核心。如果可以的话，为什么不全部使用呢？</p>
			<p>在Python中实现并行性的一种方法是多处理。这是一种基于进程的并行技术。正如您所想象的，Python内置了一个<code>multiprocessing</code>库，本节将教您如何使用它。在Python 3.2及更高版本中，这个库不再是在应用中实现多处理的推荐方式。这个街区出现了一个新人，他的名字叫<code>concurrent.futures</code>。这是另一个内置库，您将在本节中学习如何使用。</p>
			<p>解释和理解多处理最简单的方法是使用Python的内置<code>time</code>库。你可以用它来跟踪时差，有意识地暂停程序执行，等等。这正是我们所需要的，因为我们可以放入许多打印语句，它们之间有一些时间间隔，然后查看程序在顺序运行时的行为，以及在并行运行时的行为。</p>
			<p>通过几个动手操作的例子，您将了解Python中的多重处理是如何工作的。</p>
			<p>首先，请看看下面的代码片段。其中已经声明了<code>sleep_func()</code>函数。它的任务是打印一条消息，暂停程序执行1秒钟，然后在函数完成时打印另一条消息。我们可以监视这个函数运行任意次数(比如说五次)所花费的时间，然后打印出执行持续时间。片段如下:</p>
			<pre>import time 
def sleep_func():
    print('Sleeping for a 1 second')
    time.sleep(1)
    print('Done.')
if __name__ == '__main__':
    time_start = time.time()
    # Run the function 5 times
    sleep_func()
    sleep_func()
    sleep_func()
    sleep_func()
    sleep_func()
    time_stop = time.time()
    print(f'Took {round(time_stop - time_start, 2)} seconds to execute!')</pre>
			<p>这里显示的是<a id="_idIndexMarker292"/>对应的<a id="_idIndexMarker293"/>输出:</p>
			<pre><strong class="bold">Sleeping for a 1 second</strong>
<strong class="bold">Done.</strong>
<strong class="bold">Sleeping for a 1 second</strong>
<strong class="bold">Done.</strong>
<strong class="bold">Sleeping for a 1 second</strong>
<strong class="bold">Done.</strong>
<strong class="bold">Sleeping for a 1 second</strong>
<strong class="bold">Done.</strong>
<strong class="bold">Sleeping for a 1 second</strong>
<strong class="bold">Done.</strong>
<strong class="bold">Took 5.02 seconds to execute!</strong></pre>
			<p>这里发生了什么？退一步说，没什么意外。<code>sleep_func()</code>功能<a id="_idIndexMarker294"/>连续执行五次。执行时间大约为5秒。您还可以用以下方式简化前面的代码片段:</p>
			<pre>import time 
def sleep_func():
    print('Sleeping for a 1 second')
    time.sleep(1)
    print('Done.')
if __name__ == '__main__':
    time_start = time.time()
    # Run the function 5 times in loop
    for _ in range(5):
        sleep_func()
    time_stop = time.time()
    print(f'Took {round(time_stop - time_start, 2)} seconds to execute!')</pre>
			<p>如您所料，<a id="_idIndexMarker296"/>结果与<a id="_idIndexMarker297"/>完全相同:</p>
			<pre><strong class="bold">Sleeping for a 1 second</strong>
<strong class="bold">Done.</strong>
<strong class="bold">Sleeping for a 1 second</strong>
<strong class="bold">Done.</strong>
<strong class="bold">Sleeping for a 1 second</strong>
<strong class="bold">Done.</strong>
<strong class="bold">Sleeping for a 1 second</strong>
<strong class="bold">Done.</strong>
<strong class="bold">Sleeping for a 1 second</strong>
<strong class="bold">Done.</strong>
<strong class="bold">Took 5.01 seconds to execute!</strong></pre>
			<p>这种方法有问题吗？嗯，是的。我们在浪费时间和CPU内核。这些函数没有任何依赖关系，所以我们为什么不并行运行它们呢？正如我们前面提到的，有两种方法可以做到这一点。让我们首先通过<code>multiprocessing</code>库来检查旧的方法。</p>
			<p>这是一个有点冗长的方法，因为它需要声明一个过程，启动它，并加入它。如果你只有几个进程就没那么繁琐了，但是如果你的程序里有几十个进程呢？它会很快变得乏味。</p>
			<p>下面的代码片段演示了如何并行运行三次<code>sleep_func()</code>函数:</p>
			<pre>import time 
from multiprocessing import Process
def sleep_func():
    print('Sleeping for a 1 second')
    time.sleep(1)
    print('Done.')
if __name__ == '__main__':
    time_start = time.time()
    process_1 = Process(target=sleep_func)
    process_2 = Process(target=sleep_func)
    process_3 = Process(target=sleep_func)
    process_1.start()
    process_2.start()
    process_3.start()
    process_1.join()
    process_2.join()
    process_3.join()
    time_stop = time.time()
    print(f'Took {round(time_stop - time_start, 2)} seconds to  execute!')</pre>
			<p>这里显示的是<a id="_idIndexMarker298"/>输出<a id="_idIndexMarker299"/>:</p>
			<pre><strong class="bold">Sleeping for a 1 second</strong>
<strong class="bold">Sleeping for a 1 second</strong>
<strong class="bold">Sleeping for a 1 second</strong>
<strong class="bold">Done.</strong>
<strong class="bold">Done.</strong>
<strong class="bold">Done.</strong>
<strong class="bold">Took 1.07 seconds to execute!</strong></pre>
			<p>如您所见，这三个进程都是独立并行启动的，因此它们都设法在一秒钟内完成。</p>
			<p><code>Process()</code>和<code>start()</code>都是不言自明的，但是<code>join()</code>函数在做什么呢？简单地说，它告诉Python要等到过程完成。如果你在所有的进程上调用<code>join()</code>，最后两行代码直到所有的进程完成后才会执行。为了好玩，尽量去掉<code>join()</code>通话；你马上就会明白要点。</p>
			<p>你现在对多处理有了一个基本的直觉，但是故事并没有就此结束。Python 3.2引入了一种新的、改进的并行执行任务的方式。迄今为止,<code>concurrent.futures</code>库是最好的，接下来您将学习如何使用它。</p>
			<p>有了它，您不必手动管理流程。每个被执行的函数都会返回一些东西，在我们的<code>sleep_func()</code>函数中是<code>None</code>。您可以通过返回最后一条语句而不是打印它来更改它。此外，这种新方法使用<code>ProcessPoolExecutor()</code>来运行。你不需要知道任何关于它的事情；只要记住它是用来同时执行多个进程的。就代码而言，只需将您想要并行运行的所有内容放入其中。这种方法开启了两个新功能:</p>
			<ul>
				<li><code>submit()</code>:用于<a id="_idIndexMarker302"/>并行运行功能。返回的结果将被附加到一个列表中，这样我们就可以用下一个函数打印它们(或者做其他任何事情)。</li>
				<li><code>result()</code>:用于<a id="_idIndexMarker303"/>获取函数返回值。我们将简单地打印结果，但是您可以自由地做任何其他事情。</li>
			</ul>
			<p>概括地说，我们将把结果附加到一个列表中，然后在函数执行完毕时打印出来。下面的<a id="_idIndexMarker304"/>代码片段向您展示了如何用最新的Python方法实现<a id="_idIndexMarker305"/>多处理:</p>
			<pre>import time 
import concurrent.futures
def sleep_func():
    print('Sleeping for a 1 second')
    time.sleep(1)
    return 'Done.'
if __name__ == '__main__':
    time_start = time.time()
    with concurrent.futures.ProcessPoolExecutor() as ppe:
        out = []
        for _ in range(5):
            out.append(ppe.submit(sleep_func))
        for curr in concurrent.futures.as_completed(out):
            print(curr.result())
    time_stop = time.time()
    print(f'Took {round(time_stop - time_start, 2)} seconds to execute!')</pre>
			<p>结果如下所示:</p>
			<pre><strong class="bold">Sleeping for a 1 second</strong>
<strong class="bold">Sleeping for a 1 second</strong>
<strong class="bold">Sleeping for a 1 second</strong>
<strong class="bold">Sleeping for a 1 second</strong>
<strong class="bold">Sleeping for a 1 second</strong>
<strong class="bold">Done.</strong>
<strong class="bold">Done.</strong>
<strong class="bold">Done.</strong>
<strong class="bold">Done.</strong>
<strong class="bold">Done.</strong>
<strong class="bold">Took 1.17 seconds to execute!</strong></pre>
			<p>如您所见，该程序的行为与我们之前的类似，但有一些额外的好处——您不必自己管理流程，语法也更加清晰。</p>
			<p>到目前为止，我们的一个问题是缺少函数参数。目前，我们只是调用一个不接受任何参数的函数。大多数情况下不会是这样的，所以尽早学习如何处理函数参数很重要。</p>
			<p>我们将为我们的<code>sleep_func()</code>函数引入一个参数，允许我们指定执行将暂停多长时间。函数中的print语句会相应地更新。睡眠时间在<code>sleep_seconds</code>列表中定义，并且该值在每次迭代时作为第二个参数传递给<code>append()</code>。</p>
			<p>完整的片段如下所示:</p>
			<pre>import time 
import concurrent.futures
def sleep_func(how_long: int):
    print(f'Sleeping for a {how_long} seconds')
    time.sleep(how_long)
    return f'Finished sleeping for {how_long} seconds.'
if __name__ == '__main__':
    time_start = time.time()
    sleep_seconds = [1, 2, 3, 1, 2, 3]
    with concurrent.futures.ProcessPoolExecutor() as ppe:
        out = []
        for sleep_second in sleep_seconds:
            out.append(ppe.submit(sleep_func, sleep_second))
        for curr in concurrent.futures.as_completed(out):
            print(curr.result())
    time_stop = time.time()
    print(f'Took {round(time_stop - time_start, 2)} seconds to execute!')</pre>
			<p>这里显示了<a id="_idIndexMarker308"/>结果<a id="_idIndexMarker309"/>:</p>
			<pre><strong class="bold">Sleeping for 1 seconds</strong>
<strong class="bold">Sleeping for 2 seconds</strong>
<strong class="bold">Sleeping for 3 seconds</strong>
<strong class="bold">Sleeping for 1 seconds</strong>
<strong class="bold">Sleeping for 2 seconds</strong>
<strong class="bold">Sleeping for 3 seconds</strong>
<strong class="bold">Finished sleeping for 1 seconds.</strong>
<strong class="bold">Finished sleeping for 1 seconds.</strong>
<strong class="bold">Finished sleeping for 2 seconds.</strong>
<strong class="bold">Finished sleeping for 2 seconds.</strong>
<strong class="bold">Finished sleeping for 3 seconds.</strong>
<strong class="bold">Finished sleeping for 3 seconds.</strong>
<strong class="bold">Took 3.24 seconds to execute!</strong></pre>
			<p>这就是你在并行处理中处理函数参数的方式。请记住，每台机器上的执行时间不会完全相同，因为运行时间将取决于您的硬件。一般来说，与脚本的非并行版本相比，您肯定会看到速度的提高。现在，您已经了解了并行处理的基础知识。在下一节中，您将了解Python的Dask库是如何发挥作用的，在随后的一节中，您将结合并行编程、Dask和TPOT来构建机器学习模型。</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor068"/>Dask库简介</h1>
			<p>您可以将Dask视为最具革命性的大规模数据处理Python库之一。如果你是一个普通的熊猫和NumPy用户，你会喜欢Dask的。这个库允许你处理NumPy和pandas不允许的数据，因为它们不适合内存。</p>
			<p>Dask支持NumPy数组和pandas DataFrame数据结构，因此您可以很快熟悉它。它既可以在您的计算机上运行，也可以在集群上运行，这样更容易扩展。您只需要编写一次代码，然后选择运行它的环境。就这么简单。</p>
			<p>另一件需要注意的事情是，Dask允许您以最小的改动并行运行代码。正如您之前看到的，并行处理意味着执行时间减少，这通常是我们想要的行为。稍后，您将了解Dask中的并行性如何与<code>dask.delayed</code>一起工作。</p>
			<p>要开始，您必须安装库。确保激活了正确的环境。然后，从终端执行以下命令:</p>
			<pre><strong class="bold">pipenv install "dask[complete]"</strong></pre>
			<p>还有其他安装选项。例如，您可以只安装arrays或DataFrames模块，但最好从一开始就安装所有组件。不要忘记在库名两边加上引号，否则会导致错误。</p>
			<p>如果您已经安装了所有的东西，您将可以访问三个Dask集合——数组、数据帧和包。所有这些都可以存储大于RAM大小的数据集，并且它们都可以在RAM和硬盘驱动器之间划分数据。</p>
			<p>让我们从<a id="_idIndexMarker313"/> Dask数组开始，并将它们与NumPy替代数组进行比较。通过在笔记本环境中执行以下代码单元，您可以创建1，000x1，000x1，000维的<a id="_idIndexMarker314"/>  a NumPy数组。<code>%%time</code> magic命令用于测量单元完成执行所需的时间:</p>
			<pre>%%time
import numpy as np
np_ones = np.ones((1000, 1000, 1000))</pre>
			<p>构造比这个更大的数组会导致我机器上的内存错误，但是这对于比较来说很好。相应的输出如下所示:</p>
			<pre><strong class="bold">CPU times: user 1.86 s, sys: 2.21 s, total: 4.07 s</strong>
<strong class="bold">Wall time: 4.35 s</strong></pre>
			<p>如您所见，创建这个数组花了4.35秒。现在，让我们对Dask做同样的事情:</p>
			<pre>%%time
import dask.array as da
da_ones = da.ones((1000, 1000, 1000))</pre>
			<p>如您所见，惟一的变化是库导入名称。如果这是您第一次接触Dask库，执行时间的结果可能会让您大吃一惊。它们如下所示:</p>
			<pre><strong class="bold">CPU times: user 677 µs, sys: 12 µs, total: 689 µs</strong>
<strong class="bold">Wall time: 696 µs </strong></pre>
			<p>是的，你<a id="_idIndexMarker315"/>没看错。Dask花了696微秒创建了一个相同维数的数组，速度快了6250倍。当然，您不应该期望在现实世界中执行时间会有如此大的减少，但是差别应该还是很大的。</p>
			<p>接下来，我们来看一下Dask DataFrames。语法应该是非常相似的，所以学习这个库应该不会花你太多时间。为了充分展示Dask的能力，我们将创建一些无法在一台笔记本电脑的内存中容纳的大型数据集。更准确地说，我们将创建10个基于时间序列的CSV文件，每个文件呈现一年的数据，这些数据以秒为单位进行聚合，并通过五个不同的特性进行测量。这是一个很大的数目，创建它肯定需要一些时间，但是您最终应该得到10个数据集，每个数据集的大小大约为1 GB。如果你像我一样有一台8 GB内存的笔记本电脑，你不可能把它放在内存里。</p>
			<p>以下代码片段创建了这些数据集:</p>
			<pre>import pandas as pd
from datetime import datetime
for year in np.arange(2010, 2020):
    dates = pd.date_range(
        start=datetime(year=year, month=1, day=1),
        end=datetime(year=year, month=12, day=31),
        freq='S'
    )
    df = pd.DataFrame()
    df['Date'] = dates
    for i in range(5):
        df[f'X{i}'] = np.random.randint(low=0, high=100, size=len(df))
        
    df.to_csv(f'data/{year}.csv', index=False)
!ls data/</pre>
			<p>只要确保有这个<code>/data</code>文件夹，你的笔记本就可以了。此外，如果你继续下去，确保你有10 GB的磁盘空间。最后一行<code>!ls data/</code>，列出了位于<code>data</code>文件夹中的所有文件。以下是您应该看到的内容:</p>
			<pre><strong class="bold">2010.csv 2012.csv 2014.csv 2016.csv 2018.csv</strong>
<strong class="bold">2011.csv 2013.csv 2015.csv 2017.csv 2019.csv</strong></pre>
			<p>现在，让我们看看pandas读取一个CSV文件并执行一个简单的聚合需要多少时间。更准确地说，数据集按月分组，并提取总和。下面的代码片段演示了如何做到这一点:</p>
			<pre>%%time
df = pd.read_csv('data/2010.csv', parse_dates=['Date'])
avg = df.groupby(by=df['Date'].dt.month).sum()</pre>
			<p>结果如下所示:</p>
			<pre><strong class="bold">CPU times: user 26.5 s, sys: 9.7 s, total: 36.2 s</strong>
<strong class="bold">Wall time: 42 s</strong></pre>
			<p>正如你所看到的，熊猫花了42秒来完成这个计算。还不算太糟，但是如果您绝对需要加载所有数据集并执行计算，该怎么办呢？接下来让我们来探索一下。</p>
			<p>您可以使用<code>glob</code>库获取指定文件夹中所需文件的路径。然后你可以单独读取它们，并使用pandas的<code>concat()</code>功能将它们堆叠在一起。聚合以相同的方式执行:</p>
			<pre>%%time
import glob
all_files = glob.glob('data/*.csv')
dfs = []
for fname in all_files:
    dfs.append(pd.read_csv(fname, parse_dates=['Date']))
    
df = pd.concat(dfs, axis=0)
agg = df.groupby(by=df['Date'].dt.year).sum()</pre>
			<p>这里没什么可说的——笔记本就这么碎了。对于8 GB RAM的机器来说，将10 GB以上的数据存储到RAM中是不可行的。解决这个问题的一个方法是成块加载数据，但这本身就令人头疼。</p>
			<p>Dask能帮上什么忙？让我们学习如何用Dask加载这些CSV并执行相同的聚合。您可以使用下面的代码片段来实现这一点:</p>
			<pre>%%time
import dask.dataframe as dd
df = dd.read_csv('data/*.csv', parse_dates=['Date'])
agg = df.groupby(by=df['Date'].dt.year).sum().compute()</pre>
			<p>结果会再次让你大吃一惊:</p>
			<pre><strong class="bold">CPU times: user 5min 3s, sys: 1min 11s, total: 6min 15s</strong>
<strong class="bold">Wall time: 3min 41s</strong></pre>
			<p>没错，在不到4分钟的时间里，Dask设法将超过10 GB的数据读取到一台8 GB RAM的机器上。仅此一点就应该让你重新考虑NumPy和pandas，特别是如果你正在处理大量的数据或者你期望在不久的将来处理它。</p>
			<p>最后还有Dask包。它们<a id="_idIndexMarker319"/>用于存储和处理不适合内存的一般Python数据类型——例如日志数据。我们不会探究这种数据结构，但是知道它的存在是很好的。</p>
			<p>另一方面，我们将用Dask探索并行处理的概念。您在前面的<a id="_idIndexMarker320"/>章节中了解到，没有有效的理由按顺序处理数据或执行任何其他操作，因为一个的输入不依赖于另一个的输出。</p>
			<p><em class="italic"> Dask延迟</em>允许并行执行。当然，您仍然可以只依赖于我们之前学到的多处理概念，但是为什么呢？这可能是一个乏味的方法，Dask有更好的东西提供。使用Dask，不需要像纯Python那样改变编程语法。你只需要用<code>@dask.delayed</code> decorator注释一个你想要并行化的函数，你就可以开始了！</p>
			<p>您可以并行化多个函数，然后将它们放入计算图中。这就是我们接下来要做的。</p>
			<p>下面的代码片段声明了两个函数:</p>
			<ul>
				<li><code>cube()</code>:返回一个数字的立方</li>
				<li><code>multiply()</code>:将列表中的所有数字相乘并返回乘积</li>
			</ul>
			<p>以下是您需要的库导入:</p>
			<pre>import time
import dask
import math
from dask import delayed, compute</pre>
			<p>让我们对五个数字运行第一个函数，对结果调用第二个函数，看看会发生什么。注意在<code>cube()</code>函数中对<code>time.sleep()</code>的调用。这将使发现并行化和非并行化函数之间的差异变得更加容易:</p>
			<pre>%%time
def cube(number: int) -&gt; int:
    print(f'cube({number}) called!')
    time.sleep(1)
    return number ** 3
def multiply(items: list) -&gt; int:
    print(f'multiply([{items}]) called!')
    return math.prod(items)
numbers = [1, 2, 3, 4, 5]
graph = multiply([cube(num) for num in numbers])
print(f'Total = {graph}')</pre>
			<p>这是您的常规(顺序)数据处理。没什么不好，尤其是<a id="_idIndexMarker321"/>这么少这么简单的操作。相应的输出如下所示:</p>
			<pre><strong class="bold">cube(1) called!</strong>
<strong class="bold">cube(2) called!</strong>
<strong class="bold">cube(3) called!</strong>
<strong class="bold">cube(4) called!</strong>
<strong class="bold">cube(5) called!</strong>
<strong class="bold">multiply([[1, 8, 27, 64, 125]]) called!</strong>
<strong class="bold">Total = 1728000</strong>
<strong class="bold">CPU times: user 8.04 ms, sys: 4 ms, total: 12 ms</strong>
<strong class="bold">Wall time: 5.02 s</strong></pre>
			<p>正如所料，由于顺序执行，代码单元运行了大约5秒钟。现在，让我们来看看为了并行化这些功能，您必须做哪些修改:</p>
			<pre>%%time
@delayed
def cube(number: int) -&gt; int:
    print(f'cube({number}) called!')
    time.sleep(1)
    return number ** 3
@delayed
def multiply(items: list) -&gt; int:
    print(f'multiply([{items}]) called!')
    return math.prod(items)
numbers = [1, 2, 3, 4, 5]
graph = multiply([cube(num) for num in numbers])
print(f'Total = {graph.compute()}')</pre>
			<p>因此，图中只有<a id="_idIndexMarker322"/>装饰器和对<code>compute()</code>的调用。结果显示在这里:</p>
			<pre><strong class="bold">cube(3) called!cube(2) called!cube(4) called!</strong>
<strong class="bold">cube(1) called!</strong>
<strong class="bold">cube(5) called!</strong>
<strong class="bold">multiply([[1, 8, 27, 64, 125]]) called!</strong>
<strong class="bold">Total = 1728000</strong>
<strong class="bold">CPU times: user 6.37 ms, sys: 5.4 ms, total: 11.8 ms</strong>
<strong class="bold">Wall time: 1.01 s</strong></pre>
			<p>正如所料，由于并行执行，整个过程只花了一秒多一点的时间。之前宣布的计算图有一个更方便的特性——很容易可视化。你需要在你的机器上安装GraphViz 并作为一个Python库。每个操作系统的步骤都不一样，所以我们在这里就不赘述了。快速的谷歌搜索会告诉你如何安装。完成后，您可以执行以下代码行:</p>
			<pre>graph.visualize()</pre>
			<p>相应的可视化显示如下:</p>
			<div><div><img src="img/B16954_05_001.jpg" alt="Figure 5.1 – Visualization of a Dask computational graph&#13;&#10;" width="473" height="433"/>
				</div>
			</div>
			<p class="figure-caption">图5.1-Dask计算图的可视化</p>
			<p>从图中可以看到，<code>cube()</code>函数被并行调用了五次，其结果被<a id="_idIndexMarker324"/>存储在它上面的桶中。然后，使用这些值调用<code>multiply()</code>函数<a id="_idIndexMarker325"/>，并将产品存储在顶部存储桶中。</p>
			<p>这就是你需要了解的关于Dask的基础知识。您已经学习了如何使用Dask数组和数据帧，以及如何使用Dask并行处理操作。不仅如此，你还学到了Dask在现代数据科学和机器学习中扮演的重要角色。数据集大小经常超过可用内存，因此需要现代解决方案。</p>
			<p>在下一节中，您将学习如何使用Dask训练TPOT自动机器学习模型。</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor069"/>用TPOT和达斯克训练机器学习模型</h1>
			<p>首先，优化机器学习管道是一个耗时的过程。我们可以<a id="_idIndexMarker327"/>通过并行运行来显著缩短时间。Dask和TPOT结合使用效果很好，本节将教您如何在Dask集群上训练TPOT模型。不要让“集群”这个词吓到你，因为你的笔记本电脑或个人电脑就足够了。</p>
			<p>你必须<a id="_idIndexMarker329"/>再安装一个库才能继续，它叫做<code>dask-ml</code>。顾名思义，它是用来和Dask一起执行机器学习的。从终端执行以下命令进行安装:</p>
			<pre><strong class="bold">pipenv install dask-ml</strong></pre>
			<p>一旦完成，你就可以打开Jupyter实验室或者你最喜欢的Python代码编辑器，开始编码。让我们开始吧:</p>
			<ol>
				<li>Let's start with library imports. We'll also make a dataset decision here. This time, we won't spend any time on data cleaning, preparation, or examination. The goal is to have a dataset ready as soon as possible. The <code>load_digits()</code> function from scikit-learn comes in handy because it is designed to fetch many 8x8 pixel digit images for classification.<p>由于一些库经常用不必要的警告填满你的屏幕，我们将使用<code>warnings</code>库来忽略它们。请参考以下所有库导入的代码片段:</p><pre>import tpot
from tpot import TPOTClassifier
from sklearn.datasets import load_digits
from sklearn.model_selection import train_test_split
from dask.distributed import Client
import warnings
warnings.filterwarnings('ignore')</pre><p>这里唯一的新东西是来自<code>dask.distributed</code>的<code>Client</code>类。它用于建立与Dask集群(本例中是您的计算机)的连接。</p></li>
				<li>You'll <a id="_idIndexMarker330"/>now make <a id="_idIndexMarker331"/>an instance of the client. This will immediately start the Dask cluster and use all the CPU cores you have available. Here's the code for instance creation and checking where the cluster runs:<pre>client = Client()
client</pre><p>执行后，您应该会看到以下输出:</p><div><img src="img/B16954_05_002.jpg" alt="Figure 5.2 – Information on the Dask cluster&#13;&#10;" width="712" height="166"/></div><p class="figure-caption">图5.2–关于Dask集群的信息</p><p>你可以<a id="_idIndexMarker332"/>点击仪表盘链接，会带你去http://127.0.0.1:8787/status。下面的截图显示了仪表板<a id="_idIndexMarker333"/>第一次打开时的样子(没有任务运行):</p><div><img src="img/B16954_05_003.jpg" alt="Figure 5.3 – Dask cluster dashboard (no running tasks)&#13;&#10;" width="1379" height="669"/></div><p class="figure-caption">图5.3–Dask集群仪表板(无运行任务)</p><p>一旦你开始训练模型，仪表盘会变得更加丰富多彩。接下来我们会做必要的准备。</p></li>
				<li>You can call the <code>load_digits()</code> function to get the image data and then use the <code>train_test_split()</code> function to split the images into subsets for training and testing. The train/test ratio is 50:50 for this example, as we don't want to spend too much time on the training. The ratio should be higher for the training set in almost any scenario, so make sure to remember that.<p>一旦分割完成，您可以在子集上调用<code>.shape</code>来检查它们的维度。以下是完整的代码片段:</p><pre>digits = load_digits()
X_train, X_test, y_train, y_test = train_test_split(
    digits.data,
    digits.target,
    test_size=0.5,
)
X_train.shape, X_test.shape</pre><p><a id="_idIndexMarker334"/>对应的输出如下图所示:</p><div><img src="img/B16954_05_004.jpg" alt="Figure 5.4 – Dimensionality of training and testing subsets&#13;&#10;" width="358" height="44"/></div><p class="figure-caption">图5.4–训练和测试子集的维度</p><p>下一站——模特培训。</p></li>
				<li>You <a id="_idIndexMarker335"/>now have everything needed to train models with TPOT and Dask. You can do so in a very similar fashion to what you did previously. The key parameter here is <code>use_dask</code>. You should set it to <code>True</code> if you want to use Dask for training. The other parameters are well known:<pre>estimator = TPOTClassifier(
    n_jobs=-1,
    random_state=42,
    use_dask=True,
    verbosity=2,
    max_time_mins=10
)</pre><p>现在，您已经准备好调用<code>fit()</code>函数，并在训练子集上训练模型。下面是这样做的一行代码:</p><pre>estimator.fit(X_train, y_train)</pre><p>在你开始训练<a id="_idIndexMarker337"/>模型后，Dask仪表盘的<a id="_idIndexMarker336"/>外观会立即改变。这是这个过程开始几分钟后的样子:</p></li>
			</ol>
			<div><div><img src="img/B16954_05_005.jpg" alt="Figure 5.5 – Dask dashboard during training&#13;&#10;" width="1380" height="701"/>
				</div>
			</div>
			<p class="figure-caption">图5.5–培训期间的Dask仪表板</p>
			<p>10分钟后，TPOT将完成管道优化，您将在笔记本上看到以下输出:</p>
			<div><div><img src="img/B16954_05_006.jpg" alt="Figure 5.6 – TPOT optimization outputs&#13;&#10;" width="1117" height="290"/>
				</div>
			</div>
			<p class="figure-caption">图5.6-TPOT优化输出</p>
			<p>这就是你要把TPOT和达斯克结合起来所要做的。</p>
			<p>您现在<a id="_idIndexMarker338"/>知道如何<a id="_idIndexMarker339"/>在Dask集群上训练模型，这是处理更大数据集和更具挑战性问题的推荐方式。</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor070"/>总结</h1>
			<p>这一章不仅包含了关于TPOT和并行训练模型的信息，还包含了关于并行性的一般信息。你已经学到了很多东西——从如何并行化除了休眠一会儿什么也不做的基本函数，到并行化带有参数和Dask基础的函数，到在Dask集群上用TPOT和Dask训练机器学习模型。</p>
			<p>到目前为止，您已经知道如何以自动化的方式解决回归和分类任务，以及如何并行化训练过程。接下来的章节<a href="B16954_06_Final_SK_ePub.xhtml#_idTextAnchor073"> <em class="italic">第六章</em> </a> <em class="italic">《深度学习入门——神经网络速成班</em>》将为你提供所需的关于神经网络的知识。它将为第7章<em class="italic"><a href="B16954_07_Final_SK_ePub.xhtml#_idTextAnchor086">和TPOT </a></em>的神经网络分类器奠定基础，在那里我们将深入研究用最先进的神经网络算法训练自动化机器学习模型。</p>
			<p>和往常一样，请随意练习用TPOT解决回归和分类任务，但是这一次，尝试用Dask并行化这个过程。</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor071"/>问&amp;答</h1>
			<ol>
				<li value="1">定义术语“并行”</li>
				<li>解释哪些类型的任务可以并行化，哪些不可以并行化。</li>
				<li>列出并解释在您的应用程序中实现并行性的三个选项(所有选项都在本章中列出)。</li>
				<li>Dask是什么，是什么让它在较大数据集上优于NumPy和pandas？</li>
				<li>说出并解释在Dask中实现的三种基本数据结构。</li>
				<li>什么是Dask集群？</li>
				<li>你要怎么做才能告诉TPOT应该用Dask来训练？</li>
			</ol>
		</div>
	</div>
</body></html>