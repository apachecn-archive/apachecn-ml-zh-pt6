<html><head/><body>









<title>Chapter 3: Deep Learning Containers</title>







<div><div><h1 class="chapter-number" id="_idParaDest-58"><a id="_idTextAnchor060"/> <a id="_idTextAnchor061"/> 3</h1>

<h1 id="_idParaDest-59"><a id="_idTextAnchor062"/>深度学习容器</h1>

<p>在<a href="B18638_02.xhtml#_idTextAnchor041"> <em class="italic">第二章</em> </a>、<em class="italic">深度学习AMIs </em>中，我们使用<strong class="bold"> AWS深度学习AMIs </strong> ( <strong class="bold"> DLAMIs </strong>)在EC2实例内部建立一个环境，在那里我们可以训练和评估深度学习模型。在这一章中，我们将仔细研究一下<strong class="bold"> AWS深度学习容器</strong> ( <strong class="bold"> DLCs </strong>)，它们可以跨多个环境和服务一致地运行。除此之外，我们还将讨论DLAMIs和DLC之间的异同。</p>

<p>本章中的实践解决方案着重于我们可以使用DLCs的不同方式来解决在云中处理<strong class="bold">机器学习</strong> ( <strong class="bold"> ML </strong>)需求时的几个棘手问题。例如，像<strong class="bold"> Docker </strong>这样的容器技术允许我们充分利用正在运行的EC2实例，因为我们将能够在容器中运行不同类型的应用程序，而不必担心它们的依赖关系是否会冲突。除此之外，在尝试管理和降低成本时，我们将有更多的选项和解决方案可用。首先，如果我们使用<strong class="bold"> AWS Lambda </strong>(一种无服务器计算服务，允许我们运行自定义后端代码)的容器映像支持来在无服务器功能内部署我们的深度学习模型，我们将能够显著降低与全天候运行推理端点相关的基础设施成本。同时，对于无服务器函数，我们需要担心的只是函数内部的定制代码，因为AWS会负责运行该函数的基础设施。</p>

<p>在前一章的<em class="italic">了解AWS定价如何适用于EC2实例</em>一节中讨论的场景中，我们能够使用<code>m6i.large</code>实例将运行24/7推理端点的成本降低到大约每月<em class="italic">69.12美元</em>。值得注意的是，即使这个推断端点没有接收到任何流量，这个值或多或少会保持不变。换句话说，我们可能每月支付<em class="italic">69.12美元</em>来购买一项未充分利用或未使用的资源。如果我们要建立一个与生产环境配置相同的转移环境，该成本将会翻倍，并且几乎可以肯定转移环境资源将会严重利用不足。此时，您可能会想，<em class="italic">我们有可能进一步降低成本吗？好消息是这是可能的，只要我们能够使用正确的工具、服务和框架来设计一个更好的架构。</em></p>

<p>我们将通过在DLC内训练一个<strong class="bold"> PyTorch </strong>模型来开始本章的实践部分。这个模型将被上传到一个定制的容器映像中，该映像将被用来创建一个<strong class="bold"> AWS Lambda </strong>函数。之后，我们将创建一个<strong class="bold"> API网关</strong> HTTP API，它接受一个HTTP请求，并用一个包含输入请求数据的事件触发AWS Lambda函数。然后，AWS Lambda函数将加载我们为执行ML预测而训练的模型。</p>

<p>在本章中，我们将讨论以下主题:</p>

<ul>

<li>AWS深度学习容器入门</li>

<li>基本先决条件</li>

<li>使用AWS深度学习容器来训练ML模型</li>

<li>具有Lambda容器映像支持的无服务器ML部署</li>

</ul>

<p>在研究本章的动手解决方案时，我们将讨论几个<em class="italic">无服务器</em>服务，如AWS Lambda和Amazon API Gateway，它们允许我们运行应用程序，而不必自己管理基础设施。同时，使用这些资源的成本会根据这些资源的使用情况自动调整。在典型的设置中，我们可能有一个24/7运行的EC2实例，我们将为运行的资源付费，而不管它是否被使用。有了AWS Lambda，我们只需要在函数代码运行时付费。如果它每个月只运行几秒钟，那么我们这个月的费用可能接近于零！</p>

<p>记住这几点，让我们从AWS DLCs如何工作的快速介绍开始本章。</p>

<h1 id="_idParaDest-60"><a id="_idTextAnchor063"/>技术要求</h1>

<p>开始之前，我们必须准备好以下内容:</p>

<ul>

<li>网络浏览器(最好是Chrome或Firefox)</li>

<li>访问本书前两章中使用的AWS帐户</li>

<li>访问您在<em class="italic">创建您的Cloud9环境</em>和<em class="italic">增加Cloud9存储</em>章节<a href="B18638_01.xhtml#_idTextAnchor017"> <em class="italic">第1章</em> </a>、<em class="italic">AWS上的ML工程介绍</em>中准备的Cloud9环境</li>

</ul>

<p>本书的GitHub资源库https://GitHub . com/packt publishing/Machine-Learning-Engineering-on-AWS提供了Jupyter笔记本、源代码和其他用于每章的文件。</p>

<p class="callout-heading">重要说明</p>

<p class="callout">建议您在运行本书中的示例时，使用具有有限权限的IAM用户，而不是root帐户。我们将在<a href="B18638_09.xhtml#_idTextAnchor187"> <em class="italic">第9章</em> </a>、<em class="italic">安全、治理和遵从性策略</em>中详细讨论这一点以及其他安全最佳实践。如果您刚刚开始使用AWS，您可以同时继续使用root帐户。</p>

<h1 id="_idParaDest-61"><a id="_idTextAnchor064"/>AWS深度学习容器入门</h1>

<p>容器<a id="_idIndexMarker219"/>允许开发人员、工程师和系统管理员在一致的隔离环境中运行进程、脚本和<a id="_idIndexMarker220"/>应用程序。这种一致性是有保证的，因为这些容器是从<a id="_idIndexMarker221"/>容器映像启动的，类似于EC2实例从<strong class="bold">亚马逊机器映像</strong> ( <strong class="bold"> AMIs </strong>)启动的方式。</p>

<p>值得注意的是，我们可以在一个实例中同时运行不同的独立容器。这使得工程团队能够充分利用现有实例的计算能力，运行不同类型的流程和工作负载，如下图所示:</p>

<div><div><img alt="Figure 3.1 – Running multiple containers inside a single EC2 instance&#10;&#10;" height="511" src="img/B18638_03_001.jpg" width="1336"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.1–在一个EC2实例中运行多个容器</p>

<p>最受欢迎的集装箱管理解决方案之一是Docker。它是一个<a id="_idIndexMarker223"/>开源容器化平台，允许开发者和工程师轻松地构建、运行和管理容器。它涉及到一个<strong class="bold"> Dockerfile </strong>的使用，这个<a id="_idIndexMarker224"/>是一个包含如何构建容器映像的说明的文本文档。然后，这些容器映像被管理并存储在容器注册表中，以便以后可以使用。</p>

<p class="callout-heading">注意</p>

<p class="callout">Docker图像<a id="_idIndexMarker225"/>用于创建容器。Docker图像就像ZIP文件，它打包了运行应用程序所需的一切。当Docker容器从容器映像运行时(使用<code>docker run</code>命令)，容器就像一个虚拟机，其环境与运行容器的服务器隔离开来。</p>

<p>现在我们对容器和容器映像的工作原理有了更好的了解，让我们继续讨论什么是DLC，以及如何使用它们来加速ML模型的训练和部署。使用AWS DLCs的一个主要好处是，大多数相关的ML包、框架和库已经安装在容器映像中。这意味着ML工程师和数据科学家不再需要担心安装和配置ML框架、库和包。这允许他们继续准备用于训练和部署他们的深度学习模型的定制脚本。</p>

<p>由于<a id="_idIndexMarker226"/> DLC <a id="_idIndexMarker227"/>映像仅仅是预构建的容器映像，因此这些<a id="_idIndexMarker228"/>可以用于任何可以使用容器<a id="_idIndexMarker231"/>和容器映像的<a id="_idIndexMarker229"/> AWS服务<a id="_idIndexMarker230"/>。这些AWS服务包括<strong class="bold">亚马逊EC2 </strong>、<strong class="bold">亚马逊弹性容器服务</strong> ( <strong class="bold"> ECS </strong>)、<strong class="bold">亚马逊弹性Kubernetes服务(EKS) </strong>、<strong class="bold">亚马逊SageMaker </strong>、<strong class="bold"> AWS CodeBuild </strong>、<strong class="bold"> AWS Lambda </strong>、<a id="_idIndexMarker232"/>等等。</p>

<p>记住这些，让我们继续使用AWS深度学习容器来训练和部署深度学习模型！</p>

<h1 id="_idParaDest-62"><a id="_idTextAnchor065"/>必要的先决条件</h1>

<p>在本节中，我们将确保在继续培训步骤之前，满足以下先决条件:</p>

<ol>

<li>我们将准备一个Cloud9环境，并确保它已经设置好，这样我们就可以训练模型并构建定制的容器映像。</li>

<li>我们将准备一个训练数据集，用于训练深度学习模型。</li>

</ol>

<h2 id="_idParaDest-63"><a id="_idTextAnchor066"/>准备Cloud9环境</h2>

<p>在本章的第一部分，我们将在EC2实例中运行我们的深度学习容器，类似于下图所示:</p>

<div><div><img alt="Figure 3.2 – Running a Deep Learning Container inside an EC2 instance&#10;&#10;" height="537" src="img/B18638_03_002.jpg" width="1450"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.2–在EC2实例中运行深度学习容器</p>

<p>这个<a id="_idIndexMarker234"/>容器将作为使用脚本训练ML模型的环境，该脚本利用了<strong class="bold"> PyTorch </strong>框架。即使PyTorch没有安装在EC2实例中，训练脚本仍然可以成功运行，因为它将在预先安装了PyTorch的容器环境中执行。</p>

<p class="callout-heading">注意</p>

<p class="callout">如果你想知道PyTorch是什么，它是可用的最流行的开源ML框架之一。你可以去https://pytorch.org/了解更多信息。</p>

<p>在下一组步骤中，我们将确保我们的Cloud9环境已经准备就绪:</p>

<ol>

<li value="1">在搜索栏中输入<code>cloud9</code>。从结果列表中选择<strong class="bold"> Cloud9 </strong>:</li>

</ol>

<div><div><img alt="Figure 3.3 – Navigating to the Cloud9 console&#10;&#10;" height="665" src="img/B18638_03_003.jpg" width="1650"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.3–导航至Cloud9控制台</p>

<p class="list-inset">在这里，我们可以看到该区域当前被设置为<code>us-west-2</code>。确保您将此更改为您在第1章 、<em class="italic">AWS上的ML工程简介</em>中创建Cloud9实例的位置。</p>

<ol>

<li value="2">在<a href="B18638_01.xhtml#_idTextAnchor017"> <em class="italic">第一章</em> </a>、<em class="italic">AWS上的ML工程介绍</em>的<em class="italic">创建你的Cloud9环境</em>部分打开你创建的Cloud9环境，点击<a href="B18638_01.xhtml#_idTextAnchor017"> <em class="italic">第一章</em> </a>、<em class="italic">AWS上的ML工程介绍</em>中创建Cloud9环境的<code>us-west-2</code>。</li>

</ol>

<p class="callout-heading">注意</p>

<p class="callout">如果您跳过了第一章，请确保在继续之前完成该章的<em class="italic">创建您的Cloud9环境</em>和<em class="italic">增加Cloud9存储</em>部分。</p>

<ol>

<li value="3">在Cloud9环境的终端，运行以下<code>bash</code>命令创建<code>ch03</code>目录:<pre class="source-code"><strong class="bold">mkdir -p ch03</strong></pre> <pre class="source-code"><strong class="bold">cd ch03</strong></pre></li>

</ol>

<p class="list-inset">我们将使用这个目录作为本章的当前工作目录。</p>

<p>现在我们已经准备好了Cloud9环境，让我们继续下载训练数据集，以便我们可以训练我们的深度学习模型。</p>

<h2 id="_idParaDest-64"><a id="_idTextAnchor067"/>下载样本数据集</h2>

<p>我们将在本章中使用的<a id="_idIndexMarker238"/>训练数据集与我们在<a href="B18638_02.xhtml#_idTextAnchor041"> <em class="italic">第2章</em> </a>、<em class="italic">深度学习AMIs </em>中使用的数据集相同。它有两列对应于连续的<em class="italic"> x </em>和<em class="italic"> y </em>变量。在本章的后面，我们还将使用这个数据集生成一个回归模型。回归模型预期接受输入的<em class="italic"> x </em>值，并返回预测的<em class="italic"> y </em>值。</p>

<p>在下一组步骤中，我们将把训练数据集下载到我们的Cloud9环境中:</p>

<ol>

<li value="1">运行以下命令创建<code>data</code>目录:<pre class="source-code">mkdir -p <strong class="bold">data</strong></pre></li>

<li>接下来，让我们使用<code>wget</code>命令:<pre class="source-code">wget https://bit.ly/3h1KBx2 -O<strong class="bold"> data/training_data.csv</strong></pre>下载训练数据CSV文件</li>

<li>使用<code>head</code>命令检查我们的训练数据是什么样子:<pre class="source-code">head <strong class="bold">data/training_data.csv</strong></pre></li>

</ol>

<p class="list-inset">这将为我们提供多行<em class="italic"> (x，y)对</em>，类似于下面的截图所示:</p>

<div><div><img alt="Figure 3.4 – The first few rows of the training_data.csv file&#10;&#10;" height="400" src="img/B18638_03_004.jpg" width="1287"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.4–training _ data . CSV文件的前几行</p>

<p class="list-inset">因为我们<a id="_idIndexMarker239"/>是在<code>ch03</code>目录中开始这一节的，所以需要注意的是<code>training_data.csv</code>文件应该在<code>ch03/data</code>目录中。</p>

<p>既然我们已经准备好了先决条件，我们可以继续进行培训步骤。</p>

<h1 id="_idParaDest-65"><a id="_idTextAnchor068"/>使用AWS深度学习容器训练一个ML模型</h1>

<p>在这个<a id="_idIndexMarker240"/>点上，你可能想知道<a id="_idIndexMarker241"/>是什么让深度学习模型不同于其他ML模型。深度学习模型是相互连接的节点网络，它们相互通信，类似于人脑中神经元网络的通信方式。这些模型利用了网络中的多个层，类似于下图所示。更多的层和每层更多的神经元使深度学习模型能够处理和学习复杂的非线性模式和关系:</p>

<div><div><img alt="Figure 3.5 – Deep learning model&#10;&#10;" height="465" src="img/B18638_03_005.jpg" width="1060"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.5–深度学习模型</p>

<p>深度<a id="_idIndexMarker242"/>学习在<strong class="bold">自然语言处理</strong> ( <strong class="bold"> NLP </strong>)、<strong class="bold">计算机视觉</strong>、<strong class="bold">欺诈检测</strong>中有几个<a id="_idIndexMarker243"/>实用<a id="_idIndexMarker244"/>应用。除此之外，这里还有一些其他的<a id="_idIndexMarker245"/>应用和<a id="_idIndexMarker246"/>示例:</p>

<ul>

<li><strong class="bold">生成对抗网络</strong> ( <strong class="bold">甘斯</strong>):这些可以用来从原始<a id="_idIndexMarker247"/>数据集生成真实的例子，类似于我们在<em class="italic">使用深度学习模型生成合成数据集<a href="B18638_01.xhtml#_idTextAnchor017"> <em class="italic">第1章</em> </a>、<em class="italic">AWS上的ML工程简介</em>中的<em class="italic">部分。</em></em></li>

<li><strong class="bold">深度强化学习</strong>:这个<a id="_idIndexMarker248"/>利用深度神经网络和强化学习技术来解决机器人和游戏等行业的复杂问题。</li>

</ul>

<p>在过去的几年里，深度学习模型的培训和部署已经通过深度学习框架<a id="_idIndexMarker251"/>得到了极大的简化，如<strong class="bold"> PyTorch </strong>、<strong class="bold"> TensorFlow </strong>和<strong class="bold"> MXNet </strong>。AWS DLCs通过提供已经预装了运行这些ML框架所需的一切的容器映像，进一步加快了速度。</p>

<p class="callout-heading">注意</p>

<p class="callout">可以在这里查看可用DLC图片列表<a id="_idIndexMarker252"/>:<a href="https://github.com/aws/deep-learning-containers/blob/master/available_images.md">https://github . com/AWS/deep-learning-containers/blob/master/available _ images . MD</a>。注意，这些容器映像是按照(1)已安装的ML框架(<strong class="bold"> PyTorch </strong>、<strong class="bold"> TensorFlow </strong>或<strong class="bold"> MXNet </strong>)，(2)作业类型(<em class="italic">培训</em>或<em class="italic">推理</em>)，以及(3)已安装的Python版本来分类的。</p>

<p>在下一组<a id="_idIndexMarker253"/>步骤中，我们将<a id="_idIndexMarker254"/>使用已优化的DLC图像来训练PyTorch模型:</p>

<ol>

<li value="1">让我们通过运行以下命令下载<code>train.py</code>文件:<pre class="source-code">wget https://bit.ly/3KcsG3v -O <strong class="bold">train.py</strong></pre></li>

</ol>

<p class="list-inset">在我们继续之前，让我们从<code>File</code>树中打开<code>train.py</code>文件，检查它的内容:</p>

<div><div><img alt="Figure 3.6 – Opening the train.py file from the File tree&#10;&#10;" height="339" src="img/B18638_03_006.jpg" width="1650"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.6–从文件树中打开train.py文件</p>

<p class="list-inset">我们应该会看到一个脚本，它利用存储在<code>data</code>目录中的训练数据来训练一个深度学习模型。训练步骤完成后，该模型保存在<code>model</code>目录中:</p>

<div><div><img alt="Figure 3.7 – The main() function of the train.py script file&#10;&#10;" height="545" src="img/B18638_03_007.jpg" width="743"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.7–train . py脚本文件的main()函数</p>

<p class="list-inset">在这里，我们<a id="_idIndexMarker255"/>可以看到<a id="_idIndexMarker256"/>我们的<code>train.py</code>脚本的<code>main()</code>函数执行以下操作:</p>

<ul>

<li>(1)使用<code>prepare_model()</code>功能定义模型</li>

<li>(2)使用<code>load_data()</code>功能加载训练数据</li>

<li>(3)使用<code>fit()</code>方法执行训练步骤</li>

<li>(4)使用<code>torch.save()</code>方法保存模型工件</li>

</ul>

<p class="list-inset">如果<code>train.py</code>作为脚本直接执行，前面截图中的最后一段代码只是运行<code>main()</code>函数。</p>

<p class="callout-heading">注意</p>

<p class="callout">在这里可以找到完整的<code>train.py</code>脚本:<a href="https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/train.py">https://github . com/packt publishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter 03/train . py</a>。</p>

<ol>

<li value="2">接下来，使用<code>mkdir</code>命令:<pre class="source-code">mkdir -p <strong class="bold">model</strong></pre>创建<code>model</code>目录</li>

</ol>

<p class="list-inset">稍后，我们将看到模型输出保存在这个目录中。</p>

<ol>

<li value="3">通过<a id="_idIndexMarker258"/>运行以下命令安装<a id="_idIndexMarker257"/>实用程序:<pre class="source-code">sudo apt install <strong class="bold">tree</strong></pre></li>

<li>让我们使用刚刚安装的<code>tree</code>实用程序:<pre class="source-code"><strong class="bold">tree</strong></pre></li>

</ol>

<p class="list-inset">这将产生一个树状结构，类似于下面的截图:</p>

<div><div><img alt="Figure 3.8 – Results after using the tree command&#10;&#10;" height="386" src="img/B18638_03_008.jpg" width="1593"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.8–使用树命令后的结果</p>

<p class="list-inset">需要注意的是，<code>train.py</code>脚本位于<code>ch03</code>目录中，这也是<code>data</code>和<code>model</code>目录所在的位置。</p>

<ol>

<li value="5">使用<code>wget</code>命令:<pre class="source-code">wget https://bit.ly/3Iz7zaV -O <strong class="bold">train.sh</strong></pre>下载<code>train.sh</code>文件</li>

</ol>

<p class="list-inset">如果我们检查<code>train.sh</code>文件的内容，我们应该看到以下几行:</p>

<pre class="list-inset1 source-code">aws ecr get-login-password --region <strong class="bold">us-west-2</strong> | docker login --username AWS --password-stdin 763104351884.dkr.ecr.<strong class="bold">us-west-2</strong>.amazonaws.com

TRAINING_IMAGE=763104351884.dkr.ecr.<strong class="bold">us-west-2</strong>.amazonaws.com/pytorch-training:1.8.1-cpu-py36-ubuntu18.04

docker run -it -v `pwd`:/env -w /env $TRAINING_IMAGE python train.py</pre>

<p class="list-inset"><code>train.sh</code>脚本<a id="_idIndexMarker259"/>首先向<strong class="bold">亚马逊弹性容器注册中心</strong>(一个完全托管的Docker <a id="_idIndexMarker261"/>容器注册中心，我们可以在那里存储我们的容器映像)认证<a id="_idIndexMarker260"/>，以便我们可以成功下载训练容器映像。这个容器镜像已经预装了<em class="italic"> PyTorch 1.8.1 </em>和<em class="italic"> Python 3.6 </em>。</p>

<p class="callout-heading">重要说明</p>

<p class="callout"><code>train.sh</code>脚本中的代码假设我们将在<em class="italic"> Oregon </em> ( <code>us-west-2</code>)地区的EC2实例(运行Cloud9环境的地方)中运行训练实验。确保用适当的地区代码替换<code>us-west-2</code>。有关这个主题的更多信息，请随时查看https://docs . AWS . Amazon . com/AWS C2/latest/user guide/using-regions-avail ability-zones . XHTML。</p>

<p class="list-inset"><code>docker run</code>命令首先下载指定的容器映像，并使用该映像创建一个正在运行的容器进程。之后，在运行<code>docker run</code>命令时，使用<code>-v</code>标志将当前工作目录(<code>ch03</code>)挂载到容器后，当前工作目录的内容被“复制”到容器中。然后，我们使用<code>-w</code>标志将工作目录设置为我们的文件在容器中的挂载位置(<code>/env</code>)。一旦所有步骤都完成了，就在运行容器的环境中执行<code>train.py</code>脚本。</p>

<p class="callout-heading">注意</p>

<p class="callout">查看<a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a>了解更多关于如何使用<code>docker run</code>命令的信息。</p>

<ol>

<li value="6">现在<a id="_idIndexMarker262"/>我们对执行<code>train.sh</code>文件时会发生什么有了一个更好的<a id="_idIndexMarker263"/>想法，让我们使用下面的命令运行它:<pre class="source-code"><strong class="bold">chmod +x train.sh</strong></pre> <pre class="source-code"><strong class="bold">./train.sh</strong></pre></li>

</ol>

<p class="list-inset">这将产生一组日志，如下所示:</p>

<div><div><img alt="Figure 3.9 – Logs generated while running the train.sh script&#10;&#10;" height="278" src="img/B18638_03_009.jpg" width="1208"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.9–运行train.sh脚本时生成的日志</p>

<p class="list-inset">这里，<code>train.sh</code>脚本运行一个容器，该容器调用<code>train.py</code> (Python)脚本来训练深度学习模型。在前面的屏幕截图中，我们可以看到由<code>train.py</code>脚本生成的日志，因为它迭代地更新神经网络的权重，以提高输出模型的质量(也就是说，减少每次迭代的损失，以便我们可以最小化错误)。值得注意的是，这个<code>train.py</code>脚本利用<strong class="bold"> PyTorch </strong>使用提供的数据来准备和训练一个样本深度学习模型。</p>

<p class="list-inset">这就是为什么我们使用已经预装了<em class="italic"> PyTorch 1.8.1 </em>和<em class="italic"> Python 3.6 </em>的深度学习容器映像的原因。</p>

<p class="callout-heading">注意</p>

<p class="callout">完成此步骤可能需要5到10分钟。在等待的时候，请随意喝杯咖啡或茶！</p>

<ol>

<li value="7">在训练脚本完成运行后，让我们使用<code>tree</code>命令:<pre class="source-code"><strong class="bold">tree</strong></pre>检查<code>model</code>目录是否包含一个<code>model.pth</code>文件</li>

</ol>

<p class="list-inset">这应该<a id="_idIndexMarker264"/>产生一个树状<a id="_idIndexMarker265"/>结构，如下所示:</p>

<div><div><img alt="Figure 3.10 – Verifying whether the model was saved successfully&#10;&#10;" height="399" src="img/B18638_03_010.jpg" width="1579"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.10–验证模型是否保存成功</p>

<p class="list-inset">这个<code>model.pth</code>文件包含我们使用<code>train.py</code>脚本训练的序列化模型。该文件是在模型训练步骤完成后使用<code>torch.save()</code>方法创建的。请随意查看<a href="https://pytorch.org/tutorials/beginner/saving_loading_models.xhtml">https://py torch . org/tutorials/beginner/saving _ loading _ models . XHTML</a>了解更多信息。</p>

<p class="callout-heading">注意</p>

<p class="callout">生成的<code>model.pth</code>文件允许我们使用模型的参数进行预测(从文件中加载模型之后)。例如，如果我们的模型使用诸如<em class="italic"> ax^2 + bxy + cy^2 = 0 </em>的等式，则<em class="italic"> a </em>、<em class="italic"> b </em>和<em class="italic"> c </em>值就是模型参数。有了这个，如果我们有了<em class="italic"> x </em>(也就是自变量)，就可以很容易的计算出<em class="italic"> y </em>的值。也就是说，我们可以说确定<em class="italic"> a </em>、<em class="italic"> b </em>和<em class="italic"> c </em>是训练阶段的任务，而确定给定<em class="italic"> x </em>(以及给定<em class="italic"> a </em>、<em class="italic"> b </em>和<em class="italic"> c </em>)的<em class="italic"> y </em>是推理阶段的任务。通过加载<code>model.pth</code>文件，我们可以继续进行推理阶段，并在给定输入值<em class="italic"> x </em>的情况下计算<em class="italic"> y </em>的预测值。</p>

<p>那不是很容易吗？完成<a id="_idIndexMarker266"/>培训步骤<a id="_idIndexMarker267"/>后，我们将继续下一部分的部署步骤。</p>

<h1 id="_idParaDest-66"><a id="_idTextAnchor069"/>支持Lambda容器映像的无服务器ML部署</h1>

<p>现在我们有了<code>model.pth</code>文件，我们该怎么处理它？答案很简单:我们将使用一个<strong class="bold"> AWS Lambda </strong>函数<a id="_idIndexMarker269"/>和一个<strong class="bold">Amazon API Gateway</strong>HTTP API在一个无服务器API中部署这个模型，如下图中的<a id="_idIndexMarker270"/>所示:</p>

<div><div><img alt="Figure 3.11 – Serverless ML deployment with an API Gateway and AWS Lambda&#10;&#10;" height="263" src="img/B18638_03_011.jpg" width="1233"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.11–带有API网关和AWS Lambda的无服务器ML部署</p>

<p>正如我们所看到的，HTTP API应该能够接受来自“客户端”的<em class="italic"> GET </em>请求，比如移动应用和其他与最终用户交互的web服务器。这些请求然后作为输入事件数据传递给AWS Lambda函数。然后，Lambda函数从<code>model.pth</code>文件中加载模型，并使用输入事件数据中的<em class="italic"> x </em>值计算预测的<em class="italic"> y </em>值。</p>

<h2 id="_idParaDest-67"><a id="_idTextAnchor070"/>构建自定义容器图像</h2>

<p>我们的<a id="_idIndexMarker271"/> AWS Lambda函数代码需要利用<strong class="bold"> PyTorch </strong>函数和实用程序来加载模型。为了让这个设置正常工作，我们将从现有的DLC映像构建一个定制的容器映像，该映像针对<strong class="bold"> PyTorch </strong>推理需求进行了优化。这个自定义容器映像将用于我们的AWS Lambda函数代码将通过AWS Lambda的容器映像支持运行的环境。</p>

<p class="callout-heading">注意</p>

<p class="callout">有关AWS Lambda的容器图像支持的更多信息，请查看https://AWS . Amazon . com/blogs/AWS/new-for-AWS-Lambda-container-image-support/。</p>

<p>值得注意的是，有多种DLC图像可供我们选择。这些图像根据它们的作业类型(<em class="italic">训练与推理</em>)、安装的框架(<em class="italic"> PyTorch与TensorFlow与MXNet与其他选项</em>)以及安装的Python版本(<em class="italic"> 3.8与3.7与3.6与其他选项</em>)进行分类。由于我们计划使用一个容器来加载<strong class="bold"> PyTorch </strong>模型并用于执行预测，因此在构建自定义Docker映像时，我们将选择一个为推理而优化的<strong class="bold"> PyTorch </strong> DLC <em class="italic">作为基础映像。</em></p>

<p>以下步骤着重于从现有DLC映像构建自定义容器映像:</p>

<ol>

<li value="1">通过在终端中运行<code>pwd</code>命令，确保您位于<code>ch03</code>目录中。</li>

<li>接下来，运行以下命令来下载<code>dlclambda.zip</code>并在<code>ch03</code>目录中提取其内容:<pre class="source-code">wget https://bit.ly/3pt5mGN -O<strong class="bold"> dlclambda.zip</strong></pre> <pre class="source-code">unzip <strong class="bold">dlclambda.zip</strong></pre></li>

</ol>

<p class="list-inset">这个ZIP文件包含构建定制容器映像所需的文件和脚本。</p>

<ol>

<li value="3">使用<code>tree</code>命令查看<code>ch03</code>目录的样子:<pre class="source-code"><strong class="bold">tree</strong></pre></li>

</ol>

<p class="list-inset">这将产生一个树状结构，如下所示:</p>

<div><div><img alt="Figure 3.12 – Results after running the tree command&#10;&#10;" height="708" src="img/B18638_03_012.jpg" width="1650"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.12–运行tree命令后的结果</p>

<p class="list-inset">这里，从<code>dlclambda.zip</code>文件中提取了几个<a id="_idIndexMarker273"/>新文件:</p>

<ul>

<li><code>Dockerfile</code></li>

<li><code>app/app.py </code></li>

<li><code>build.sh</code></li>

<li><code>download-rie.sh </code></li>

<li><code>invoke.sh </code></li>

<li><code>run.sh </code></li>

</ul>

<p class="list-inset">我们将在本章的步骤中详细讨论每个文件。</p>

<ol>

<li value="4">在文件树中，找到并打开位于<code>ch03/app</code>目录下的<code>app.py</code>文件:</li>

</ol>

<div><div><img alt="Figure 3.13 – app.py Lambda handler implementation&#10;&#10;" height="362" src="img/B18638_03_013.jpg" width="731"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.13–app . py Lambda处理程序实现</p>

<p class="list-inset">该文件<a id="_idIndexMarker274"/>包含AWS Lambda处理程序实现代码，它(1)加载模型，(2)从事件数据中提取输入的<em class="italic"> x </em>值，(3)使用模型计算预测的<em class="italic"> y </em>值，以及(4)以字符串形式返回输出的<em class="italic"> y </em>值。</p>

<p class="list-inset">在本章末尾的<em class="italic">完成和测试无服务器API设置</em>部分，我们将设置一个HTTP API，通过URL查询字符串(例如，<code>https://&lt;URL&gt;/predict?x=42</code>)接受<code>x</code>的值。一旦请求进来，Lambda将调用一个包含代码的处理函数来处理进来的请求。它将加载深度学习模型，并使用它来预测使用<em class="italic"> x </em>的值的<code>y</code>的值。</p>

<p class="callout-heading">注意</p>

<p class="callout">在这里可以找到完整的<code>app/app.py</code>文件:<a href="https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/app/app.p">https://github . com/packt publishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter 03/app/app . py</a>。</p>

<ol>

<li value="5">使用<code>cp</code>命令:<pre class="source-code"><strong class="bold">cp model/model.pth app/model/model.pth</strong></pre>将<code>model.pth</code>文件从<code>model</code>目录复制到<code>app/model</code>目录</li>

</ol>

<p class="callout-heading">重要说明</p>

<p class="callout">确保您只从可信来源加载ML模型。在<code>app/app.py</code>内部，我们使用<code>torch.load()</code>加载模型，攻击者可以利用包含恶意有效负载的模型来利用该模型。攻击者可以很容易地准备一个模型(带有恶意的有效负载)，当加载该模型时，攻击者可以访问运行ML脚本的服务器或资源(例如，通过<strong class="bold">反向外壳</strong>)。关于这个主题的更多信息，你可以查看作者关于如何黑客攻击和保护ML环境和系统的演讲:<a href="https://speakerdeck.com/arvslat/pycon-apac-2022-hacking-and-securing-machine-learning-environments-and-systems?slide=8">https://speaker deck . com/ARV slat/pycon-APAC-2022-hacking-and-securing-machine-learning-environments-and-systems？slide=8 </a>。</p>

<ol>

<li value="6">接下来，让<a id="_idIndexMarker275"/>使用<code>chmod</code>命令:<pre class="source-code"><strong class="bold">chmod +x *.sh</strong></pre>使<code>build.sh</code>、<code>download-rie.sh</code>、<code>invoke.sh</code>和<code>run.sh</code>脚本文件可执行</li>

<li>在运行<code>build.sh</code>命令之前，让我们使用<code>cat</code>命令:<pre class="source-code">cat <strong class="bold">build.sh</strong></pre>来检查脚本的内容</li>

</ol>

<p class="list-inset">这将产生一行代码，类似于下面的代码块:</p>

<pre class="list-inset1 source-code"><strong class="bold">docker build</strong> -t dlclambda .</pre>

<p class="list-inset"><code>docker build</code>命令使用当前目录下Docker文件中指定的指令构建Docker容器映像。<em class="italic">这是什么意思？</em>这意味着我们正在使用目录中的相关文件构建一个容器映像，并且我们也在使用Dockerfile文件中的指令来安装必要的包。这个过程类似于准备容器的<em class="italic"> DNA </em>，它可以用来创建新的容器，其环境配置有所需的工具和软件包。</p>

<p class="list-inset">因为我们将<code>dlclambda</code>作为参数传递给了<code>-t</code>标志，所以在构建过程完成后，我们的定制容器图像将拥有<code>dlclambda:latest</code>名称和标签。注意，我们可以用一个特定的版本号(例如，<code>dlclambda:3</code>)替换最新的标签，但是现在我们将坚持使用<code>latest</code>标签。</p>

<p class="callout-heading">注意</p>

<p class="callout">有关<a id="_idIndexMarker276"/>和<code>docker build</code>命令的更多信息，请查看https://docs . docker . com/engine/reference/command line/build/。</p>

<ol>

<li value="8">我们还必须检查Dockerfile文件的内容。当我们使用这个Dockerfile文件构建容器映像时会发生什么？<ol><li>以下DLC图像用作构建两个阶段的基础图像:<code>https://763104351884.dkr.ecr.us-west-2.amazonaws.com/pytorch-inference:1.8.1-cpu-py36-ubuntu18.04</code>。值得注意的是，这个Dockerfile利用了<strong class="bold">多阶段构建</strong>到<a id="_idIndexMarker278"/>来确保最终的容器不包含来自先前构建阶段的未使用的工件和文件。</li>

<li>接下来，安装<strong class="bold"> Lambda运行时接口客户端</strong>。这允许任何定制容器映像与AWS Lambda兼容使用。</li>

<li>创建了<code>/function</code>目录。然后将<code>app/</code>目录(在Cloud9环境的<code>ch03</code>目录中)的内容复制到容器中的<code>/function</code>目录。</li>

<li><code>ENTRYPOINT</code>设置为<code>/opt/conda/bin/python -m awslambdaric</code>。<code>CMD</code>然后被设置为<code>app.handler</code>。<code>ENTRYPOINT</code>和<code>CMD</code>指令<a id="_idIndexMarker279"/>定义当容器开始运行时执行哪个命令。</li>

</ol></li>

</ol>

<p class="callout-heading">注意</p>

<p class="callout">单个Dockerfile文件中的一个<code>FROM</code>指令。这些<code>FROM</code>指令中的每一个都对应于一个新的构建阶段，在该阶段可以复制来自先前阶段的工件和文件。对于多阶段构建，最后一个构建阶段会生成最终映像(理想情况下，它不包括前面构建阶段中未使用的文件)。</p>

<p class="list-inset">预期的最终输出将是一个可用于启动容器的容器图像，如下所示:</p>

<div><div><img alt="Figure 3.14 – Lambda Runtime Interface Client&#10;&#10;" height="529" src="img/B18638_03_014.jpg" width="1266"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.14–Lambda运行时接口客户端</p>

<p class="list-inset">如果这个<a id="_idIndexMarker281"/>容器在没有任何附加参数的情况下启动，将执行以下命令:</p>

<pre class="list-inset1 source-code">/opt/conda/bin/python -m <strong class="bold">awslambdaric</strong> <strong class="bold">app.handler</strong></pre>

<p class="list-inset">这将运行我们的<code>app.py</code>文件的<code>handler()</code>函数来处理AWS Lambda事件。这个<code>handler()</code>函数然后将使用我们在<em class="italic">中使用AWS深度学习容器训练的深度学习模型来训练ML模型</em>部分以进行预测。</p>

<p class="callout-heading">注意</p>

<p class="callout">你可以在这里找到docker file:<a href="https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/Dockerfile">https://github . com/packt publishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter 03/docker file</a>。</p>

<p class="list-inset">在运行<code>build.sh</code>脚本之前，确保用适当的地区代码替换docker文件中的所有<code>us-west-2</code>实例。</p>

<ol>

<li value="9">现在，让我们运行<code>build.sh</code>脚本:<pre class="source-code"><strong class="bold">./build.sh</strong></pre></li>

<li>最后，我们需要使用<code>docker images</code>命令:<pre class="source-code"><strong class="bold">docker images | grep dlclambda</strong></pre>检查定制容器映像的大小是否超过10 GB</li>

</ol>

<p class="list-inset">我们应该看到<code>dlclambda</code>的容器图像尺寸是<code>4.61GB</code>。重要的是<a id="_idIndexMarker282"/>要注意，对Lambda函数使用容器映像时有10 GB的限制。如果我们希望在AWS Lambda中使用自定义容器图像，那么它的图像大小需要低于10 GB。</p>

<p>至此，我们的定制容器映像已经准备好了。下一步是在使用容器映像创建AWS Lambda函数之前在本地测试它。</p>

<h2 id="_idParaDest-68"><a id="_idTextAnchor071"/>测试容器图像</h2>

<p>我们可以使用<strong class="bold"> Lambda运行时接口仿真器</strong>在本地测试<a id="_idIndexMarker283"/>容器映像。这个<a id="_idIndexMarker284"/>将帮助我们检查我们的容器映像在稍后部署到AWS Lambda时是否能正常运行。</p>

<p>在接下来的几个步骤中，我们将下载并使用Lambda运行时接口仿真器来检查我们的容器映像:</p>

<ol>

<li value="1">使用<code>cat</code>命令检查<code>download-rie.sh</code> : <pre class="source-code">cat <strong class="bold">download-rie.sh</strong></pre>的内容</li>

</ol>

<p class="list-inset">这将在终端中输出以下代码块:</p>

<pre class="list-inset1 source-code">mkdir -p ~/.aws-lambda-rie &amp;&amp; curl -Lo ~/.aws-lambda-rie/aws-lambda-rie \

https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie \

&amp;&amp; chmod +x ~/.aws-lambda-rie/aws-lambda-rie</pre>

<p class="list-inset"><code>download-rie.sh</code>脚本简单地下载Lambda运行时接口仿真器二进制文件，并使用<code>chmod</code>命令使其可执行。</p>

<ol>

<li value="2">接下来，运行<code>download-rie.sh</code>脚本:<pre class="source-code">sudo <strong class="bold">./download-rie.sh</strong></pre></li>

<li>使用<code>cat</code>命令<a id="_idIndexMarker285"/>检查<code>run.sh</code> : <pre class="source-code">cat <strong class="bold">run.sh</strong></pre>的内容</li>

</ol>

<p class="list-inset">我们应该看到一个带有几个参数值的<code>docker run</code>命令，类似于下面的代码块:</p>

<pre class="list-inset1 source-code"><strong class="bold">docker run</strong> -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 <strong class="bold">--entrypoint /aws-lambda/aws-lambda-rie</strong> dlclambda:latest /opt/conda/bin/python -m awslambdaric app.handler</pre>

<p class="list-inset">让我们快速检查一下传递给每个标志的参数值:</p>

<ul>

<li><code>-v</code> : <code>~/.aws-lambda-rie</code>是运行Docker容器外部的一个目录，将被挂载到<code>/aws-lambda</code>(在容器内部)。</li>

<li><code>-p</code>:这将容器的端口<code>8080</code>绑定到实例的端口<code>9000</code>。</li>

<li><code>--entrypoint</code>:这将覆盖容器启动时执行的默认<code>ENTRYPOINT</code>命令。</li>

<li><code>[IMAGE]</code> : <code>dlclambda:latest.</code></li>

<li><code>[COMMAND]</code> <code>[ARG…]</code> : <code>/opt/conda/bin/python -m awslambdaric app.handler.</code></li>

</ul>

<p class="list-inset">该<code>docker run</code>命令覆盖默认的<code>ENTRYPOINT</code>命令，并使用<a id="_idIndexMarker286"/>T2，而不是使用<code>--entrypoint</code>标志。这将在<code>http://localhost:9000/2015-03-31/functions/function/invocations</code>启动一个本地端点。</p>

<p class="callout-heading">注意</p>

<p class="callout">关于<a id="_idIndexMarker287"/>命令<code>docker run</code>的更多信息，请随时查看<a href="https://docs.docker.com/engine/reference/commandline/run/">https://docs.docker.com/engine/reference/commandline/run/</a>。</p>

<ol>

<li value="4">现在，让<a id="_idIndexMarker288"/>调用<code>run.sh</code>脚本:<pre class="source-code"><strong class="bold">./run.sh</strong></pre></li>

<li>通过单击加号(<strong class="bold"> + </strong>)按钮创建一个新的终端选项卡，如下面的屏幕截图所示:</li>

</ol>

<div><div><img alt="Figure 3.15 – Creating a new Terminal tab&#10;&#10;" height="358" src="img/B18638_03_015.jpg" width="770"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.15–创建新的终端标签</p>

<p class="list-inset">请注意，当我们打开一个<strong class="bold">新终端</strong>标签时，<code>run.sh</code>脚本应该保持运行。</p>

<ol>

<li value="6">在<code>invoke.sh</code>脚本中:<pre class="source-code"><strong class="bold">cd ch03</strong></pre> <pre class="source-code"><strong class="bold">cat invoke.sh</strong></pre></li>

</ol>

<p class="list-inset">这应该向我们展示了<code>invoke.sh</code>脚本文件中的内容。它应该包含一个单行脚本，类似于下面的代码块:</p>

<pre class="list-inset1 source-code">curl -X<strong class="bold">POST</strong> "<strong class="bold">http://localhost:9000/2015-03-31/functions/function/invocations</strong>" -d '{"queryStringParameters":{"x":<strong class="bold">42</strong>}}'</pre>

<p class="list-inset">这个脚本简单地利用<code>curl</code>命令向本地端点发送一个包含<code>x</code>输入值的示例<code>POST</code>请求，这个请求之前由<code>run.sh</code>脚本启动。</p>

<ol>

<li value="7">现在，让我们运行<code>invoke.sh</code>脚本:<pre class="source-code"><strong class="bold">./invoke.sh</strong></pre></li>

</ol>

<p class="list-inset">这将产生一个接近<code>"42.4586"</code>的值。在<code>invoke.sh</code>脚本中随意更改输入<code>x</code>值，看看输出值是如何变化的。</p>

<ol>

<li value="8">导航回<a id="_idIndexMarker289"/>到第一个选项卡，按下<em class="italic"> Ctrl </em> + <em class="italic"> C </em>停止运行<code>run.sh</code>脚本。</li>

</ol>

<p>假设我们能够使用<strong class="bold"> Lambda运行时接口仿真器</strong>成功调用定制容器映像中的<code>app.py</code> Lambda函数处理程序，我们现在可以继续将容器映像推送到Amazon ECR，并使用它来创建AWS Lambda函数。</p>

<h2 id="_idParaDest-69"><a id="_idTextAnchor072"/>将容器图像推送到Amazon ECR</h2>

<p><strong class="bold">亚马逊弹性容器注册</strong> ( <strong class="bold"> ECR </strong>)是一个<a id="_idIndexMarker290"/>容器注册服务，允许我们存储<a id="_idIndexMarker291"/>和管理Docker容器图像。在本节中，我们将创建一个ECR存储库，然后将我们的定制容器映像推送到这个ECR存储库中。</p>

<p>让我们从创建ECR存储库开始:</p>

<ol>

<li value="1">在Cloud9环境的<a id="_idIndexMarker292"/>右上角，定位并点击<strong class="bold">分享</strong>按钮旁边的圆圈，如下图所示。从选项列表中选择<strong class="bold">转到仪表板</strong>:</li>

</ol>

<div><div><img alt="Figure 3.16 – Navigating to the Cloud9 console&#10;&#10;" height="463" src="img/B18638_03_016.jpg" width="1602"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.16–导航至Cloud9控制台</p>

<p class="list-inset">这应该会打开Cloud9控制台，在这里我们可以找到所有创建的Cloud9环境。</p>

<ol>

<li value="2">在搜索栏中输入<code>registry</code>。从结果列表中选择<strong class="bold">弹性容器注册表</strong>。</li>

<li>找到并点击ECR控制台页面右上角的<strong class="bold">创建存储库</strong>按钮。</li>

<li>在<code>dlclambda</code>上):</li>

</ol>

<div><div><img alt="Figure 3.17 – Creating an ECR repository&#10;&#10;" height="629" src="img/B18638_03_017.jpg" width="869"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.17–创建ECR存储库</p>

<p class="list-inset">可选地，您<a id="_idIndexMarker293"/>可以启用<strong class="bold">标签不变性</strong>，类似于前面的截图所示。这将有助于确保我们不会意外覆盖现有的容器图像标签。</p>

<ol>

<li value="5">向下滚动到页面底部，然后单击<strong class="bold">创建存储库</strong>。</li>

<li>我们应该会看到一个成功通知，以及<strong class="bold"> View push commands </strong>按钮，类似于下面的截图:</li>

</ol>

<div><div><img alt="Figure 3.18 – View push commands&#10;&#10;" height="173" src="img/B18638_03_018.jpg" width="1079"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.18–查看推送命令</p>

<p class="list-inset">点击<strong class="bold">查看推送命令</strong>按钮，打开&lt; ECR库名称&gt;的<strong class="bold">推送命令弹出窗口。</strong></p>

<ol>

<li value="7">在<em class="italic">步骤1 </em>下的灰色框中找到<code>bash</code>命令。通过单击下面屏幕截图中突出显示的框按钮，将命令复制到剪贴板:</li>

</ol>

<div><div><img alt="Figure 3.19 – Push commands&#10;&#10;" height="742" src="img/B18638_03_019.jpg" width="836"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.19–推送命令</p>

<p class="list-inset">这个<a id="_idIndexMarker294"/>命令将用于在我们的Cloud9环境中向Amazon ECR认证Docker客户机。这将允许我们将容器图像推送到Amazon ECR。</p>

<ol>

<li value="8">导航<a id="_idIndexMarker295"/>回到<code>bash</code>命令:</li>

</ol>

<div><div><img alt="Figure 3.20 – Running the client authentication command&#10;&#10;" height="322" src="img/B18638_03_020.jpg" width="904"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.20–运行客户端验证命令</p>

<p class="list-inset">我们应该会得到一条<strong class="bold">登录成功</strong>的消息。如果没有这一步，我们将无法从Amazon ECR推送和提取容器图像。</p>

<ol>

<li value="9">导航回带有ECR push命令的浏览器选项卡，并复制<em class="italic">步骤3 </em>下的命令，如下图所示:<em class="italic"> </em></li>

</ol>

<div><div><img alt="Figure 3.21 – Copying the docker tag command&#10;&#10;" height="745" src="img/B18638_03_021.jpg" width="1235"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.21–复制docker标签命令</p>

<p class="list-inset">这一次，我们<a id="_idIndexMarker296"/>将从<code>docker tag</code>命令复制<code>docker tag</code>命令，该命令用于创建命名引用并将其映射到Docker图像。</p>

<p class="callout-heading">注意</p>

<p class="callout"><code>docker tag</code>命令用于指定元数据(如名称和版本)并将其添加到容器映像中。容器映像存储库存储特定映像的不同版本，当使用<code>docker push</code>命令时，<code>docker tag</code>命令帮助存储库识别哪个版本的映像将被更新(或上传)。如需更多信息，请随时查看https://docs.docker.com/engine/reference/commandline/tag/.</p>

<ol>

<li value="10">回到包含Cloud9环境的<a id="_idIndexMarker298"/>浏览器选项卡，将复制的<code>docker tag</code>命令粘贴到终端窗口中。找到命令末尾的<code>latest</code>标记值，并替换为<code>1</code>:<pre class="source-code">docker tag dlclambda:latest <strong class="bold">&lt;ACCOUNT ID&gt;</strong>.dkr.ecr.us-west-2.amazonaws.com/dlclambda:<strong class="bold">latest</strong></pre></li>

</ol>

<p class="list-inset">在用<code>1</code>替换了<code>latest</code>标签后，该命令应该类似于下面的代码块:</p>

<pre class="list-inset1 source-code">docker tag dlclambda:latest <strong class="bold">&lt;ACCOUNT ID&gt;</strong>.dkr.ecr.us-west-2.amazonaws.com/dlclambda:<strong class="bold">1</strong></pre>

<p class="list-inset">确保<code>&lt;ACCOUNT ID&gt;</code>值被正确设置为您正在使用的AWS帐户的帐户ID。您从<code>&lt;ACCOUNT ID&gt;</code>值中复制的<code>docker tag</code>命令设置正确。</p>

<ol>

<li value="11">使用<code>docker images</code>命令快速检查我们的Cloud9环境中的容器映像:<pre class="source-code"><strong class="bold">docker images</strong></pre></li>

</ol>

<p class="list-inset">这将返回所有容器图像，包括<code>dlclambda</code>容器图像，如下面的屏幕截图所示:</p>

<div><div><img alt="Figure 3.22 – Running the docker images command&#10;&#10;" height="66" src="img/B18638_03_022.jpg" width="988"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.22–运行docker images命令</p>

<p class="list-inset">值得注意的是，前面屏幕截图中显示的两个容器图像标签具有相同的图像ID。这意味着它们指向同一个图像，即使它们有不同的名称和标签。</p>

<ol>

<li value="12">使用<code>docker push</code>命令:<pre class="source-code"><strong class="bold">docker push &lt;ACCOUNT ID&gt;.dkr.ecr.us-west-2.amazonaws.com/dlclambda:1</strong></pre>将<a id="_idIndexMarker299"/>容器映像推送到Amazon ECR存储库</li>

</ol>

<p class="list-inset">确保用您正在使用的AWS帐户的帐户ID替换<code>&lt;ACCOUNT ID&gt;</code>的值。在上一步运行<code>docker images</code>命令后，通过检查<code>.dkr.ecr.us-west-2.amazonaws.com/dlclambda</code>前的数值，可以得到<code>&lt;ACCOUNT ID&gt;</code>的值。</p>

<p class="callout-heading">注意</p>

<p class="callout">注意，图像标签值是一个<code>1</code>(一)，而不是容器图像名称和冒号后的字母<em class="italic"> l </em>。</p>

<ol>

<li value="13">导航回包含ECR按钮命令的浏览器选项卡，点击<strong class="bold">关闭</strong>按钮。</li>

<li>在<strong class="bold">私有库</strong>列表下找到并点击我们创建的ECR库的名称(即<code>dlclambda</code>):</li>

</ol>

<div><div><img alt="Figure 3.23 – Private repositories&#10;&#10;" height="278" src="img/B18638_03_023.jpg" width="1074"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.23–私有存储库</p>

<p class="list-inset">这应该会将我们重定向到详细信息页面，在这里我们可以看到不同的图像标签，如下面的屏幕截图所示:</p>

<div><div><img alt="Figure 3.24 – Repository details page&#10;&#10;" height="272" src="img/B18638_03_024.jpg" width="1124"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.24–存储库详细信息页面</p>

<p class="list-inset">一旦我们的带有指定图像标签的<a id="_idIndexMarker300"/>容器图像反映在相应的Amazon ECR存储库详细信息页面中，我们就可以使用它来创建AWS Lambda函数，使用Lambda的容器图像支持。</p>

<p>既然我们的定制容器映像已经被推送到<strong class="bold"> Amazon ECR </strong>，我们就可以准备和配置无服务器API设置了！</p>

<h2 id="_idParaDest-70"><a id="_idTextAnchor073"/>在自动气象站Lambda上运行最大似然预测</h2>

<p><strong class="bold"> AWS Lambda </strong>是一种<a id="_idIndexMarker301"/>无服务器<a id="_idIndexMarker302"/>计算服务，允许开发人员和工程师运行事件驱动的代码，而无需供应或管理基础设施。Lambda函数可以被来自其他AWS服务的资源调用，例如<a id="_idIndexMarker303"/>作为<strong class="bold"> API网关</strong>(一个用于配置和管理API的完全托管的服务)<strong class="bold">亚马逊S3 </strong>(一个<a id="_idIndexMarker304"/>对象存储服务，我们可以在那里上传和下载文件)<strong class="bold">亚马逊SQS </strong>(一个完全托管的消息队列服务)，等等。这些<a id="_idIndexMarker305"/>函数在隔离的运行时环境中执行，这些运行时环境有定义的最大执行时间和最大内存限制，类似于下图所示:</p>

<div><div><img alt="Figure 3.25 – AWS Lambda isolated runtime environment&#10;&#10;" height="442" src="img/B18638_03_025.jpg" width="1053"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.25–AWS Lambda隔离运行时环境</p>

<p>有两种方法部署Lambda函数代码及其依赖项:</p>

<ul>

<li>使用容器映像作为部署包。</li>

<li>使用一个<code>.zip</code>文件作为部署包</li>

</ul>

<p>当使用容器映像作为部署包时，自定义Lambda函数代码可以使用容器映像中安装和配置的内容。也就是说，如果我们要使用从AWS DLC构建的自定义容器映像，我们将能够在我们的函数代码中使用安装的ML框架(即<strong class="bold"> PyTorch </strong>),并在AWS Lambda执行环境中运行ML预测。</p>

<p>现在我们对AWS Lambda的容器图像支持有了更好的理解，让我们继续创建我们的AWS Lambda函数:</p>

<ol>

<li value="1">在搜索栏中输入<code>lambda</code>。从结果列表中选择<strong class="bold"> Lambda </strong>导航至AWS Lambda控制台。</li>

<li>找到并点击页面右上角的<strong class="bold">创建功能</strong>按钮。</li>

<li>【T2上】 ):</li>

</ol>

<div><div><img alt="Figure 3.26 – Using the container image support of AWS Lambda&#10;&#10;" height="887" src="img/B18638_03_026.jpg" width="1650"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.26–使用AWS Lambda的容器图像支持</p>

<p class="list-inset">选择<strong class="bold">容器映像</strong>选项意味着我们将使用定制的容器映像作为部署包。这个部署包应该包含Lambda代码及其依赖项。</p>

<ol>

<li value="4">在<strong class="bold">容器图像URI </strong>下，点击<strong class="bold">浏览图像</strong>按钮。这将打开一个<a id="_idIndexMarker307"/>弹出窗口，如下所示:</li>

</ol>

<div><div><img alt="Figure 3.27 – Selecting the container image&#10;&#10;" height="440" src="img/B18638_03_027.jpg" width="950"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.27–选择容器图像</p>

<p class="list-inset">在<code>dlclambda:1</code>下)。</p>

<ol>

<li value="5">单击<code>dlclambda</code>容器图像将用于我们Lambda函数的部署包。</li>

<li>在<a id="_idIndexMarker308"/>之后，点击<strong class="bold">创建功能</strong>。</li>

</ol>

<p class="callout-heading">注意</p>

<p class="callout">完成此步骤可能需要3到5分钟。在等待的时候，请随意喝杯咖啡或茶！</p>

<ol>

<li value="7">导航到<strong class="bold">配置&gt;通用配置</strong>选项卡，点击<strong class="bold">编辑</strong>:</li>

</ol>

<div><div><img alt="Figure 3.28 – Editing the general configuration&#10;&#10;" height="514" src="img/B18638_03_028.jpg" width="1650"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.28–编辑常规配置</p>

<p class="list-inset">在这里，我们可以看到AWS Lambda函数被配置为默认的最大内存限制为128 MB，超时为3秒。如果Lambda函数在执行过程中超过一个或多个配置的限制，则会引发错误。</p>

<ol>

<li value="8">接下来，更新<code>10240</code> MB，因为我们期待我们的<code>1</code> min和<code>0</code> seconds，因为推断步骤可能需要比默认值3秒更长的时间:</li>

</ol>

<div><div><img alt="Figure 3.29 – Modifying the memory and timeout settings&#10;&#10;" height="737" src="img/B18638_03_029.jpg" width="1650"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.29–修改内存和超时设置</p>

<p class="list-inset">注意<a id="_idIndexMarker309"/>增加内存和超时限制会影响Lambda函数的计算能力和总运行时间，以及使用服务运行预测的总成本。现在，让我们专注于使用<strong class="bold">内存</strong>和<strong class="bold">超时</strong>的这些当前配置值让<strong class="bold"> AWS Lambda </strong>功能工作。一旦我们可以运行初始设置，我们就可以使用不同的配置值组合来管理设置的性能和成本。</p>

<p class="callout-heading">注意</p>

<p class="callout">我们可以使用<strong class="bold"> AWS计算优化器</strong>来帮助<a id="_idIndexMarker310"/> us优化AWS Lambda函数的整体性能和成本。有关这个主题的更多信息，请查看<a href="https://aws.amazon.com/blogs/compute/optimizing-aws-lambda-cost-and-performance-using-aws-compute-optimizer/">https://AWS . Amazon . com/blogs/compute/optimizing-AWS-lambda-cost-and-performance-using-AWS-compute-optimizer/</a>。</p>

<ol>

<li value="9">之后点击<strong class="bold">保存</strong>按钮。我们应该看到一个类似于<strong class="bold">更新函数&lt;函数名&gt; </strong>的通知。</li>

<li>导航至<strong class="bold">测试</strong>选项卡。</li>

<li>在<code>test</code>下):</li>

</ol>

<div><div><img alt="Figure 3.30 – Configuring the test event&#10;&#10;" height="1001" src="img/B18638_03_030.jpg" width="1650"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.30–配置测试事件</p>

<p class="list-inset">确保<a id="_idIndexMarker311"/>您在代码编辑器中指定了以下测试事件值，类似于前面的屏幕截图所示:</p>

<pre class="list-inset1 source-code">{

  "queryStringParameters": {

    "x": 42

  }

}</pre>

<p class="list-inset">当执行测试时，这个测试事件值被传递给AWS Lambda <code>handler()</code>函数的<code>event</code>(第一个)参数。</p>

<ol>

<li value="12">点击<strong class="bold">保存</strong>。</li>

<li>现在，让我们通过点击<strong class="bold">测试</strong>按钮来测试我们的设置:</li>

</ol>

<div><div><img alt="Figure 3.31 – Successful execution result&#10;&#10;" height="858" src="img/B18638_03_031.jpg" width="1650"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.31–成功的执行结果</p>

<p class="list-inset">几秒钟后，我们应该看到执行结果成功，类似于我们在前面的截图中看到的。</p>

<ol>

<li value="14">在<code>x</code>到<code>41</code>然后马上点击<code>41.481697</code>。</li>

</ol>

<p class="callout-heading">重要说明</p>

<p class="callout">在AWS Lambda函数的第一次调用过程中，可能需要几秒钟的时间来下载函数代码并准备好执行环境。这种现象通常被称为<em class="italic">冷启动</em>。当第二次被调用时(例如，在同一分钟内)，<a id="_idIndexMarker313"/> Lambda功能立即运行，没有与冷启动相关的延迟。例如，Lambda函数完成第一次调用可能需要大约30到40秒。在此之后，所有后续的请求都需要一秒或更短的时间。Lambda函数完成其执行的速度明显更快，因为在第一次调用期间准备的执行环境被冻结，并在随后的调用中重用。如果AWS Lambda函数在一段时间后(例如，大约10到30分钟不活动)没有被调用，则执行环境被删除，并且需要在下次调用该函数时重新准备一个新的执行环境。有不同的方法来管理这一点，并确保AWS Lambda功能一致地执行，而不会受到冷启动的影响。其中一个策略是<a id="_idIndexMarker314"/>利用<strong class="bold">提供的并发性</strong>，这有助于确保可预测的函数启动时间。查看<a href="https://aws.amazon.com/blogs/compute/operating-lambda-performance-optimization-part-1/">https://AWS . Amazon . com/blogs/compute/operating-lambda-performance-optimization-part-1/</a>了解更多关于这个主题的信息。</p>

<p>我们的AWS Lambda函数已经准备好执行ML预测，我们可以继续创建触发Lambda函数的无服务器HTTP API。</p>

<h2 id="_idParaDest-71"><a id="_idTextAnchor074"/>完成并测试无服务器API设置</h2>

<p>我们创建的AWS <a id="_idIndexMarker315"/> Lambda函数需要由<a id="_idIndexMarker316"/>事件源触发。一个可能的事件源是被配置为接收HTTP请求的API网关HTTP API。收到请求后，HTTP API会将请求数据作为事件传递给AWS Lambda函数。Lambda函数一旦接收到事件，就会使用深度学习模型进行推理，然后将预测的输出值返回给HTTP API。之后，HTTP API将向请求资源返回HTTP响应。</p>

<p>创建API网关HTTP API有不同的方法。在接下来的几个步骤中，我们将直接从AWS Lambda控制台创建这个HTTP API:</p>

<ol>

<li value="1">找到<strong class="bold">功能概述</strong>窗格，点击<strong class="bold">添加触发器</strong>:</li>

</ol>

<div><div><img alt="Figure 3.32 – Add trigger&#10;&#10;" height="332" src="img/B18638_03_032.jpg" width="1045"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.32–添加触发器</p>

<p class="list-inset"><strong class="bold">添加触发器</strong>按钮应该在<strong class="bold">功能概述</strong>窗格的左侧，如前面的截图所示。</p>

<ol>

<li value="2">使用以下触发器配置添加一个<a id="_idIndexMarker317"/>新AWS <a id="_idIndexMarker318"/> Lambda触发器:</li>

</ol>

<div><div><img alt="Figure 3.33 – Trigger configuration&#10;&#10;" height="771" src="img/B18638_03_033.jpg" width="915"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.33–触发器配置</p>

<p class="list-inset">这是我们的触发器配置:</p>

<ul>

<li><strong class="bold">选择一个触发器</strong> : <strong class="bold"> API网关</strong></li>

<li><strong class="bold">创建新的API或使用现有的API</strong>:<strong class="bold">创建API </strong></li>

<li><strong class="bold"> API类型</strong> : <strong class="bold"> HTTP API </strong></li>

<li><strong class="bold">安全</strong> : <strong class="bold">开启</strong></li>

</ul>

<p class="list-inset">这将创建并配置一个HTTP API，该API接受请求并将请求数据作为事件发送给AWS Lambda函数。</p>

<p class="callout-heading">重要说明</p>

<p class="callout">请注意，一旦我们为生产使用配置了我们的设置，就需要保护这个配置。有关这个主题的更多信息，请查看<a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/security.xhtml">https://docs . AWS . Amazon . com/API gateway/latest/developer guide/security . XHTML</a>。</p>

<ol>

<li value="3">一旦<a id="_idIndexMarker319"/>您完成了新触发器的配置，点击<a id="_idIndexMarker320"/><strong class="bold">添加</strong>按钮。</li>

<li>在<strong class="bold">触发器</strong>窗格下找到我们刚刚创建的API网关触发器。点击<strong class="bold"> API网关</strong>链接(例如<strong class="bold"> dlclambda-API </strong>)，这将打开一个新的选项卡。在<strong class="bold">开发</strong>(在侧栏中)下，点击<strong class="bold">集成</strong>。在<strong class="bold"> dlclambda-API </strong>路径下，点击<strong class="bold">任意</strong>。点击<strong class="bold">管理集成</strong>，然后点击<strong class="bold">编辑</strong>(位于<strong class="bold">集成细节</strong>窗格)。在<strong class="bold">编辑集成</strong>页面，将<strong class="bold">有效载荷格式版本</strong>(在<strong class="bold">高级设置</strong>下)的值更新为<strong class="bold"> 2.0 </strong>，类似于<em class="italic">图3.34 </em>中的值。之后点击<strong class="bold">保存</strong>。</li>

</ol>

<div><div><img alt="Figure 3.34 – Updating the Payload format version&#10;&#10;" height="858" src="img/B18638_03_034.jpg" width="1650"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.34–更新有效载荷格式版本</p>

<p class="list-inset">在更新了URL中的<code>x</code>值之后，Lambda函数将在执行测试推断时使用<code>0</code>作为默认的<code>x</code>值。</p>

<p class="callout-heading">注意</p>

<p class="callout">如果在向API网关端点发送请求时没有指定<code>x</code>值，您可能希望触发一个异常。可以随意修改<code>app.py</code>的<em class="italic">行44</em>:<a href="https://github.com/PacktPublishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter03/app/app.py">https://github . com/packt publishing/Machine-Learning-Engineering-on-AWS/blob/main/chapter 03/app/app . py</a>来改变这种行为。</p>

<ol>

<li value="5">将<code>?x=42</code>追加到浏览器URL的末尾，类似于下面的URL字符串:<pre class="source-code">https://&lt;API ID&gt;.execute-api.us-west-2.amazonaws.com/default/dlclambda<strong class="bold">?x=42</strong></pre></li>

</ol>

<p class="list-inset">确保按下<code>42</code>作为输入<code>x</code>值:</p>

<div><div><img alt="Figure 3.35 – Testing the API endpoint&#10;&#10;" height="79" src="img/B18638_03_035.jpg" width="667"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.35–测试API端点</p>

<p class="list-inset">这应该会返回一个接近于<code>42.4586</code>的值，如前面的截图所示。随意测试<code>x</code>的不同值，看看预测的<em class="italic"> y </em>值如何变化。</p>

<p class="callout-heading">重要说明</p>

<p class="callout">确保在完成配置和测试API设置后，删除AWS Lambda和API网关资源。</p>

<p>在这一点上，我们<a id="_idIndexMarker321"/>应该为自己感到骄傲，因为我们能够使用<strong class="bold"> AWS Lambda </strong>和<strong class="bold"> Amazon API Gateway </strong>在无服务器API中成功<a id="_idIndexMarker322"/>部署我们的深度学习模型！在AWS Lambda的容器映像支持发布之前，使用我们在本章中使用的相同技术栈来设置和维护无服务器ML推理API是很棘手的。现在我们已经有了这个初始设置，准备和配置类似的无服务器ML驱动的API应该更容易了。注意，我们还可以选择创建一个Lambda函数URL来为Lambda函数生成一个惟一的URL端点。</p>

<div><div><img alt="Figure 3.36 – Cost of running the serverless API versus an API running inside an EC2 instance&#10;&#10;" height="480" src="img/B18638_03_036.jpg" width="1141"/>

</div>

</div>

<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图3.36-运行无服务器API与在EC2实例中运行API的成本比较</p>

<p>在我们<a id="_idIndexMarker323"/>结束本章之前，让我们快速检查一下<a id="_idIndexMarker324"/>如果我们使用<strong class="bold"> AWS Lambda </strong>和<strong class="bold"> API Gateway </strong>作为ML推理端点，成本会是什么样子。如上图所示，运行这个无服务器API的预期成本取决于通过它的流量。这意味着，如果没有流量通过API，成本将是最小的。一旦更多的流量通过这个HTTP API端点，成本也会逐渐增加。与右边的图表相比，无论是否有流量通过部署在EC2实例中的HTTP API，预期成本都是相同的。</p>

<p>为您的API选择架构和设置取决于多种因素。我们不会详细讨论这个话题，所以请随意查看这里提供的资源:<a href="https://aws.amazon.com/lambda/resources/">https://aws.amazon.com/lambda/resources/</a>。</p>

<h1 id="_idParaDest-72"><a id="_idTextAnchor075"/>总结</h1>

<p>在这一章中，我们能够更仔细地了解<strong class="bold"> AWS深度学习容器</strong> ( <strong class="bold"> DLCs </strong>)。与<strong class="bold"> AWS深度学习AMIs </strong> ( <strong class="bold"> DLAMIs </strong>)类似，AWS DLCs已经安装了相关的ML框架、库和包。这大大加快了构建和部署深度学习模型的过程。同时，容器环境保证是一致的，因为它们是从预先构建的容器映像运行的。</p>

<p>DLAMIs和DLC之间的一个关键区别是多个AWS DLCs可以在一个EC2实例中运行。这些容器也可以在其他支持容器的AWS服务中使用。这些服务包括<strong class="bold"> AWS Lambda </strong>、<strong class="bold">亚马逊ECS </strong>、<strong class="bold">亚马逊EKS </strong>和<strong class="bold">亚马逊EC2 </strong>等等。</p>

<p>在这一章中，我们能够使用DLC训练深度学习模型。然后，我们通过Lambda的容器映像支持将这个模型部署到AWS Lambda函数中。之后，我们测试了Lambda函数，看看它是否能够成功加载深度学习模型来执行预测。为了从HTTP端点触发这个Lambda函数，我们创建了一个API网关HTTP API。</p>

<p>在下一章中，我们将关注<strong class="bold">无服务器数据管理</strong>，并使用各种服务来建立和配置数据仓库和数据湖。我们将使用以下AWS服务、功能和特性:<strong class="bold">红移无服务器</strong>、<strong class="bold"> AWS湖形成</strong>、<strong class="bold"> AWS胶水</strong>和<strong class="bold">亚马逊雅典娜</strong>。</p>

<h1 id="_idParaDest-73"><a id="_idTextAnchor076"/>延伸阅读</h1>

<p>有关本章主题的更多信息，请随时查阅以下资源:</p>

<ul>

<li><em class="italic">什么是深度学习容器？</em>(<a href="https://docs.aws.amazon.com/deep-learning-containers/latest/devguide/what-is-dlc.xhtml">https://docs . AWS . Amazon . com/deep-learning-containers/latest/dev guide/what-is-DLC . XHTML</a>)</li>

<li><em class="italic">亚马逊API网关中的安全性</em>(https://docs . AWS . Amazon . com/API Gateway/latest/developer guide/Security . XHTML)</li>

<li><em class="italic">AWS Lambda-容器图像支持的新功能</em>(https://AWS . Amazon . com/blogs/AWS/New-for-AWS-Lambda-Container-Image-Support/)</li>

<li><em class="italic">使用AWS Lambda实现无服务器架构时要避免的问题</em>(<a href="https://aws.amazon.com/blogs/architecture/mistakes-to-avoid-when-implementing-serverless-architecture-with-lambda/">https://AWS . Amazon . com/blogs/Architecture/missons-to-Avoid-When-Implementing-server less-Architecture-with-Lambda/)</a></li>

</ul>

</div>

</div>



</body></html>