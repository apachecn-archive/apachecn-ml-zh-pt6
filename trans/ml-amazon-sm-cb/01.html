<html><head/><body>





<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style>
<div><div><h1 id="_idParaDest-21"><em class="italic"> <a id="_idTextAnchor020"/>第1章</em>:使用亚马逊SageMaker开始机器学习</h1>
			<p><strong class="bold">机器学习</strong> ( <strong class="bold"> ML </strong>)是<a id="_idIndexMarker000"/>当今世界最重要的话题之一。通过使用不同的算法和模型，它可以解决不同的实际问题和需求，如异常检测、预测、垃圾邮件检测、图像分类等。在您的本地机器上进行一些实验将有助于事情的开始。然而，一旦我们需要处理涉及更大数据集、深度学习需求和生产级模型部署的端到端实验，我们将需要一套更专用的解决方案来帮助我们有效地管理这些实验。</p>
			<p>这就是亚马逊SageMaker的目标。<strong class="bold"> Amazon SageMaker </strong>是一个<a id="_idIndexMarker001"/>完全托管的ML服务，它汇集了不同的解决方案来加速准备、构建、培训和部署ML模型的过程。当我们阅读本书的每一章时，我们将看到它是如何在ML过程的不同阶段帮助更快地完成工作的。</p>
			<div><div><img src="img/B16850_01_1.jpg" alt="Figure 1.1 – Chapter 1 recipes &#13;&#10;" width="1300" height="730"/>
				</div>
			</div>
			<p class="figure-caption">图1.1–第1章配方</p>
			<p>在这一介绍性章节中，我们将使用Amazon SageMaker执行一个简化的端到端ML实验。本章的目标是帮助我们熟悉并理解它能帮助我们快速训练和部署ML模型。如<em class="italic">图1.1 </em>所示，我们将看到<a id="_idIndexMarker002"/>Amazon sage maker如何适应ML流程。通过一个样本数据集，我们将致力于构建、分析和部署一个模型，该模型使用相关管理经验的月数来预测专业人员的工资。</p>
			<p>我们将从启动Amazon SageMaker笔记本实例开始，在这里我们将运行我们的实验。一旦<a id="_idIndexMarker003"/>一切就绪，我们将使用<strong class="bold"> pandas </strong>数据分析和操作库和<strong class="bold"> matplotlib </strong>数据可视化库来可视化数据。之后，当<a id="_idIndexMarker004"/>训练我们的线性回归模型时，我们将使用<strong class="bold"> SageMaker Python SDK </strong>。一旦我们生成了模型，我们将使用深度学习框架<strong class="bold"> Apache MXNet </strong>来加载所创建的模型文件并提取线性模型的参数。我们还将使用sklearn库中的度量工具来评估我们在本章中准备的回归模型。在我们执行了模型评估步骤之后，我们将使用<strong class="bold"> SageMaker Python SDK </strong>来将我们的模型部署到推理端点。最后，我们将使用boto3中的SageMakerRuntime客户端来调用我们部署的Amazon SageMaker推理端点。</p>
			<p>我们将在本章中介绍以下配方:</p>
			<ul>
				<li>发布一个<strong class="bold">亚马逊SageMaker笔记本实例</strong></li>
				<li>检查<strong class="bold"> SageMaker Python SDK </strong>和<strong class="bold"> AWS CLI </strong>的版本</li>
				<li>为线性回归实验准备<strong class="bold">亚马逊S3 </strong>桶和训练数据集</li>
				<li>在Python中可视化和理解数据</li>
				<li>用Python训练您的第一个模型</li>
				<li>用Python中的<strong class="bold"> Apache MXNet </strong>加载一个<strong class="bold">线性学习器</strong>模型</li>
				<li>在Python中评估模型</li>
				<li>在Python中部署您的第一个模型</li>
				<li>从boto3使用<strong class="bold"> SageMakerRuntime </strong>客户端调用<strong class="bold"> Amazon SageMaker </strong>模型端点</li>
			</ul>
			<p>一旦我们完成了本章的食谱，我们将会对如何在ML过程的不同阶段使用<strong class="bold"> Amazon SageMaker </strong>有一个很好的想法。记住这一点，让我们开始吧！</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>技术要求</h1>
			<p>只要你有一个现有的<strong class="bold"> AWS </strong>账户，接下来的步骤将是小菜一碟。如果您仍然没有AWS帐户，请随时查看<strong class="bold"> AWS自由层</strong>页面，并点击<strong class="bold">创建自由帐户</strong>:<a href="https://aws.amazon.com/free/">https://aws.amazon.com/free/</a>。点击<strong class="bold">创建免费账户</strong>按钮后，你将被重定向到<strong class="bold">注册AWS </strong>页面，如图<em class="italic">图1.2 </em>所示:</p>
			<div><div><img src="img/B16850_01_2.jpg" alt="Figure 1.2 – Sign up for AWS&#13;&#10;" width="774" height="682"/>
				</div>
			</div>
			<p class="figure-caption">图1.2–注册AWS</p>
			<p>您需要做的就是完成这里的步骤来完成注册过程。每个章节使用的Jupyter笔记本、源代码和CSV文件都可以在这个资源库中获得:<a href="https://github.com/PacktPublishing/Machine-Learning-with-Amazon-SageMaker-Cookbook/tree/master/Chapter01">https://github . com/packt publishing/Machine-Learning-with-Amazon-sage maker-Cookbook/tree/master/chapter 01</a>。</p>
			<p>请点击以下链接查看动作视频中的相关代码:</p>
			<p>https://bit.ly/38WpNDf<a href="https://bit.ly/38WpNDf"/></p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>发布亚马逊SageMaker笔记本实例</h1>
			<p>在<a id="_idIndexMarker006"/>这个菜谱中，我们将建立一个<strong class="bold"> Amazon SageMaker笔记本实例</strong>，在那里我们可以使用<strong class="bold"> Jupyter笔记本</strong>运行我们的ML实验。<strong class="bold"> SageMaker笔记本实例</strong>是一个完全托管的ML计算实例<a id="_idIndexMarker007"/>，运行一系列工具和应用，如<strong class="bold"> Jupyter笔记本应用</strong>。已经安装了几个工具和库并准备好使用，我们可以直接进入ML实验，而不必担心安装和维护工作。</p>
			<p class="callout-heading">重要说明</p>
			<p class="callout">请注意，我们也可以在亚马逊SageMaker Studio 中执行我们的ML实验。我们再来仔细看看<a id="_idIndexMarker008"/>亚马逊SageMaker工作室<strong class="bold">第六章<a href="B16850_06_Final_ASB_ePub.xhtml#_idTextAnchor435"> <em class="italic">中的</em></a></strong>第六章 ，<em class="italic">亚马逊SageMaker中的</em>自动机器学习。从我们的角度来看，知道如何使用这两者是至关重要的，因为将会有一些特性和功能，如<strong class="bold">本地模式</strong>，这在<strong class="bold">笔记本实例</strong>中受支持，但在<strong class="bold">亚马逊SageMaker Studio </strong>中不受支持。</p>
			<h2 id="_idParaDest-24">准备就绪</h2>
			<p>以下是这个配方的先决条件— (1)一个AWS帐户和(2)管理<strong class="bold">亚马逊SageMaker </strong>和<strong class="bold">亚马逊S3 </strong>资源的权限(如果使用带有自定义URL的<strong class="bold"> AWS IAM </strong>用户)。在大多数情况下，建议以AWS IAM用户身份登录，而不是使用root帐户。有关更多信息，请随意查看<a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html">https://docs . AWS . Amazon . com/IAM/latest/user guide/best-practices . html</a>。</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>怎么做……</h2>
			<p>在进行下一组步骤之前，确保屏幕右上角指定的AWS区域是您希望创建资源的区域。在这个菜谱中，我们将在<strong class="bold"> N. Virginia </strong> (us-east-1)地区创建我们的资源。您可以根据自己的需要随意更改:</p>
			<ol>
				<li>Click <strong class="bold">Services</strong> on the navigation bar. A list of services will be shown in the menu. Under <strong class="bold">Machine Learning</strong>, look for <strong class="bold">Amazon SageMaker</strong> and then click the <a id="_idIndexMarker009"/>link to navigate to the SageMaker console:<div><img src="img/B16850_01_3.jpg" alt="Figure 1.3 – Services menu&#13;&#10;" width="1645" height="916"/></div><p class="figure-caption">图1.3–服务菜单</p><p><em class="italic">图1.3 </em>向我们展示了撰写本文时菜单的样子。随着AWS不断改善用户体验并定期添加新服务，当您读到本文时，用户界面可能已经不同了！</p></li>
				<li>In the navigation pane, click <strong class="bold">notebook instances</strong> under <strong class="bold">Notebook</strong>. This should open a page that shows all running notebooks (if any):<div><img src="img/B16850_01_4.jpg" alt="Figure 1.4 – Amazon SageMaker dashboard&#13;&#10;" width="1648" height="767"/></div><p class="figure-caption">图1.4–亚马逊SageMaker仪表板</p><p>我们可以在<em class="italic">图1.4 </em>中<a id="_idIndexMarker010"/>看到<strong class="bold">亚马逊SageMaker仪表盘</strong>。导航窗格位于屏幕的左侧。在<strong class="bold">笔记本</strong>下，我们有<strong class="bold">笔记本实例</strong>、<strong class="bold">生命周期配置</strong>和<strong class="bold"> Git存储库</strong>。</p><p class="callout-heading">注意</p><p class="callout">我们将简要讨论<a id="_idIndexMarker011"/>生命周期配置脚本如何帮助我们自动化笔记本准备和配置步骤在<em class="italic">还有更多… </em>部分<em class="italic">为多个深度学习本地实验准备SageMaker笔记本实例</em>配方在<a href="B16850_03_Final_ASB_ePub.xhtml#_idTextAnchor114"> <em class="italic">第3章</em> </a>，<em class="italic">使用机器学习和深度学习框架与Amazon SageMaker </em>。</p></li>
				<li>On the <strong class="bold">notebook instances</strong> page, click the <strong class="bold">Create notebook instance</strong> button:<div><img src="img/B16850_01_5.jpg" alt="Figure 1.5 – Create notebook instance button&#13;&#10;" width="1345" height="255"/></div><p class="figure-caption">图1.5–创建笔记本实例按钮</p><p>在<em class="italic">图1.5 </em>中，我们应该可以看到图像右上方的<strong class="bold">创建笔记本实例</strong>按钮。</p></li>
				<li>Fill out the<a id="_idIndexMarker012"/> details in the <strong class="bold">Create notebook instance</strong> form. Specify the notebook instance name and choose <strong class="bold">notebook-al1-v1</strong> under<strong class="bold"> Platform identifier</strong>:<div><img src="img/B16850_01_6.jpg" alt="Figure 1.6 – Creating a notebook instance&#13;&#10;" width="1024" height="974"/></div><p class="figure-caption">图1.6–创建笔记本实例</p><p>在<em class="italic">图1.6 </em>中，我们有一个允许我们在创建笔记本实例之前管理笔记本实例设置的表单。</p><p class="callout-heading">注意</p><p class="callout">在<strong class="bold">弹性推理</strong> ( <strong class="bold"> EI </strong>)下，我们可以选择指定一个EI加速器类型(例如ml.eia2.medium)。EI加速器有助于减少推理端点执行预测所需的时间。将EI加速器附加到笔记本实例将允许我们在本地构建模型时测试和评估推理性能。因为我们现在不需要它，所以我们将把它设置为none。请注意，EI加速器也可以附加到SageMaker托管的端点上，以很小的成本提高推理性能。为什么这很重要？当然，推断端点执行预测的速度越快越好。关于这个话题的更多信息，请随时参考https://docs.aws.amazon.com/sagemaker/latest/dg/ei.html<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/ei.html"/>。</p></li>
				<li>Under <strong class="bold">IAM role</strong>, choose <strong class="bold">Create a new role</strong>:<div><img src="img/B16850_01_7.jpg" alt="Figure 1.7 – Create a new role&#13;&#10;" width="251" height="123"/></div><p class="figure-caption">图1.7–创建新角色</p><p>在<em class="italic">图1.7 </em>中，我们可以看到<strong class="bold"> IAM角色</strong>下不同的可能配置选项。什么是<strong class="bold"> IAM角色</strong>？IAM角色<a id="_idIndexMarker013"/>是一个IAM身份，用于委托对<a id="_idIndexMarker014"/>实体和资源的访问。该角色可由资源承担，以获得执行特定任务所需的权限。在我们的例子中，我们将为notebook实例创建一个角色来调用其他服务和访问特定的资源。</p></li>
				<li>Select <strong class="bold">Any S3 bucket</strong> under <strong class="bold">S3 buckets you specify</strong> and then click <strong class="bold">Create role</strong>:<div><img src="img/B16850_01_8.jpg" alt="Figure 1.8 – Create an IAM role&#13;&#10;" width="728" height="513"/></div><p class="figure-caption">图1.8–创建IAM角色</p><p>在<em class="italic">图1.8 </em>中，我们选择了<strong class="bold">任意S3桶</strong>选项。为了更安全的设置，我们可以选择<strong class="bold">特定的S3桶</strong>选项。对于这一章中的食谱，任何S3桶选项都可以。</p><p class="callout-heading">重要说明</p><p class="callout">请注意，我们为这个示例指定的安全配置应该仅用于开发目的。当处理生产级需求时，需要实现更安全的配置。在这种情况下，我们可以选择<strong class="bold">这种形式的具体S3桶</strong>。另一种选择是在IAM控制台中准备一个更严格的IAM角色，并在创建notebook实例时使用它。</p></li>
				<li>After<a id="_idIndexMarker015"/> successfully creating an IAM role, choose <strong class="bold">Enable</strong> for <strong class="bold">Root access</strong> and <strong class="bold">No Custom Encryption</strong> for <strong class="bold">Encryption key</strong>:<div><img src="img/B16850_01_9.jpg" alt="Figure 1.9 – Permissions and encryption&#13;&#10;" width="710" height="370"/></div><p class="figure-caption">图1.9–权限和加密</p><p>正如我们在<em class="italic">图1.9 </em>中看到的，我们允许笔记本实例的用户进行root访问。启用root访问意味着用户可以安装新软件，甚至修改实例中的系统关键文件。</p></li>
				<li>Choose <strong class="bold">No VPC</strong> under <strong class="bold">VPC - optional</strong>:<div><img src="img/B16850_01_10.jpg" alt="Figure 1.10 – Network configuration&#13;&#10;" width="672" height="163"/></div><p class="figure-caption">图1.10–网络配置</p><p>从<em class="italic">图1.10 </em>中可以看出，我们将网络配置设置为<strong class="bold">无VPC </strong>。鉴于我们只是使用合成和虚拟数据集进行一些测试实验，因此<strong class="bold">无VPC </strong>选项将会成功。我们可以选择一个VPC，并根据安全需要和要求指定是启用还是禁用直接互联网访问。在这个配方中，我们将使用<a id="_idIndexMarker016"/>中的<strong class="bold">没有VPC </strong>的配置。</p></li>
				<li>Choose <strong class="bold">Clone a public Git repository to this notebook instance only</strong> under <strong class="bold">Repository</strong> and set the field value under <strong class="bold">Git repository URL</strong> to <a href="https://github.com/PacktPublishing/Machine-Learning-with-Amazon-SageMaker-Cookbook">https://github.com/PacktPublishing/Machine-Learning-with-Amazon-SageMaker-Cookbook</a>:<div><img src="img/B16850_01_11.jpg" alt="Figure 1.11 – Cloning a public Git repository to the notebook instance&#13;&#10;" width="845" height="390"/></div><p class="figure-caption">图1.11–将公共Git存储库克隆到笔记本实例</p><p>在<em class="italic">图1.11 </em>中，我们选择了允许我们将公共Git存储库克隆到笔记本实例的选项。另一个选项是<strong class="bold">添加一个存储库到Amazon SageMaker </strong>选项，它允许我们关联需要凭证的私有Git存储库。我们也可以将一个没有凭证的公共Git存储库与帐户相关联。假设我们想要将这本书的笔记本菜谱克隆到笔记本实例，我们将选择<strong class="bold">仅将公共Git存储库克隆到这个笔记本实例</strong>选项。</p></li>
				<li>Optionally, you may specify tags. Specify Environment under <strong class="bold">Key</strong> and development under <strong class="bold">Value</strong>:<div><img src="img/B16850_01_12.jpg" alt="Figure 1.12 – Adding tags&#13;&#10;" width="585" height="169"/></div><p class="figure-caption">图1.12–添加标签</p><p>我们可以在<em class="italic">图1.12 </em>中看到，我们已经为将要创建的资源添加了一个可选标签。如果您使用AWS已经有一段时间了，您可能会意识到最好使用标记分配元数据来管理资源。这些标签对于成本分配和安全风险管理特别有用。如果你想了解更多这方面的内容，请查看以下链接:<a href="https://d1.awsstatic.com/whitepapers/aws-tagging-best-practices.pdf">https://D1 . AWS static . com/white papers/AWS-tagging-best-practices . pdf</a>。</p></li>
				<li>Click on the <strong class="bold">Create notebook instance</strong> button after the last section of the form to start the notebook creation process. You will be directed back to the <strong class="bold">Notebook instances</strong> page, as shown in the following screenshot: <div><img src="img/B16850_01_13.jpg" alt="Figure 1.13 – Notebook instance being created&#13;&#10;" width="1418" height="265"/></div><p class="figure-caption">图1.13–正在创建笔记本实例</p><p>在<em class="italic">图1.13 </em>中，我们可以看到，在完成表单后，笔记本实例将在几分钟内处于<strong class="bold">挂起</strong>状态，同时它正在被供应。</p></li>
				<li>一旦<a id="_idIndexMarker018"/>状态变为<strong class="bold">运行</strong>，点击<strong class="bold">打开Jupyter </strong>:</li>
			</ol>
			<div><div><img src="img/B16850_01_14.jpg" alt="Figure 1.14 – Notebook instance with the InService status&#13;&#10;" width="1434" height="259"/>
				</div>
			</div>
			<p class="figure-caption">图1.14–处于使用中状态的笔记本实例</p>
			<p>从<em class="italic">图1.14 </em>中可以看出，一旦笔记本实例的状态变为<strong class="bold">在用</strong>，在<strong class="bold">动作</strong>下就会出现<strong class="bold">打开Jupyter </strong>和<strong class="bold">打开JupyterLab </strong>链接。点击<strong class="bold">打开Jupyter </strong>应该会打开一个新的选项卡，显示一个类似于下面截图所示的页面:</p>
			<div><div><img src="img/B16850_01_15.jpg" alt="Figure 1.15 – Jupyter&#13;&#10;" width="1135" height="861"/>
				</div>
			</div>
			<p class="figure-caption">图1.15–Jupyter</p>
			<p>在<em class="italic">图1.15 </em>中，我们可以看到我们在笔记本实例创建步骤中指定的Git存储库已经被克隆到Jupyter工作目录中。</p>
			<p>现在我们已经设置好了一切，我们应该准备好本章的下一个食谱了！</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>工作原理……</h2>
			<p>正如本文开头提到的<a id="_idIndexMarker019"/>,<strong class="bold">sage maker笔记本实例</strong>是一个完全托管的计算实例，运行一系列工具和应用程序，帮助数据科学家和ML实践者立即进行ML实验。以下是笔记本实例中已经可用的一些工具和应用程序。如果我们自己进行设置，可能需要一些时间才能让这些工具正常工作:</p>
			<ul>
				<li><strong class="bold">木星笔记本</strong>和<strong class="bold">木星实验室</strong></li>
				<li>Jupyter内核和Python包，如<strong class="bold"> SageMaker Python SDK </strong>、<strong class="bold"> scikit-learn </strong>、<strong class="bold"> TensorFlow </strong>和<strong class="bold"> Apache MXNet </strong></li>
				<li>Jupyter R内核连同<a id="_idIndexMarker020"/>的<strong class="bold"> reticulate </strong>库一起预装在笔记本上</li>
				<li><strong class="bold"> AWS CLI </strong></li>
			</ul>
			<p>使用<strong class="bold"> SageMaker笔记本实例</strong>时，建议在进行实验时尽可能对笔记本实例使用较小的实例类型(例如ml.t2.medium)以降低成本。当然，在处理相对较大的数据集时，我们可以根据需要更新和升级notebook实例类型。如图<em class="italic">图1.16 </em>所示，笔记本实例通常大部分时间都在运行，用于培训的ML实例仅运行几分钟:</p>
			<div><div><img src="img/B16850_01_16.jpg" alt="Figure 1.16 – Using a smaller instance type for the notebook instance and using &#13;&#10;a larger instance type for the instances used for the training jobs&#13;&#10;" width="1196" height="595"/>
				</div>
			</div>
			<p class="figure-caption">图1.16–对笔记本实例使用较小的实例类型，对用于培训作业的实例使用较大的实例类型</p>
			<p>请注意，使用较大的实例类型(如ml . m 5.2 xlage)比使用较小的实例类型(包括ml.t2.medium和ml.t3.medium实例)更昂贵。鉴于这些培训作业仅持续几分钟，使用较大实例类型的成本影响显著降低，因为一旦培训作业完成，这些实例就会自动删除<a id="_idIndexMarker021"/>。</p>
			<p class="callout-heading">重要说明</p>
			<p class="callout">为了消除任何混淆，重要的是要注意在训练和处理作业期间创建的ML实例不同于我们运行脚本的原始笔记本实例。在我们使用estimator.fit()和<strong class="bold"> SageMaker Python SDK </strong>运行训练作业之前，我们<a id="_idIndexMarker022"/>只有一个实例在运行——笔记本实例。在运行estimator.fit()函数时，我们将运行两个或更多实例——为笔记本实例运行的ML实例和为培训作业运行的一个或多个ML实例。训练作业完成后，为训练作业运行的ML实例被删除，我们又回到只有一个笔记本实例的状态。由于我们还没有使用<strong class="bold"> SageMaker Python SDK </strong>进行模型训练和部署，这些细节可能还不完全有意义。不要担心，当我们完成本章的食谱时，这些笔记会更有意义。</p>
			<p>在大多数情况下，在数据处理和训练步骤中使用较大的实例，在ML从业者执行和测试脚本的笔记本实例中使用较小的实例是更好的选择。</p>
			<p>更多信息，请随时查看<a id="_idIndexMarker023"/>亚马逊SageMaker定价<strong class="bold">页面:<a href="https://aws.amazon.com/sagemaker/pricing/">https://aws.amazon.com/sagemaker/pricing/</a>。</strong></p>
			<h1 id="_idParaDest-27">检查SageMaker Python SDK和AWS CLI的版本</h1>
			<p>在这个菜谱中，我们将<a id="_idIndexMarker024"/>检查运行conda_python3内核的笔记本中的<strong class="bold"> SageMaker Python SDK </strong>版本。<strong class="bold"> SageMaker Python SDK </strong>是一个帮助数据科学家和ML从业者在<strong class="bold">亚马逊SageMaker </strong>上训练和部署ML模型的库。了解它的版本是非常重要的，因为版本1之间有几个不同之处。x和版本2。x的<strong class="bold"> SageMaker Python SDK </strong>。在本书中，我们将使用2.X版本。</p>
			<h2 id="_idParaDest-28">准备就绪</h2>
			<p>确保您已经完成了<em class="italic">启动Amazon SageMaker笔记本实例并准备先决条件</em>配方。</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>怎么做……</h2>
			<p>该配方中的第一组步骤<a id="_idIndexMarker025"/>集中于检查<strong class="bold"> SageMaker Python SDK </strong>版本:</p>
			<ol>
				<li value="1">Click <strong class="bold">New</strong> and then choose <strong class="bold">conda_python3</strong> in the drop-down list:<div><img src="img/B16850_01_17.jpg" alt="Figure 1.17 – Creating a new notebook using the conda_python3 kernel&#13;&#10;" width="719" height="441"/></div><p class="figure-caption">图1.17–使用conda_python3内核创建新笔记本</p><p>我们可以在<em class="italic">图1.17 </em>中看到，在创建新笔记本时，有几种环境可供选择。在列表的顶部，我们有<strong class="bold"> R </strong>环境，它允许熟悉并有经验使用R语言的数据科学家使用R、reticulate和<strong class="bold"> SageMaker Python SDK </strong>进行ML实验。你没听错！我们可以在R中使用Python库，并通过reticulate包来实现。我们还拥有允许我们立即使用不同的ML和深度学习库、框架和工具的环境。其中包括已经安装了<strong class="bold"> TensorFlow </strong>、<strong class="bold"> PyTorch </strong>、<strong class="bold"> Chainer </strong>和<strong class="bold"> MXNet </strong>的环境。</p></li>
				<li>A new tab will open. Click <strong class="bold">File</strong> &gt; <strong class="bold">Rename…</strong>:<div><img src="img/B16850_01_18.jpg" alt="Figure 1.18 – New notebook&#13;&#10;" width="853" height="251"/></div><p class="figure-caption">图1.18–新笔记本电脑</p><p>在<em class="italic">图1.18 </em>中，我们有<a id="_idIndexMarker026"/>一个新笔记本，其名称最初设置为无标题。有两种方法可以重命名此笔记本。第一种是点击<strong class="bold">文件</strong>菜单，然后点击<strong class="bold">重命名...</strong>。另一种方法是点击Jupyter标志和<strong class="bold">最后一个检查点</strong>文本之间的无标题文本。</p></li>
				<li>A popup will open. Specify First Notebook as the new notebook name and then click <strong class="bold">Rename</strong>:<div><img src="img/B16850_01_19.jpg" alt="Figure 1.19 – Renaming the notebook&#13;&#10;" width="966" height="295"/></div><p class="figure-caption">图1.19-重命名笔记本</p><p>我们指定新的笔记本名称，如图<em class="italic">图1.19 </em>所示。请注意，即使这看起来是一个简单的步骤，相应地命名事物并保持事物有条理将帮助我们在长期内完成更多的事情。</p></li>
				<li>In the code cell in the<a id="_idIndexMarker027"/> Jupyter notebook, run the following lines of code to see the version of the <strong class="bold">SageMaker Python SDK</strong> installed: <pre>import sagemaker
sagemaker.<strong class="bold">__version__</strong></pre><p>我们应该得到2分。运行这几行代码后的X.X值:</p><div><img src="img/B16850_01_20.jpg" alt="Figure 1.20 – Checking the SageMaker Python SDK version&#13;&#10;" width="1490" height="499"/></div><p class="figure-caption">图1.20–检查SageMaker Python SDK版本</p><p>如图<em class="italic">图1.20 </em>所示，我们使用的是版本2。<strong class="bold"> SageMaker Python SDK </strong>的x。如果您使用的是较低版本的<strong class="bold"> SageMaker Python SDK </strong>，请运行以下命令安装最新版本！pip安装-升级笔记本电脑单元内的sagemaker。命令前的感叹号允许我们执行终端命令，而不必打开单独的终端。</p><p class="callout-heading">注意</p><p class="callout">有关使用版本2的<a id="_idIndexMarker028"/>的更多信息，请参考本页。<strong class="bold"> SageMaker Python SDK </strong>的x:<a href="https://sagemaker.readthedocs.io/en/stable/v2.html">https://sagemaker.readthedocs.io/en/stable/v2.html</a>。</p><p>该方法中的下一组步骤集中在检查<strong class="bold"> AWS CLI </strong>版本和操作系统细节。什么是AWS CLI？<strong class="bold"> AWS命令行界面</strong> (AWS CLI)帮助<a id="_idIndexMarker029"/>我们从命令行控制多个AWS服务和管理资源。</p></li>
				<li>Click on the Jupyter logo to go back to the root page. Next, create a new Terminal by clicking <strong class="bold">New</strong> and then choosing <strong class="bold">Terminal</strong> in the drop-down list:<div><img src="img/B16850_01_21.jpg" alt="Figure 1.21 – Creating a new Terminal&#13;&#10;" width="719" height="325"/></div><p class="figure-caption">图1.21–创建新的终端</p><p>我们可以在<em class="italic">图1.21 </em>中看到<strong class="bold">端子</strong>选项在列表的底部。选择<strong class="bold">终端</strong>选项将打开一个类似于图1.22 所示的新标签:</p><div><img src="img/B16850_01_22.jpg" alt="Figure 1.22 – New Terminal&#13;&#10;" width="341" height="143"/></div><p class="figure-caption">图1.22–新终端</p><p>这个终端允许我们执行bash命令并使用命令行工具，如<strong class="bold"> AWS CLI </strong>。我们还可以使用sudo yum install命令在notebook实例中安装包。</p></li>
				<li>Next, we check the <a id="_idIndexMarker030"/>version of the <strong class="bold">AWS CLI</strong> tool installed:<pre><strong class="bold">aws --version</strong></pre><p>您应该得到一个类似AWS-CLI/1 . 19 . 22 Python/3 . 6 . 13 Linux/4 . 14 . 219-119.340 . amzn 1 . x86 _ 64 boto core/1 . 20 . 22的值。</p></li>
				<li>Check the operating system details by reading the /etc/os-release file:<pre><strong class="bold">cat /etc/os-release</strong></pre><p>您应该会得到类似于以下屏幕截图所示的操作系统详细信息:</p></li>
			</ol>
			<div><div><img src="img/B16850_01_23.jpg" alt="Figure 1.23 – SageMaker notebook instance operating system details&#13;&#10;" width="458" height="174"/>
				</div>
			</div>
			<p class="figure-caption">图1.23–sage maker笔记本实例操作系统详情</p>
			<p>在<em class="italic">图1.23 </em>中，我们可以看到我们正在使用Amazon Linux AMI 2018.03处理一个实例。现在我们知道了我们正在使用的笔记本实例的操作系统细节，如果shell命令或安装脚本不能立即工作，那么调试问题就容易多了。</p>
			<p>现在我们对本书中使用的工具和版本有了更好的理解，我们可以在下一个食谱中继续进行ML实验了！</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>它是如何工作的……</h2>
			<p><strong class="bold"> SageMaker Python SDK </strong>帮助<a id="_idIndexMarker031"/>数据科学家和ML实践者使用Python库进行ML实验，该库抽象了底层API操作，这使其与<strong class="bold"> Boto3 AWS SDK for Python </strong>有所区别。<strong class="bold"> SageMaker Python SDK </strong>利用抽象层和概念<a id="_idIndexMarker032"/>如模型、估计器和预测器，fit()和deploy()函数类似于库和<a id="_idIndexMarker033"/>框架如<a id="_idIndexMarker034"/>Keras和<strong class="bold"> scikit-learn </strong>所拥有的。</p>
			<p>在这个食谱中，我们使用了sagemaker。__version__检查<strong class="bold"> SageMaker Python SDK </strong>的版本。这很重要，因为我们试图避免使用版本1。在开始任何实验之前。如果您需要从版本1迁移现有笔记本<a id="_idIndexMarker035"/>。x到版本2。十、参考此链接:<a href="https://sagemaker.readthedocs.io/en/stable/v2.html">https://sagemaker.readthedocs.io/en/stable/v2.html</a>。AWS CLI 也是如此。尽可能使用最新版本的命令行工具非常重要。如果您使用的是旧版本的<strong class="bold"> AWS CLI </strong>，请参考此链接并将其升级到新版本:<a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html">https://docs . AWS . Amazon . com/CLI/latest/user guide/CLI-chap-install . html</a>。</p>
			<p>在菜谱的最后，我们通过检查/etc/os-release文件检查了操作系统的详细信息。假设我们正在使用一个使用<strong class="bold"> Amazon Linux AMI </strong>的实例，当我们需要安装软件包时，我们将<a id="_idIndexMarker036"/>使用sudo yum install命令而不是sudo apt install。请随意查看<a href="https://aws.amazon.com/amazon-linux-ami/">https://aws.amazon.com/amazon-linux-ami/</a>获取更多关于这个Linux镜像的信息。</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>为线性回归实验准备亚马逊S3桶和训练数据集</h1>
			<p>在这个菜谱中，我们将在终端内使用<strong class="bold"> AWS CLI </strong>创建一个<strong class="bold">亚马逊S3 </strong> bucket。当我们在本章<a id="_idIndexMarker037"/>中执行不同的配方时，这个<strong class="bold"> S3 </strong>桶将包含输入和输出文件。如果这是你第一次听说<strong class="bold">亚马逊S3 </strong>，这是一个对象存储服务，帮助用户存储他们的文件和数据。在本书的食谱中，当我们在进行ML实验时，我们将在<strong class="bold">亚马逊S3 </strong>中存储和下载不同的文件、数据集和<a id="_idIndexMarker038"/>日志。另一方面，<strong class="bold"> AWS命令行界面(CLI) </strong>是一个命令行实用程序，有助于控制和管理多个AWS服务和资源。在这个菜谱中，我们将使用它在终端中用aws s3 mb命令创建一个<strong class="bold">亚马逊S3 </strong>桶。</p>
			<p class="callout-heading">重要说明</p>
			<p class="callout">请注意，本书中的大多数食谱都会将文件存储和加载到我们将在本食谱中创建的S3存储桶中。在这个S3桶里，我们将为这本书的每一章创建一个文件夹，以保持东西有条理。</p>
			<p>我们还将准备用于本章剩余食谱的数据集。该数据集只有三列——姓氏、管理经验月份和月薪。除此之外，它将只有20个记录，因为这将足以准备我们的第一个<strong class="bold">线性学习者</strong>模型。我们<a id="_idIndexMarker040"/>有意试图保持<a id="_idIndexMarker041"/>事情简单，这样我们就可以专注于模型的训练、评估和部署，而不必在我们的第一次尝试中经历很多问题。</p>
			<h2 id="_idParaDest-32">准备就绪</h2>
			<p>确保您已经完成了<em class="italic">启动Amazon SageMaker笔记本实例和准备先决条件</em>方法。</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>怎么做……</h2>
			<p>该配方中的第一组步骤集中在使用<strong class="bold"> AWS CLI </strong>创建S3铲斗<a id="_idIndexMarker043"/>:</p>
			<ol>
				<li value="1">Create a new Terminal by clicking <strong class="bold">New</strong> and then choosing <strong class="bold">Terminal</strong> in the drop-down list: <div><img src="img/B16850_01_24.jpg" alt="Figure 1.24 – Creating a new Terminal&#13;&#10;" width="921" height="325"/></div><p class="figure-caption">图1.24–创建新的终端</p><p>在<em class="italic">图1.24 </em>中，我们<a id="_idIndexMarker044"/>可以看到终端选项在列表的<a id="_idIndexMarker045"/>底部。选择<strong class="bold">终端</strong>选项将打开一个新的选项卡，类似于图1.25 中的<em class="italic">所示:</em></p><div><img src="img/B16850_01_25.jpg" alt="Figure 1.25 – Terminal&#13;&#10;" width="332" height="141"/></div><p class="figure-caption">图1.25–终端</p><p>在接下来的几个步骤中，我们将使用这个终端通过<strong class="bold"> AWS CLI </strong>创建一个S3存储桶。</p></li>
				<li>Check the existing <strong class="bold">Amazon S3</strong> buckets by using the aws s3 ls command: <pre><strong class="bold">aws s3 ls</strong></pre><p>这将帮助我们测试<strong class="bold"> AWS CLI </strong>是否也已正确配置。</p><p class="callout-heading">重要说明</p><p class="callout">如果出现无法定位凭证错误，这意味着在<strong class="bold"> AWS CLI </strong>中没有正确配置AWS凭证。要解决此问题，请按照此页面上的步骤操作:<a href="https://aws.amazon.com/premiumsupport/knowledge-center/s3-locate-credentials-error/">https://AWS . Amazon . com/premium support/knowledge-center/S3-locate-credentials-error/</a>。</p></li>
				<li>Create a<a id="_idIndexMarker046"/> new <strong class="bold">Amazon S3</strong> bucket by using the aws s3 mb command. Make sure to specify a unique BUCKET_NAME before<a id="_idIndexMarker047"/> running the following block of code:<pre><strong class="bold">BUCKET_NAME=my-custom-s3-bucket-abcdef</strong>
<strong class="bold">aws s3 mb s3://$BUCKET_NAME</strong></pre><p>如果bucket创建步骤成功，那么在使用aws s3 mb命令之后，您应该会看到与make_bucket: <s3 bucket="" name="">类似的一行。同样，不要忘记将前面代码块中的my-custom-s3-bucket-abcdef替换为您选择的全局唯一的s3存储桶名称。</s3></p><p>现在我们已经完成了S3存储桶的创建，下一组步骤集中在创建首选目录结构以及一个空的CSV文件。</p></li>
				<li>Now, let's print the working directory using the pwd command. Let's also check the files and directories in our current working directory using the ls command:<pre><strong class="bold">pwd</strong>
<strong class="bold">ls</strong></pre><p>运行这些命令将生成类似于以下屏幕截图所示的输出:</p><div><img src="img/B16850_01_26.jpg" alt="Figure 1.26 – Current working directory and the files inside the current working directory&#13;&#10;" width="462" height="184"/></div><p class="figure-caption">图1.26-当前工作目录和当前工作目录中的文件</p><p>在<em class="italic">图1.26 </em>中，我们可以快速查看一下<strong class="bold"> SageMaker笔记本实例</strong>创建后的初始目录结构。我们可以看到这里也有目录<a id="_idIndexMarker048"/>用于SageMaker示例<a id="_idIndexMarker049"/>笔记本。这些示例笔记本是从这个库中自动提取的:<a href="https://github.com/aws/amazon-sagemaker-examples">https://github.com/aws/amazon-sagemaker-examples</a>。</p></li>
				<li>Create the required directory structure using the mkdir command. We use the -p option to automatically create the subdirectories as well:<pre><strong class="bold">cd SageMaker</strong>
<strong class="bold">mkdir -p my-experiments/chapter01/files</strong>
<strong class="bold">ls -1ahF</strong></pre><p>运行这些命令将为我们提供类似于图1.27 所示的目录结构:</p><div><img src="img/B16850_01_27.jpg" alt="Figure 1.27 – The my-experiments directory and its subdirectories have been created&#13;&#10;" width="745" height="384"/></div><p class="figure-caption">图1.27–my-experiments目录及其子目录已经创建</p><p>注意在<em class="italic">图1.27 </em>中，使用的命令是ls -1ahF，而不是ls-lahF(较短的<em class="italic">短划线</em>与较长的<em class="italic">长划线</em>)。确保使用数字1，而不是小写字母l。</p></li>
				<li>使用以下命令导航到chapter01目录中的files目录:<pre><strong class="bold">cd my-experiments/chapter01/files</strong></pre></li>
				<li>使用touch命令，创建一个空文件，文件名为management _ experience _ and _ salary . CSV:<pre><strong class="bold">touch management_experience_and_salary.csv</strong></pre></li>
				<li>关闭<a id="_idIndexMarker050"/>终端浏览器选项卡。</li>
				<li>Navigate back<a id="_idIndexMarker051"/> to the Jupyter UI and click the <strong class="bold">Jupyter</strong> logo to go back to the home working directory:<div><img src="img/B16850_01_28.jpg" alt="Figure 1.28 – Clicking the Jupyter logo&#13;&#10;" width="430" height="139"/></div><p class="figure-caption">图1.28–点击Jupyter标志</p><p>您将被重定向回工作目录，其中显示了使用Amazon-SageMaker-Cookbook学习的机器目录和我的实验目录:</p><div><img src="img/B16850_01_29.jpg" alt="Figure 1.29 – Home directory showing both the Machine-Learning-with-Amazon-SageMaker-Cookbook and my-experiments directories&#13;&#10;" width="1071" height="408"/></div><p class="figure-caption">图1.29-显示使用Amazon-SageMaker-Cookbook的机器学习和my-experiments目录的主目录</p><p>在<em class="italic">图1.29 </em>中，我们有自己偏好的目录结构。Amazon-SageMaker-Cookbook的机器学习目录包含我们的参考笔记本，my-experiments目录将包含我们在制作本书<a id="_idIndexMarker053"/>的食谱时从零开始准备的笔记本和文件<a id="_idIndexMarker052"/>。在我们完成这本书之后，my-experiments目录的内容应该类似于Machine-Learning-with-Amazon-sage maker-Cookbook目录中的内容。</p></li>
				<li>Navigate to the files directory by clicking my-experiments, chapter01, and then files: <div><img src="img/B16850_01_30.jpg" alt="Figure 1.30 – Navigating to the CSV file inside the files directory&#13;&#10;" width="455" height="250"/></div><p class="figure-caption">图1.30–导航到文件目录中的CSV文件</p><p>如图<em class="italic">图1.30 </em>所示，我们在files目录下有management _ experience _ and _ salary . CSV文件。如果我们想跳回其中一个父目录，我们可以通过单击面包屑中的链接来实现。</p></li>
				<li>Click <strong class="bold">management_experience_and_salary.csv</strong>. This should open a new tab, as shown in the following screenshot:<div><img src="img/B16850_01_31.jpg" alt="Figure 1.31 – Empty CSV file&#13;&#10;" width="673" height="155"/></div><p class="figure-caption">图1.31–空CSV文件</p><p>在<em class="italic">图1.31 </em>中，我们可以看到一个空的management _ experience _ and _ salary . CSV文件。</p></li>
				<li>Update the <a id="_idIndexMarker054"/>values inside the <strong class="bold">comma-separated values</strong> (<strong class="bold">CSV</strong>) file and<a id="_idIndexMarker055"/> make sure that it contains the following records:<div><img src="img/B16850_01_32.jpg" alt="Figure 1.32 – The CSV data we will use in this chapter to prepare our linear regression model&#13;&#10;" width="661" height="864"/></div><p class="figure-caption">图1.32–我们将在本章中使用CSV数据来准备我们的线性回归模型</p><p>我们可以在<em class="italic">图1.32 </em>中看到一个3列21行的表格，包括表头。CSV文件应该有3列:姓氏、管理经验月份和月薪。</p><p class="callout-heading">小费</p><p class="callout">您还可以从Machine-Learning-with-Amazon-sage maker-Cookbook/chapter 01目录中复制management _ experience _ and _ salary . CSV文件的内容。您也可以在这里找到存储库，并从Chapter01目录中复制必要的文件:<a href="https://github.com/PacktPublishing/Machine-Learning-with-Amazon-SageMaker-Cookbook">https://github . com/packt publishing/Machine-Learning-with-Amazon-sage maker-Cookbook</a>。</p><p>CSV文件<a id="_idIndexMarker056"/>在被<a id="_idIndexMarker057"/>保存之前应该是这样的:</p><div><img src="img/B16850_01_33.jpg" alt="Figure 1.33 – CSV file containing the training data&#13;&#10;" width="602" height="466"/></div><p class="figure-caption">图1.33–包含训练数据的CSV文件</p><p>我们在<em class="italic">图1.33 </em>中有20行样本数据的CSV文件。我们如何解释这个CSV文件的内容？泰勒有65个月的管理经验，月薪1630美元。</p></li>
				<li>最后点击<strong class="bold">文件</strong>打开<strong class="bold">文件</strong>菜单，然后点击<strong class="bold">保存</strong>。之后，您可以关闭浏览器选项卡，或者通过单击Jupyter徽标导航回主目录。</li>
			</ol>
			<p>既然我们已经准备好了我们的训练数据集，现在我们可以继续ML过程中的下一步了！</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>工作原理……</h2>
			<p>这个菜谱的第一部分涉及使用<strong class="bold"> AWS CLI </strong>创建一个<strong class="bold">亚马逊S3 </strong> bucket。正如您将在后面的食谱中看到的，我们将使用这个S3存储桶来存储ML实验的输入和输出文件。每当你在配方的代码块中看到&lt;在此插入桶名&gt;文本时，确保用该配方中使用的桶名更新和替换它们。</p>
			<p>该方法的第二部分涉及创建CSV文件并用数据集值填充它。如您所见，我们有意使用一个小而简化的数据集。在开始使用ML时，有这样一种误解，即在训练模型时将大型数据集作为先决条件。当然，我们可以使用的数据越多，我们的结果就越好。然而，当我们试图第一次就让事情运转起来时，我们可以使用一个较小的数据集来帮助我们快速进行设置和实验。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">在本章中，我们将利用这个相对小而简单的数据集，通过使用<strong class="bold">线性学习器</strong> <strong class="bold"> SageMaker </strong>内置算法来演示<a id="_idIndexMarker058"/>动作中的线性回归。<strong class="bold">简单线性回归</strong>涉及<a id="_idIndexMarker059"/>使用单一预测变量预测目标值。在这种情况下，目标值是专业人员的月薪，预测变量是以月为单位的管理经验。</p>
			<p>在我们继续训练我们的<strong class="bold">线性学习者</strong>模型之前，让我们在下一个食谱中首先可视化和理解我们的数据！</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>用Python可视化和理解数据</h1>
			<p>在这个配方中，我们<a id="_idIndexMarker060"/>将加载样本数据集并生成一个<a id="_idIndexMarker061"/>散点图，以探索数据集中<a id="_idIndexMarker062"/>变量之间的关系。正如您在下面的<a id="_idIndexMarker063"/>屏幕截图中看到的，我们从包含management_experience_months和monthly_salary值的数据框架开始，并生成了一个可视化图形，使我们能够观察这两个变量之间的线性关系:</p>
			<div><div><img src="img/B16850_01_34.jpg" alt="Figure 1.34 – Using matplotlib to generate a scatter plot chart from a DataFrame&#13;&#10;" width="1243" height="479"/>
				</div>
			</div>
			<p class="figure-caption">图1.34–使用matplotlib从数据帧生成散点图</p>
			<p>这个方法的目的是让我们在直接进入ML过程的其他步骤之前，首先使用绘图库(例如matplotlib)来理解数据。我们首先将一个样本数据集从CSV文件加载到pandas数据框架，然后使用matplotlib生成散点图。</p>
			<h2 id="_idParaDest-36">准备就绪</h2>
			<p>本食谱上接<em class="italic">准备亚马逊S3桶和线性回归实验的训练数据集</em>食谱。</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>怎么做……</h2>
			<p>我们将在这个菜谱中使用pandas数据分析库和matplotlib绘图库来加载数据并生成散点图，以探索management_experience_months (x)和monthly_salary (y)之间的关系。以下一组指令向我们展示了如何从CSV文件加载数据集的x和y值:</p>
			<ol>
				<li value="1">如果你还没有使用conda_python3内核<a id="_idIndexMarker065"/>创建一个新的笔记本，在my-experiments/chapter01目录下创建一个新的笔记本，并将其重命名为这个食谱的标题<a id="_idIndexMarker066"/>。我们将在笔记本的下一组步骤中运行代码。</li>
				<li>Load the CSV file data <a id="_idIndexMarker067"/>into a DataFrame using <strong class="bold">pandas</strong>. The read_csv() function looks for and reads the file using the specified file path and returns the content as pandas.DataFrame.<pre>import pandas as pd
filename = "files/management_experience_and_salary.csv"
df_all_data = pd.<strong class="bold">read_csv</strong>(filename)</pre><p>注意，在使用read_csv()函数时，可以配置几个参数。最常见的有sep(分隔符)、header、use_cols。</p></li>
				<li>Inspect the value of df_all_data:<pre>df_all_data</pre><p>df_all_data的前几条记录将类似于<em class="italic">图1.35 </em>所示显示:</p><div><img src="img/B16850_01_35.jpg" alt="Figure 1.35 – The df_all_data dataframe (showing 9 records out of 20 total records)&#13;&#10;" width="722" height="498"/></div><p class="figure-caption">图1.35–df _ all _ data数据帧(显示了20条记录中的9条)</p><p>对于较大的数据集，您可以使用pandas中的其他可用选项，例如head()和tail()。您可能还会发现需要根据您正在使用的数据集<a id="_idIndexMarker068"/>来查找和处理<em class="italic"> null </em>或<em class="italic"> N/A </em>值，如下面的<a id="_idIndexMarker070"/>截图所示<a id="_idIndexMarker069"/>。</p></li>
				<li>We use the %store magic<a id="_idIndexMarker071"/> from <strong class="bold">IPython</strong> to store df_all_data and make it available in the <a id="_idIndexMarker072"/>notebooks for our next recipes:<pre><strong class="bold">%store</strong> df_all_data</pre><p>我们将在本章后面的<em class="italic">在Python中训练你的第一个模型</em>和<em class="italic">在Python中评估模型</em>中加载和使用df_all_data。</p><p>下一组步骤集中在使用<strong class="bold"> matplotlib </strong>库生成散点图，显示<em class="italic"> x </em>和<em class="italic"> y </em>值的(线性)关系。matplotlib 库<a id="_idIndexMarker073"/>是Python中最常用的数据可视化库之一。</p></li>
				<li>Import <strong class="bold">matplotlib</strong>:<pre>%matplotlib inline
import matplotlib.pyplot as plt</pre><p class="callout-heading">小费</p><p class="callout">请注意,%matplotlib inline是一个IPython魔法函数，它允许将matplotlib生成的图形包含并存储在Jupyter笔记本中。</p></li>
				<li>Generate<a id="_idIndexMarker074"/> a scatter <a id="_idIndexMarker075"/>plot using <strong class="bold">matplotlib</strong>:<pre>plt.rcParams["figure.figsize"] = (8,8)
plt.<strong class="bold">scatter</strong>(
    df_all_data.management_experience_months,   
    df_all_data.monthly_salary)
plt.xlabel('Management Experience (Months)',  
           fontsize=18)
plt.ylabel('Monthly Salary (USD)', fontsize=16)
plt.xlim(0, 120)
plt.ylim(0, 2400)</pre><p>这将呈现一个<a id="_idIndexMarker076"/>图表，帮助我们了解我们关注的两个变量之间的关系:</p></li>
			</ol>
			<div><div><img src="img/B16850_01_36.jpg" alt="Figure 1.36 – Scatter plot using matplotlib where the x axis = management experience (months) &#13;&#10;and the y axis = monthly salary&#13;&#10;" width="946" height="885"/>
				</div>
			</div>
			<p class="figure-caption">图1.36-使用matplotlib的散点图，其中x轴=管理经验(月), y轴=月薪</p>
			<p>在<em class="italic">图1.36 </em>的<a id="_idIndexMarker077"/>散点图中，我们看到有一个线性趋势。我们还看到自变量和因变量之间存在正相关关系。这种相关性表明<a id="_idIndexMarker078"/>一个简单的线性回归模型的一种可能用法，它使用自变量<a id="_idIndexMarker079"/>的值(管理<a id="_idIndexMarker080"/>经验月数)来预测因变量(月薪)的值。</p>
			<p>虽然还需要一些假设和步骤来证明线性回归模型的使用，但我们现在将跳过这些，因为我们将专注于使用<strong class="bold">线性学习器</strong> <strong class="bold"> SageMaker </strong>内置算法来解决这个线性回归问题。现在，让我们看看这是如何工作的！</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>工作原理……</h2>
			<p>在这个菜谱中，我们<a id="_idIndexMarker081"/>使用<strong class="bold"> pandas </strong>从一个CSV文件中加载样本数据集。我们将只处理带有几条记录和几列的CSV文件。在处理现实生活中的实验时，您很可能会处理包含更多列的大型数据集。一般ML实验需要几百到几千条记录才能得到好的结果。对于处理文本或图像的更复杂的实验，你肯定需要更多。</p>
			<p>在生成的散点图中，我们可以看到<em class="italic">月薪</em>(一般)随着<em class="italic">月管理经验</em>的增加而增加。根据我们正在解决的问题的类型，我们可能最终会使用其他类型的图表，并且最有可能的是，它可以使用<strong class="bold"> matplotlib </strong>来可视化。在典型的ML工作负载和实验中，我们通常在进行训练步骤之前执行数据预处理和特征工程步骤。</p>
			<p class="callout-heading">重要说明</p>
			<p class="callout">我们有意跳过了其他数据预处理和特性工程步骤，这样我们就可以专注于使用<strong class="bold">Amazon SageMaker Python SDK</strong>运行一个推理端点。在<a href="B16850_04_Final_ASB_ePub.xhtml#_idTextAnchor200"> <em class="italic">第四章</em> </a>、<em class="italic">准备、处理、分析数据</em>中，我们会谈到几种不同的解决方案，包括<strong class="bold"> Amazon SageMaker处理</strong>，来处理和转换数据。</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>用Python训练你的第一个模型</h1>
			<p>在之前的配方中，我们<a id="_idIndexMarker082"/>生成了一个散点图，以探索数据集中两个变量之间的<a id="_idIndexMarker083"/>关系。在这个菜谱中，我们将使用<strong class="bold"> SageMaker线性学习器</strong>内置算法来构建一个线性回归模型，该模型使用相关管理经验的月数来预测专业人员的工资。该配方旨在演示如何在涉及训练-测试分割和运行训练作业的ML实验中使用<strong class="bold"> SageMaker </strong>内置算法:</p>
			<div><div><img src="img/B16850_01_37.jpg" alt="Figure 1.37 – Performing the train-test split and then running the training jobs to generate a model&#13;&#10;" width="1188" height="514"/>
				</div>
			</div>
			<p class="figure-caption">图1.37–执行训练测试分割，然后运行训练作业以生成模型</p>
			<p><em class="italic">图1.37 </em>向我们展示了我们将在这个食谱中做些什么。使用从<em class="italic">加载的数据帧，在Python </em>配方中可视化和理解您的数据，我们将执行训练-测试分割，并使用训练数据集来训练和构建模型。</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>准备就绪</h2>
			<p>这份食谱上接<em class="italic">用Python </em>可视化和理解你的数据。确保您已经完成了该配方中的步骤，因为我们将需要df_all_data的值。</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>怎么做……</h2>
			<p>以下指令集向我们展示了如何使用Python构建和部署线性回归模型:</p>
			<ol>
				<li value="1">如果您还没有使用conda_python3内核创建一个新的笔记本，请在my-experiments/chapter01目录中创建一个新的笔记本，并将其重命名为这个食谱的标题。我们将在笔记本的下一组步骤中运行代码。</li>
				<li>使用来自<strong class="bold"> IPython </strong>的%store magic <a id="_idIndexMarker084"/>来读取存储的<a id="_idIndexMarker085"/>变量df_all_data，该变量来自<em class="italic">可视化和理解Python中的数据</em>方法:<pre>%store -r <strong class="bold">df_all_data</strong></pre></li>
				<li>Perform the train-test split:<pre>from sklearn.model_selection import <strong class="bold">train_test_split</strong>
X = df_all_data['management_experience_months']
X = X.values
y = df_all_data['monthly_salary'].values
     
X_train, X_test, y_train, y_test = train_test_split(
    X, y, <strong class="bold">test_size=0.3</strong>, random_state=0)</pre><p>train_test_split()函数接受一个或多个数组，并将它们分成互斥的训练和测试数据帧。对于0.3的测试大小，我们分配30%的数据集作为测试数据。在我们的示例中，我们传递了两个数据帧，X和y。通过输出，我们仅用一行代码就从X获得了X_train和X_test，从y获得了y_train和y_test。因为我们向train_test_split()传递了两个数据帧X和y，所以只用一行代码就获得了两个数据帧的分割。random_state参数只是允许我们在下一次运行同一行代码时得到相同的结果，以达到可再现性的目的。</p><p class="callout-heading">注意</p><p class="callout">当使用数据集时，我们通常将数据集分为训练数据集和测试数据集。我们使用训练数据集来训练ML模型。测试数据集用于评估模型。在本书接下来的章节中，我们将看到在一些食谱中，我们将把数据集分成训练、验证和测试数据集。当模型在调整模型超参数的同时被训练时，验证数据集将用于评估训练数据上的模型。在使用训练和验证数据集完成训练后，测试数据集将用于评估模型。</p></li>
				<li>Ensure that the<a id="_idIndexMarker086"/> training dataset has the target column as the first <a id="_idIndexMarker087"/>column:<pre>df_training_data = pd.DataFrame({
    'monthly_salary': <strong class="bold">y_train</strong>,
    'management_experience_months': <strong class="bold">X_train</strong>
})</pre><p>这一步很重要，因为一些<a id="_idIndexMarker088"/> l算法，如<strong class="bold">线性学习器内置算法</strong>，期望第一列包含目标变量数据。</p></li>
				<li>Inspect the training dataset:<pre>df_training_data</pre><p>运行代码将快速查看数据集前几行的x (management_experience_months)和y (monthly_salary)值:</p><div><img src="img/B16850_01_38.jpg" alt="Figure 1.38 – The df_training_data dataframe (showing 8 records out of 14 total records)&#13;&#10;" width="589" height="418"/></div><p class="figure-caption">图1.38–df _ training _ data数据帧(显示了14条记录中的8条)</p><p>在<em class="italic">图1.38 </em>中可以看到，训练数据集共有14条记录，占我们初始CSV文件中记录总数的70%。这是因为在前面的步骤中使用train_test_split()函数时，将test_size参数设置为0.3。</p><p>一旦我们完成了训练测试分割的<a id="_idIndexMarker089"/>步骤，我们将把训练数据上传到S3:</p></li>
				<li>使用mkdir bash命令创建一个临时目录。请注意，这与/tmp目录不同，因为这个新的tmp目录是在my-experiments/chapter01目录中创建的:<pre>!mkdir -p <strong class="bold">tmp</strong></pre></li>
				<li>使用to_csv()函数将训练数据保存为<a id="_idIndexMarker090"/> CSV格式(无标题和索引)。这将文件保存在我们刚刚创建的tmp目录中。重要的是要注意头和索引参数被设置为假，因为在后面的步骤中的训练作业中要使用的训练数据集预期没有头和索引:<pre>df_training_data.<strong class="bold">to_csv</strong>(     'tmp/<strong class="bold">training_data.csv</strong>',      <strong class="bold">header=False</strong>, <strong class="bold">index=False</strong>)</pre></li>
				<li>指定存储桶名称和前缀。确保将s3_bucket的值替换为您在<em class="italic">准备亚马逊s3桶和线性回归实验的训练数据集</em>配方:<pre>s3_bucket = '<strong class="bold">&lt;insert bucket name here&gt;</strong>' prefix = 'chapter01'</pre>中创建的S3桶的名称</li>
				<li>Upload the training data CSV to S3 using the <strong class="bold">AWS CLI</strong>. The following line of code runs the bash command that makes use of the AWS CLI tool to copy and upload the CSV file we have generated in a previous step to the S3 bucket. The first parameter after aws s3 cp is the source (tmp/training_data.csv). This is the file we generated and saved in the tmp directory after using the to_csv() function. The second parameter is the target destination (s3://&lt;bucket + prefix&gt;/training_data.csv): <pre>!<strong class="bold">aws s3 cp</strong> tmp/training_data.csv s3://{s3_bucket}/{prefix}/input/training_data.csv</pre><p>重要的是<a id="_idIndexMarker091"/>注意，前面的代码块只包含一行<a id="_idIndexMarker092"/>(以防下面的语句因为命令的长度而被渲染成两行)。</p><p class="callout-heading">小费</p><p class="callout">要指定在使用AWS CLI时使用的区域，可以使用- region选项。如需了解更多信息，请访问<a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-options.html">https://docs . AWS . Amazon . com/CLI/latest/user guide/CLI-configure-options . html</a>。</p><p>在<a id="_idIndexMarker093"/>下一组步骤中，我们将重点使用<a id="_idIndexMarker094"/><strong class="bold">SageMaker Python SDK</strong>来训练我们的<strong class="bold">线性学习器</strong>模型:</p></li>
				<li>Initialize and import the training prerequisites. The <strong class="bold">SageMaker Python SDK</strong>, along with the <strong class="bold">Boto AWS Python SDK</strong>, is already included when we use the <em class="italic">conda_python3</em> kernel in our Jupyter notebook. The <strong class="bold">Boto AWS Python SDK</strong> (boto3) is a service-level SDK that provides a way for us to access different AWS services (for example, <strong class="bold">EC2</strong>, <strong class="bold">S3</strong>, <strong class="bold">IAM</strong>, and more) programmatically. The <strong class="bold">SageMaker Python SDK</strong> focuses on operations we can do with <a id="_idIndexMarker095"/>SageMaker<a id="_idIndexMarker096"/> for our ML experiments:<pre>import <strong class="bold">sagemaker</strong>
import <strong class="bold">boto3</strong>
from sagemaker import get_execution_role
     
role_arn = get_execution_role()
session = sagemaker.Session()
region_name = boto3.Session().region_name</pre><p>get_execution_role()和sagemaker的返回值。Session()将在后面的步骤中使用。来自<strong class="bold"> SageMaker Python SDK </strong>的get_execution_role()函数返回与notebook实例相关联的IAM角色。这个函数的返回值是<a id="_idIndexMarker097"/>,稍后当我们为训练作业初始化评估器对象<a id="_idIndexMarker098"/>时，它被用作一个参数。</p><p class="callout-heading">注意</p><p class="callout">什么是<strong class="bold"> IAM角色</strong>？<strong class="bold"> IAM </strong>代表<a id="_idIndexMarker099"/>身份和访问管理。IAM角色是具有特定权限的身份，用于向用户和资源委派访问权限，而无需使用长期凭据。</p><p>除此之外，我们称之为sagemaker之后的值。Session()用作下一步的参数。它还提供了SageMaker实验中使用的便利函数和实用程序，包括upload_data()、download_data()、default_bucket()和account_id()函数。</p><p class="callout-heading">注意</p><p class="callout">什么是SageMaker会话对象？它是用来处理SageMaker API调用和请求以及与ML实验相关的其他服务(例如，<strong class="bold">亚马逊S3 </strong>)的对象。要了解更多信息，可以在这里查看我们可以与会话对象一起使用的可用实用函数:<a href="https://sagemaker.readthedocs.io/en/stable/api/utility/session.html">https://sagemaker . readthe docs . io/en/stable/API/utility/Session . html</a>。</p></li>
				<li>设定<strong class="bold"> S3 </strong>输入位置和<strong class="bold"> S3 </strong>输出位置。需要注意的是，下面的代码块只包含两行(如果由于语句长度的原因，下面的语句变成了四行或更多行):<pre>training_s3_input_location = f"s3://{s3_bucket}/{prefix}/input/training_data.csv"  training_s3_output_location = f"s3://{s3_bucket}/{prefix}/output/"</pre></li>
				<li>Prepare the S3 Input parameter with content_type="text/csv":<pre>from sagemaker.inputs import TrainingInput
train = <strong class="bold">TrainingInput</strong>(training_s3_input_location, content_type="text/csv")</pre><p>当我们使用的输入数据集格式<a id="_idIndexMarker101"/>不是我们正在使用的算法所期望的默认格式时，通常会执行这个步骤<a id="_idIndexMarker100"/>。<strong class="bold">线性学习器</strong>算法<a id="_idIndexMarker102"/>也支持recordIO包装的protobuf格式，使用起来比CSV格式更有效。为了使事情更简单，更容易吸收，我们将使用CSV格式。</p></li>
				<li>Prepare the image URI for <strong class="bold">Linear Learner</strong>. The retrieve() function returns the <strong class="bold">Amazon ECR</strong> URI of the <strong class="bold">Linear Learner</strong> built-in algorithm. Take note that the URI changes depending on the region and the experiments that you are running assume that all resources are in a single region. Otherwise, you will encounter issues during your training jobs. To solve these types of issues, simply specify the region name when using and configuring the different tools: <pre>from sagemaker.image_uris import retrieve 
container = <strong class="bold">retrieve</strong>("linear-learner", region_name, "1")
container</pre><p>这应该会产生类似于“382416733822 . dkr . ECR . us-east-1 . Amazon AWS . com/linear-learner:1”的值。</p></li>
				<li>Initialize the Estimator object. The Estimator class accepts a couple of arguments, including the container<a id="_idIndexMarker103"/> URI, SageMaker session object, and the role ARN we have obtained <a id="_idIndexMarker104"/>from the previous steps in this recipe. In the following code, we have also specified the arguments instance_count, instance_type, and output_path: <pre>estimator = sagemaker.estimator.<strong class="bold">Estimator</strong>(
    <strong class="bold">container</strong>,
    <strong class="bold">role</strong>, 
    <strong class="bold">instance_count</strong>=1, 
    <strong class="bold">instance_type</strong>='ml.m5.xlarge',
    <strong class="bold">output_path</strong>=training_s3_output_location,
    <strong class="bold">sagemaker_session</strong>=session)</pre><p>运行培训作业时，<strong class="bold"> SageMaker </strong>会在您正在使用的Jupyter笔记本实例之外启动新实例。这些实例专用于运行培训作业，并在培训作业完成后自动销毁。使用的培训作业实例的数量取决于instance_count参数，实例的大小和类型取决于instance_type参数。也就是说，当fit()函数在估计器中的当前配置的后续步骤中被调用时，SageMaker提供<a id="_idIndexMarker105"/>单个ml.m5.xlarge实例<a id="_idIndexMarker106"/>来运行<strong class="bold">线性学习器</strong>内置算法并将结果存储到output_path。</p><p class="callout-heading">重要说明</p><p class="callout">请注意，这是初始化评估程序对象和配置培训作业的方法之一。另一种选择是使用LinearLearner类，它抽象出运行训练作业时使用的容器图像。我们决定在本章中使用Estimator类，这样我们就有机会展示训练作业需要(1)容器映像，(2)训练数据集，(3)超参数，以及(4)一些其他配置值来执行。我们将在第四章 、<em class="italic">准备、处理和分析数据</em>中的<em class="italic">中看到一个示例，说明如何使用特定的算法估计器类通过内置的KMeans算法</em>执行聚类分析，<em class="italic">通过内置的PCA算法</em>执行降维，以及<em class="italic">使用protobuf recordIO训练输入类型</em>训练KNN模型。</p></li>
				<li>Set the hyperparameters of the estimator using the set_hyperparameters() function: <pre>estimator.<strong class="bold">set_hyperparameters</strong>(predictor_type='regressor', mini_batch_size=4)</pre><p>超参数<a id="_idIndexMarker107"/>是类似参数的值，可以在执行训练任务之前调整和配置<a id="_idIndexMarker108"/>。<a id="_idIndexMarker109"/>可配置的超参数值取决于所使用的算法，在这种情况下，我们使用线性学习器内置算法，我们设置predictor_type和mini_batch_size超参数。</p><p class="callout-heading">重要说明</p><p class="callout">假设我们正在处理一个相对较小的训练数据集(14条记录)，我们将mini_batch_size值设置为4。对于回归问题，predictor_type参数应设置为' regressor ',对于分类问题，predictor_type参数应设置为' binary_classifier '或' multiclass_classifier ',具体取决于类的数量。每个内置算法都有自己的一组有效的超参数和值，所以一定要查看官方的AWS文档。随着您对内置算法及其内部工作方式越来越熟悉，您将对如何修改和调整这些超参数有更好的感觉。</p></li>
				<li>Execute the training job using the fit() function. This runs the training job by provisioning the servers, running the algorithm on those servers, and then terminating the servers after. As this happens, log messages will be displayed in your notebook to update you on the status of the training job: <pre>estimator.<strong class="bold">fit</strong>({'train': train})</pre><p>培训工作的结果是一个ML模型，我们可以在接下来的步骤中使用它。训练作业完成后，可以使用Estimator对象的model_data属性访问包含输出模型工件的model.tar.gz文件的路径。</p><p class="callout-heading">小费</p><p class="callout">当有更大的数据集可用时，可以将验证数据集传递给fit()函数。</p><p>在<a id="_idIndexMarker110"/>大约8到15分钟后，我们应该会看到一组类似于<em class="italic">图1.39 </em>所示培训工作的<a id="_idIndexMarker111"/>日志:</p><div><img src="img/B16850_01_39.jpg" alt="Figure 1.39 – Results of the SageMaker training job execution in Python&#13;&#10;" width="1077" height="369"/></div><p class="figure-caption">图1.39–Python中SageMaker培训作业执行的结果</p><p>在<em class="italic">图1.39 </em>中，我们有fit()函数生成的日志。我们可以将日志消息和步骤分为以下几组— (1)启动并准备用于训练的ML <a id="_idIndexMarker112"/>实例，(2)下载输入的<a id="_idIndexMarker113"/>数据和训练图像，(3)在训练Docker容器中运行<em class="italic">入口点</em>脚本，(4)保存模型，(5)指定训练作业已经完成，最后(6)记录训练和可计费秒数。我们将在<em class="italic">设置Python和R实验环境</em>的<em class="italic">部分深入了解幕后发生的细节<em class="italic">第2章</em> ，<em class="italic">构建和使用自己的算法容器映像</em>。</em></p><p>如果您想要查看属性，例如训练作业细节和估计器对象的模型数据的位置，请随意运行估计器。__dict__在培训工作完成后。</p><p class="callout-heading">重要说明</p><p class="callout">如果您使用的是全新的AWS帐户，在使用fit()和deploy()函数启动ML实例时，可能会遇到ResourceLimitExceeded错误。要解决此问题，请打开AWS支持中心并创建一个案例。如需了解更多信息，请随时访问此链接:<a href="https://aws.amazon.com/premiumsupport/knowledge-center/resourcelimitexceeded-sagemaker/">https://AWS . Amazon . com/premium support/knowledge-center/resourcelimitexceed-sage maker/</a>。</p><p>在该配方的最后一组<a id="_idIndexMarker114"/>步骤中，我们将重点关注使用%store magic来<a id="_idIndexMarker115"/>保存训练好的模型S3位置、估计器的图像URI以及测试数据集值。</p></li>
				<li>Copy the value of estimator.model_data to a variable named model_data:<pre>model_data = estimator.<strong class="bold">model_data</strong>
model_data</pre><p>我们应该会得到一个类似于' S3://<s3 bucket="" name="">/chapter 01/output/linear-learner-2021-03-13-02-23-18-930/output/model . tar . gz '的值。</s3></p></li>
				<li>使用%store magic来存储model_data的值，这样我们就可以在<em class="italic">用Python中的Apache MXNet加载线性学习者模型</em>和<em class="italic">用Python部署您的第一个模型</em>中使用这个方法:<pre>%store <strong class="bold">model_data</strong></pre></li>
				<li>Copy the value of estimator.image_uri to a variable named model_uri:<pre>model_uri = <strong class="bold">estimator.image_uri</strong>
model_uri</pre><p>我们应该得到一个类似于' 382416733822 . dkr . ECR . us-east-1 . Amazon AWS . com/linear-learner:1 '的值。</p></li>
				<li>Similar <a id="_idIndexMarker116"/>to model_data, we use the %store magic to store the<a id="_idIndexMarker117"/> value of model_uri, X_test, and y_test:<pre>%store <strong class="bold">model_uri</strong>
%store <strong class="bold">X_test</strong>
%store <strong class="bold">y_test</strong></pre><p>至此，我们已经完成了训练一个<strong class="bold">线性学习者</strong>模型所需的步骤。</p></li>
			</ol>
			<p>现在让我们看看这个食谱是如何工作的！</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>工作原理……</h2>
			<p>在这个菜谱中，我们使用了<strong class="bold"> SageMaker Python SDK </strong>来构建和部署线性回归模型。该配方分为以下几个主要部分:</p>
			<ul>
				<li><strong class="bold">训练-测试分割</strong>:配方从训练-测试分割开始，将CSV文件中的数据集分为训练和测试数据集。理想情况下，我们应该执行这个步骤两次，这样我们就有了模型训练阶段的训练和验证数据集。通过这种方式，我们可以使用测试数据集来评估模型，而不是用于训练。</li>
				<li><strong class="bold">保存并上传训练数据集到S3 </strong>:分割数据集后的下一步是确保数据格式正确。在这里，我们确保CSV文件的第一列包含目标值，以便正常工作。培训数据被上传到<strong class="bold">亚马逊S3 </strong>，因为它是在运行<strong class="bold"> SageMaker </strong>培训作业之前培训数据需要上传的默认来源。我们在这个菜谱中使用了text/csv内容类型，但是我们也可以选择使用其他内容类型，例如用于<strong class="bold">线性学习器</strong>内置算法的application/x-recordio-proto buf。利用这一点，我们可以在训练步骤中使用<strong class="bold">优化的protobuf recordIO </strong>格式，还可以利用<strong class="bold">管道模式</strong>的<a id="_idIndexMarker118"/>优势，后者<a id="_idIndexMarker119"/>可以缩短更大数据集的训练作业开始时间。我们将在<em class="italic">将CSV数据转换为protobuf recordIO格式</em>和<em class="italic">使用protobuf recordIO训练输入类型</em>训练一个KNN模型中仔细查看protobuf recordIO格式<a href="B16850_04_Final_ASB_ePub.xhtml#_idTextAnchor200"> <em class="italic">第4章</em> </a>、<em class="italic">准备、处理和分析数据</em>。</li>
				<li><strong class="bold">训练</strong>:一旦训练数据被上传到<strong class="bold"> S3 </strong>，评估器对象在开始训练作业前被初始化和配置。Estimator只是一个高级接口，允许开发人员用不同的参数初始化和配置训练作业。一旦训练工作完成，model.tar.gz模型文件被上传到目标S3存储桶。</li>
			</ul>
			<p>请注意，用于执行所有这些步骤的<a id="_idIndexMarker120"/> Python代码在<a id="_idIndexMarker121"/>所有<strong class="bold"> SageMaker内置算法</strong>中都是相似的。然而，当处理不同的算法时，我们需要注意用户输入格式和超参数，因为它们根据所使用的算法和我们正在解决的ML问题而不同。</p>
			<h2 id="_idParaDest-43">还有更多…</h2>
			<p>您可能已经注意到，在初始化评估器对象时，我们会传递一个<strong class="bold"> ECR </strong>存储库URI。每个<strong class="bold"> SageMaker内置算法</strong>都有相应的容器映像，AWS已经为您准备并优化了这些映像。您还可以选择使用您自己的定制容器图像和算法，我们将在接下来的几章中详细讨论。<strong class="bold"> SageMaker </strong>在处理这些<a id="_idIndexMarker122"/>容器图像时的假设几乎是相同的，不管我们是使用内置算法还是我们已经构建并推送到我们自己的ECR存储库的自定义算法。我们可以创建自己的Docker映像，并让SageMaker在我们的培训工作和模型部署中使用该映像。我们只需要遵循一组指导原则，这样SageMaker就可以像使用内置算法一样使用Docker映像。也就是说，以下是我们每次执行培训步骤时<strong class="bold"> SageMaker </strong>在内部执行的一些步骤:</p>
			<ol>
				<li value="1">使用fit()函数时，超参数、训练输入和输出文件的位置以及使用<strong class="bold"> SageMaker Python SDK </strong>指定的其他参数和配置选项作为参数传递给<strong class="bold"> SageMaker API </strong>。</li>
				<li>ML实例由<strong class="bold"> SageMaker </strong>提供，算法容器映像在ML实例中拉出并启动。容器可以访问SageMaker下载的文件，包括输入文件和其他配置选项(例如，hyperparameters.json)。</li>
				<li>一旦培训工作完成，储存在(/opt/ml/model)中的输出文件由<strong class="bold"> SageMaker </strong>自动上传到目标S3目的地。</li>
			</ol>
			<p>我们将在<a href="B16850_02_Final_ASB_ePub.xhtml#_idTextAnchor061"> <em class="italic">第2章</em> </a>、<em class="italic">构建和使用自己的算法容器映像</em>中，详细了解这一切是如何工作的。</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>参见</h2>
			<p>如果您正在寻找使用<strong class="bold">线性学习器</strong>算法构建模型的实际应用，这些模型可用于使用真实数据集解决特定的现实生活问题，请随意查看<strong class="bold">AWS/Amazon-sage maker-examples</strong>GitHub资源库中的一些<a id="_idIndexMarker123"/>笔记本:</p>
			<ul>
				<li>乳腺癌预测——训练一个<strong class="bold">线性学习器</strong>模型来预测乳房肿块图像的属性(例如，半径_平均值、平滑度_标准差和凹度_最差)是否指示良性或恶性肿瘤。请随意使用以下链接查看这个笔记本:<a href="https://github.com/aws/amazon-sagemaker-examples/tree/master/introduction_to_applying_machine_learning/breast_cancer_prediction">https://github . com/AWS/Amazon-sage maker-examples/tree/master/introduction _ to _ applying _ machine _ learning/breast _ cancer _ prediction</a>。</li>
				<li>检测信用卡欺诈——一个<strong class="bold">线性学习器</strong>模型被训练成使用来自Kaggle的信用卡欺诈检测数据集来预测高风险或欺诈性交易，可从这里获得:<a href="https://www.kaggle.com/mlg-ulb/creditcardfraud/data">https://www.kaggle.com/mlg-ulb/creditcardfraud/data</a>。请随意使用以下链接查看本笔记本:<a href="https://github.com/aws/amazon-sagemaker-examples/blob/master/scientific_details_of_algorithms/linear_learner_class_weights_loss_functions/linear_learner_class_weights_loss_functions.ipynb">https://github . com/AWS/Amazon-sage maker-examples/blob/master/scientific _ details _ of _ algorithms/linear _ learner _ class _ weights _ loss _ functions/linear _ learner _ class _ weights _ loss _ functions . ipynb</a>。</li>
			</ul>
			<p>有了这些笔记本，以及本章中的食谱，我们需要知道，我们可以使用<strong class="bold">线性学习器</strong>算法来训练可用于(1)回归、(2)二元分类和(3)多类分类的模型。更多信息可以随意参考以下链接:<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/linear-learner.html">https://docs . AWS . Amazon . com/sage maker/latest/DG/linear-learner . html</a>。</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>使用Python中的Apache MXNet加载线性学习者模型</h1>
			<p>在前面的<a id="_idIndexMarker124"/>配方中，我们使用<strong class="bold"> SageMaker Python SDK </strong>运行了一个训练<a id="_idIndexMarker125"/>作业。在这个菜谱中，我们将使用<strong class="bold"> Apache MXNet </strong>和<strong class="bold">胶子</strong>来加载<a id="_idIndexMarker126"/>模型，提取其参数，并在本地执行预测。如果你<a id="_idIndexMarker127"/>想知道<strong class="bold"> Gluon </strong>是什么，它与<strong class="bold"> Apache MXNet </strong>有什么不同，Gluon是深度学习的高级API，而<strong class="bold"> Apache MXNet </strong>是深度学习框架<a id="_idIndexMarker128"/>，通常用<strong class="bold"> TensorFlow </strong>和<strong class="bold"> PyTorch </strong>来分类<a id="_idIndexMarker129"/>:</p>
			<div><div><img src="img/B16850_01_40.jpg" alt="Figure 1.40 – Using Apache MXNet to load the model and extract the parameters of the model&#13;&#10;" width="967" height="213"/>
				</div>
			</div>
			<p class="figure-caption">图1.40–使用Apache MXNet加载模型并提取模型的参数</p>
			<p>也就是说，这个菜谱的目的是展示在训练步骤之后上传到亚马逊S3存储桶的模型文件可以使用<strong class="bold"> Apache MXNet </strong>进行加载和分析，如图<em class="italic">图1.40 </em>所示:</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>做好准备</h2>
			<p>以下是这个食谱的先决条件:</p>
			<ul>
				<li>这份食谱延续了<em class="italic">用Python </em>训练你的第一个模型。确保您已经完成了该配方中的步骤，因为我们将需要model_data的值。</li>
				<li>使用conda_mxnet_p36内核的新笔记本。</li>
			</ul>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>怎么做……</h2>
			<p>对于这个<a id="_idIndexMarker130"/>食谱，我们需要一个新的<a id="_idIndexMarker131"/>笔记本和<a id="_idIndexMarker132"/>使用conda_mxnet_p36内核来完成这个食谱。步骤如下:</p>
			<ol>
				<li value="1">If you have not created a new notebook using the conda_mxnet_p36 kernel yet, create a new notebook inside the my-experiments/chapter01 directory and rename it to the title of this recipe. We will run the code in the next set of steps inside this notebook.<p class="callout-heading">注意</p><p class="callout">这和使用conda_python3内核的笔记本有什么区别？使用conda_mxnet_p36内核的笔记本已经可以利用<strong class="bold"> Apache MXNet </strong>深度学习框架，而不必单独安装这个。</p></li>
				<li>Load model_data using the %store magic. If you can still recall, we used the %store magic to save the model_data value in the <em class="italic">Training your first model in Python</em> recipe:<pre><strong class="bold">%store -r</strong> model_data
model_data</pre><p>我们应该会得到一个类似于' S3://<s3 bucket="" name="">/chapter 01/output/linear-learner-2021-03-13-02-23-18-930/output/model . tar . gz '的值。model.tar.gz档案里有什么？它包含SageMaker培训作业后生成的模型文件。</s3></p></li>
				<li>使用下面的代码块准备SageMaker会话。我们将在下一步使用S3Downloader.download()函数时使用session对象:<pre>import sagemaker  <strong class="bold">session</strong> = sagemaker.Session()</pre></li>
				<li>使用<strong class="bold"> SageMaker Python SDK </strong>中的<a id="_idIndexMarker133"/>S3 downloader . download()函数来<a id="_idIndexMarker134"/>从S3下载<a id="_idIndexMarker135"/>model.tar.gz文件到my-experiments/chapter01目录下的tmp目录:<pre>from sagemaker.s3 import S3Downloader <strong class="bold">S3Downloader.download</strong>(s3_uri=model_data,                       local_path="tmp/",                       sagemaker_session=session)</pre></li>
				<li>Quickly check what is inside the tmp directory with the help of the ls command:<pre>!ls <strong class="bold">tmp</strong></pre><p>我们应该在my-experiments/chapter01/tmp目录中看到model.tar.gz文件。</p><p>接下来的指令将允许我们提取model.tar.gz文件的内容。</p></li>
				<li>Extract the contents of the downloaded model.tar.gz file using the tar command:<pre>!tar -xzvf tmp/<strong class="bold">model.tar.gz</strong></pre><p>我们应该得到一个类似于model_algo-1的值。</p></li>
				<li>Unzip the results of the previous step (model_algo-1):<pre>!unzip <strong class="bold">model_algo-1</strong></pre><p>运行解压缩操作后，您应该会在同一个目录中看到一组类似的model_algo-1解压缩文件:</p><div><img src="img/B16850_01_41.jpg" alt="Figure 1.41 – Extracted model output files after using the tar and unzip commands&#13;&#10;" width="541" height="165"/></div><p class="figure-caption">图1.41–使用tar和unzip命令后提取的模型输出文件</p><p>在<em class="italic">图1.41 </em>中，我们可以看到model_algo-1内部有几个文件——additional-params . JSON、mx-mod-symbol.json、mx-mod-0000.params和manifest.json。</p><p>随着<a id="_idIndexMarker136"/>模型文件已经从<a id="_idIndexMarker138"/>model.tar.gz文件中提取<a id="_idIndexMarker137"/>，我们现在将提取线性回归模型的权重和偏差值。</p></li>
				<li>导入mxnet和其他所需的库和函数:<pre>import <strong class="bold">mxnet</strong>       from mxnet import <strong class="bold">gluon</strong> from json import load as <strong class="bold">json_load</strong> from json import dumps as <strong class="bold">json_dumps</strong></pre></li>
				<li>从zip文件的提取内容中加载模型:<pre>sym_json = json_load(open('<strong class="bold">mx-mod-symbol.json</strong>')) sym_json_string = json_dumps(sym_json)       model = gluon.nn.SymbolBlock(         outputs=mxnet.sym.load_json(           sym_json_string         ),         inputs=mxnet.sym.var('data'))       model.load_parameters(     '<strong class="bold">mx-mod-0000.params</strong>',      allow_missing=True)</pre></li>
				<li>初始化<a id="_idIndexMarker139"/>模型和<a id="_idIndexMarker140"/>准备<a id="_idIndexMarker141"/>局部预测功能。mxnet_predict()函数简单地利用我们在前面的步骤中加载的模型来获得x的每个指定值的y值:<pre>model.initialize()       def <strong class="bold">mxnet_predict</strong>(x, model=model):     return model(mxnet.nd.array([x]))[0].asscalar()</pre></li>
				<li>Perform predictions using the mxnet_predict() function:<pre><strong class="bold">mxnet_predict</strong>(42)</pre><p>我们应该得到一个类似于1226.6005的值。稍后，当我们运行<em class="italic">在Python </em> recipe中部署您的第一个模型时，我们将看到它与推理端点返回的结果相匹配。</p></li>
				<li>定义extract_weight_and_bias()函数。该函数接受MXNet线性模型并返回权重和偏差:<pre>def <strong class="bold">extract_weight_and_bias</strong>(model):     params = model.collect_params()     weight = params['fc0_weight'].data()[0].asscalar()     bias = params['fc0_bias'].data()[0].asscalar()          return {         "weight": weight,         "bias": bias     }</pre></li>
				<li>Extract the <em class="italic">weight</em> and the <em class="italic">bias</em> of the linear regression model using the extract_weight_and_bias() function defined in the previous step:<pre>weight_and_bias = <strong class="bold">extract_weight_and_bias(model)</strong>
weight_and_bias</pre><p>我们<a id="_idIndexMarker142"/>应该得到一个类似于<a id="_idIndexMarker144"/>的值<a id="_idIndexMarker143"/>到{'weight': 8.219234，' bias': 881.3926}。</p></li>
				<li>使用%store魔法保存weight_and_bias的值:<pre><strong class="bold">%store</strong> weight_and_bias</pre></li>
				<li>Finally, let's clean up a bit by deleting the files extracted from model.tar.gz:<pre>%%bash
rm -f <strong class="bold">additional-params.json</strong>
rm -f <strong class="bold">manifest.json</strong>
rm -f <strong class="bold">model_algo-1</strong>
rm -f <strong class="bold">mx-mod-symbol.json</strong>
rm -f <strong class="bold">mx-mod-0000.params</strong></pre><p>随着这个菜谱中的步骤的完成，我们已经证明了使用SageMaker来训练我们的模型不会阻止我们加载和分析由训练作业产生的模型工件。</p></li>
			</ol>
			<p>现在让我们看看这个食谱是如何工作的！</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>工作原理……</h2>
			<p>在这个菜谱中，我们使用<strong class="bold"> Apache MXNet </strong>来加载模型并执行本地预测。我们还提取了线性回归模型的参数值(例如，权重和偏差)，并使用这些参数值创建了我们自己的预测函数。</p>
			<p class="callout-heading">重要说明</p>
			<p class="callout">加载训练模型的方法取决于所使用的算法以及该算法的版本。例如，如果用<strong class="bold"> XGBoost </strong>算法训练一个模型，那么得到的模型应该由相应的XGBoost Python库加载。</p>
			<p>首先，<a id="_idIndexMarker145"/>方法可能有点令人生畏，但是我们简单地从训练作业创建的文件中加载了模型及其参数。这个反序列化的模型允许我们在Jupyter笔记本中本地执行预测和额外的分析，而不必依赖于部署的推理端点资源。</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/>评估Python中的模型</h1>
			<p>在之前的<a id="_idIndexMarker148"/>配方中，我们已经使用<strong class="bold">线性学习器</strong>算法<a id="_idIndexMarker149"/>训练了回归模型，并使用<strong class="bold"> MXNet </strong>和<strong class="bold">胶子</strong>加载了模型。在训练步骤之后，需要对模型进行评估，并且需要将结果和度量值与其他模型进行比较。<strong class="bold">模型评估</strong>是ML过程的关键部分，因为这有助于我们找到最佳模型，该模型将用于对未来未知值进行预测。这个方法的目的是在评估回归模型时提供一组简化的步骤。</p>
			<p>使用Python编程语言，我们将在原始散点图上生成回归线的可视化，并使用相关指标(例如，<strong class="bold">均方根误差(RMSE)、均方误差(MSE)和平均绝对误差(MAE) </strong>)评估ML模型</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>做好准备</h2>
			<p>以下是这个食谱的先决条件:</p>
			<ul>
				<li>这个方法继续从<em class="italic">用Python </em>中的Apache MXNet加载线性学习者模型。确保您已经完成了该配方中的步骤，因为我们将需要weight_and_bias的值以及Python中以前配方的值。</li>
				<li>使用conda_python3内核的新笔记本。</li>
			</ul>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>怎么做……</h2>
			<p>第一组步骤<a id="_idIndexMarker150"/>集中于从之前的配方和<a id="_idIndexMarker151"/>笔记本中加载保存的数据:</p>
			<ol>
				<li value="1">如果您还没有使用conda_python3内核创建一个新的笔记本，请在my-experiments/chapter01目录中创建一个新的笔记本，并将其重命名为这个食谱的标题。我们将在笔记本的下一组步骤中运行代码。</li>
				<li>Use the %store magic to load the weight_and_bias value from the <em class="italic">Loading a linear learner model with Apache MXNet in Python</em> recipe:<pre>%store -r <strong class="bold">weight_and_bias</strong>
weight_and_bias</pre><p>我们应该得到一个类似于{'weight': 8.219234，' bias': 881.3926}的值。</p></li>
				<li>Similarly, load the df_all_data value from the <em class="italic">Training your first model in Python</em> recipe:<pre>%store -r <strong class="bold">df_all_data</strong>
df_all_data</pre><p>这将向我们显示一个类似于<em class="italic">图1.42 </em>所示数值的数据框架:</p><div><img src="img/B16850_01_42.jpg" alt="Figure 1.42 – df_all_data&#13;&#10;" width="409" height="566"/></div><p class="figure-caption">图1.42–df _ all _ data</p><p>我们有<a id="_idIndexMarker152"/>df _ all _ data数据帧，如<em class="italic">图1.42 </em>所示。%store magic的好处在于它可以处理大多数简单的可序列化值，比如数据帧、字典和字符串。这使我们能够将CSV文件中的df_all_data值加载到<em class="italic">在Python </em>中可视化和理解您的数据，并且我们可以在不同的笔记本中继续使用df_all_data，而不必再次从CSV文件中加载数据。</p></li>
				<li>Use the %store magic to load the X_test value from the <em class="italic">Training your first model in Python</em> recipe:<pre>%store -r <strong class="bold">X_test</strong>
X_test</pre><p>我们应该得到一个类似于array([32，61，37，59，14，22])的X_test值。</p></li>
				<li>We also load the value for y_test:<pre>%store -r <strong class="bold">y_test</strong>
y_test</pre><p>我们应该得到一个类似于array([1090，1330，1300，1430，1090，1040])的y_test值。</p></li>
				<li>定义manual_predict()函数。我们将利用这一点，使用提取的权重和偏差来执行预测。manual_predict()函数<a id="_idIndexMarker154"/>类似于<em class="italic">中的mxnet_predict()函数，使用Python </em>方法中的Apache MXNet加载线性学习者模型，除了<a id="_idIndexMarker155"/>我们使用权重和偏差直接计算y的值，而不是直接使用模型进行推断:<pre>def <strong class="bold">manual_predict</strong>(x, weight_and_bias=weight_and_bias):     params = weight_and_bias      return params['weight'] * x + params['bias']</pre></li>
				<li>Use the manual_predict() function to perform a sample prediction:<pre>manual_predict(42)</pre><p>我们应该会得到一个类似于1226的值。36866 . 68868688686请注意，在使用Python 方法中的Apache MXNet加载线性学习者模型的<em class="italic">中的mxnet_predict()函数后，我们得到了类似的结果。</em></p></li>
				<li>Generate the regression line DataFrame and store it inside regression_line_df. Note that the code after the equals (=) symbol belongs to the same line and should not be treated as if it were a separate line of code (in case certain statements from the following code block get rendered as multiple lines because of the length of the command):<pre>import pandas as pd
<strong class="bold">regression_line_df</strong> = pd.DataFrame(
    list(range(0, 121)), 
    columns=['management_experience_months']
)
     
<strong class="bold">regression_line_df</strong>['monthly_salary'] = <strong class="bold">manual_predict</strong>(regression_line_df['management_experience_months'])</pre><p>在前面的<a id="_idIndexMarker156"/>代码块中，我们生成了一个从<a id="_idIndexMarker157"/> 1到121的数字列表。然后，我们使用manual_predict()函数来计算连续每个月的管理经验的预测月薪。</p></li>
				<li>Inspect the records of the generated regression line DataFrame:<pre>regression_line_df</pre><p>运行前面的代码行将呈现数据帧，显示management_experience_months列中每个值对应的monthly_salary值:</p><div><img src="img/B16850_01_43.jpg" alt="Figure 1.43 – Regression line DataFrame (showing 5 records out of 121 total records)&#13;&#10;" width="1049" height="266"/></div><p class="figure-caption">图1.43-回归线数据框(显示121条记录中的5条)</p><p>在<em class="italic">图1.43 </em>中，我们可以看到包含回归线的x和y值的数据框。</p><p>在下一组步骤中，我们将重点关注在散点图顶部呈现回归线，显示所有数据集点:</p></li>
				<li>导入matplotlib: <pre>%matplotlib inline import matplotlib.pyplot as plt</pre></li>
				<li>Generate<a id="_idIndexMarker158"/> the visualization of the regression line with the <a id="_idIndexMarker159"/>original scatter plot chart:<pre>plt.rcParams["figure.figsize"] = (8,8)
plt.<strong class="bold">scatter</strong>(
    df_all_data.management_experience_months,   
    df_all_data.monthly_salary
)
r_line = regression_line_df
plt.<strong class="bold">plot</strong>(r_line['management_experience_months'],  
         r_line['monthly_salary'], 
         color='red', 
         linewidth=3)
plt.xlabel('Management Experience (Months)', fontsize=18)
plt.ylabel('Monthly Salary (USD)', fontsize=16)
plt.xlim(0, 120)
plt.ylim(0, 2400)</pre><p>一旦您执行了上一步中的代码块，您将在来自源CSV文件的数据点散点图的顶部获得一个表示模型的折线图:</p><div><img src="img/B16850_01_44.jpg" alt="Figure 1.44 – Visualization of the regression line on top of the original scatter plot &#13;&#10;" width="950" height="885"/></div><p class="figure-caption">图1.44–原始散点图顶部回归线的可视化</p><p>在<em class="italic">图1.44 </em>中，我们<a id="_idIndexMarker160"/>可以从<em class="italic">可视化和理解Python </em>配方中的数据中看到散点图<a id="_idIndexMarker161"/>顶部的回归线。</p><p>在该配方的最后一组步骤中，我们将计算模型评估度量值<strong class="bold"> RMSE </strong>、<strong class="bold"> MSE </strong>和<strong class="bold"> MAE: </strong>。</p></li>
				<li>从scikit-learn导入度量工具:<pre>from sklearn import metrics import numpy as np</pre></li>
				<li>View the records in the test dataset:<pre>df_test_data = pd.DataFrame({
    'monthly_salary': y_test,
    'management_experience_months': X_test
})
df_test_data</pre><p>运行前面的代码块会给我们一个类似于<em class="italic">图1.45 </em>所示的数据帧:</p><div><img src="img/B16850_01_45.jpg" alt="Figure 1.45 – df_test_data&#13;&#10;" width="488" height="278"/></div><p class="figure-caption">图1.45–测向测试数据</p><p>在<em class="italic">图1.45 </em>中，我们有df_test_data数据帧。它应该包含从数据集中随机选择的6条记录。如果你还记得我们在<em class="italic">用Python </em>训练你的第一个模型时做了什么，我们执行了训练-测试分割，分配14条记录给训练数据集，6条记录给测试集。</p></li>
				<li>使用manual_predict()函数从测试数据集中计算每一行<a id="_idIndexMarker163"/>的<a id="_idIndexMarker162"/>预测月薪。将结果存储在test_pred变量中。到目前为止，我们只在本章的每个食谱中使用了训练数据。现在，我们将使用测试数据作为训练模型的输入来计算每行的预测月薪:<pre>test_pred = <strong class="bold">manual_predict</strong>(     df_test_data['management_experience_months'] )</pre></li>
				<li>Compute for <strong class="bold">RMSE</strong>, <strong class="bold">MSE</strong>, and <strong class="bold">MAE</strong> by using and comparing the predicted values from the actual values for the monthly salary data:<pre>np.<strong class="bold">sqrt</strong>(metrics.<strong class="bold">mean_squared_error</strong>(df_test_data['monthly_salary'], test_pred))
metrics.<strong class="bold">mean_squared_error</strong>(df_test_data['monthly_salary'], test_pred)
metrics.<strong class="bold">mean_absolute_error</strong>(df_test_data['monthly_salary'], test_pred)</pre><p>我们应该得到类似如下的值:RMSE 73.2016，MSE 5358.4791，MAE 66.8494。</p></li>
			</ol>
			<p>现在让我们看看这个食谱是如何工作的！</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>工作原理……</h2>
			<p>一旦我们有了模型，我们必须在看不见的数据上评估它，比如测试集。模型评估步骤允许我们了解ML模型的性能，并将其与解决同类问题的其他模型进行比较。</p>
			<p>为了帮助我们理解我们的模型是如何执行和表现的，我们使用matplotlib生成了带有原始散点图的<a id="_idIndexMarker164"/>回归线的可视化。有了测试数据，我们就有了实际月薪值和<a id="_idIndexMarker165"/>模型预测的月薪值。根据这两个值，我们生成了<strong class="bold"> RMSE </strong>、<strong class="bold"> MSE </strong>和<strong class="bold"> MAE </strong>的评估度量值。这些评估指标衡量我们的模型对不属于训练数据的数据的预测程度。通过这些度量，我们可以比较我们构建和训练的其他模型的性能，以便我们可以评估哪个模型更好。</p>
			<p class="callout-heading">重要说明</p>
			<p class="callout">评估指标<a id="_idIndexMarker167"/>RMSE、MSE和MAE 之间的<a id="_idIndexMarker166"/>区别是什么？与MAE相比，RMSE和MSE惩罚更大的变化。当处理带有异常值的数据集时，MAE可能是更好的选择。</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>还有更多…</h2>
			<p>当处理非常大的数据集时，我们可以<a id="_idIndexMarker169"/>使用<strong class="bold"> SageMaker处理</strong>，这样我们就可以使用专用的ML实例来运行计算模型评估度量值的脚本。这只是<strong class="bold"> SageMaker处理</strong>的应用和可能的用例之一，因为它也可用于数据准备和特征工程。</p>
			<h1 id="_idParaDest-54">在Python中部署您的第一个模型</h1>
			<p>在之前的配方中，我们<a id="_idIndexMarker170"/>执行了模型评估步骤。在这个配方中，我们<a id="_idIndexMarker171"/>将使用<strong class="bold"> SageMaker Python SDK </strong>将<strong class="bold">线性学习器</strong>模型部署到推理端点。什么是推理端点？推理端点是一个web应用程序端点，它(1)接受一组<a id="_idIndexMarker172"/>值作为输入(例如，x值/秒)，(2)加载训练模型，(3)使用训练模型使用输入预测值，最后，(4)以首选格式返回预测值。</p>
			<p>部署模型后，我们将使用示例management_experience_months值用一些测试预测来测试推断端点。我们应该在一秒或更短的时间内获得相应的预测月薪值！</p>
			<h2 id="_idParaDest-55">正在准备中</h2>
			<p>这个配方上接<em class="italic">评估Python </em>配方中的模型。确保您已经完成了该配方中的步骤以及<em class="italic">在Python </em>配方中训练您的第一个模型，因为我们将需要该配方中的model_data和model_uri的值。</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>怎么做……</h2>
			<p>下一组步骤集中在部署我们在前面的配方中训练和评估的模型:</p>
			<ol>
				<li value="1">如果您还没有使用conda_python3内核创建一个新的笔记本，请在my-experiments/chapter01目录中创建一个新的笔记本，并将其重命名为这个食谱的标题。我们将在笔记本的下一组步骤中运行代码。</li>
				<li>Use the %store magic to read the value of model_data. Remember that we saved the value of model_data in the <em class="italic">Training your first model in Python</em> recipe:<pre><strong class="bold">%store -r</strong> model_data
model_data</pre><p>我们应该会得到一个类似于' S3://<bucket name="">/chapter 01/output/linear-learner-2021-03-13-02-23-18-930/output/model . tar . gz '的值。</bucket></p></li>
				<li>Similarly, read the value of model_uri:<pre>%store -r <strong class="bold">model_uri</strong>
model_uri</pre><p>我们应该得到一个类似于' 382416733822 . dkr . ECR . us-east-1 . Amazon AWS . com/linear-learner:1 '的值。</p></li>
				<li>导入并加载<a id="_idIndexMarker173"/>几个先决条件，包括角色和会话:<pre>import sagemaker  from sagemaker import get_execution_role        <strong class="bold">role</strong> = get_execution_role() <strong class="bold">session</strong> = sagemaker.Session()</pre></li>
				<li>初始化一个sagemaker.model.Model对象，使用model_uri、model_data、role和session作为<a id="_idIndexMarker174"/>参数值:<pre>from sagemaker.model import Model model = <strong class="bold">Model</strong>(image_uri=model_uri,                model_data=model_data,               role=role,               sagemaker_session=session)</pre></li>
				<li>Set predictor_cls of the model to sagemaker.predictor.Predictor:<pre>from sagemaker.predictor import Predictor
model.predictor_cls = Predictor</pre><p>如果设置了predictor_cls，在下一步中调用deploy()函数将返回一个predictor对象。否则，调用deploy()函数后将不会返回Predictor对象。</p></li>
				<li>Call the deploy() function to deploy the <strong class="bold">Linear Learner</strong> model to an inference endpoint: <pre>predictor = model.deploy(
    initial_instance_count=1, 
    instance_type='ml.m5.xlarge', 
    endpoint_name="<strong class="bold">linear-learner-python</strong>")</pre><p>请随意<a id="_idIndexMarker175"/>指定<a id="_idIndexMarker176"/>首选端点名称值。</p><p class="callout-heading">重要说明</p><p class="callout">运行deploy()函数将启动一个实例，该实例将继续运行，直到执行删除资源操作。当实例运行时，您将为它运行的时间付费。完成本章后，请确保删除推理端点。完成本章后，您可以使用predictor.delete_endpoint()删除推理端点。请注意，在本章的最后一个配方中，<em class="italic">从boto3 </em>调用带有SageMakerRuntime客户端的Amazon SageMaker模型端点，我们需要激活推理端点。也就是说，您可以在完成该配方后删除推理端点。</p></li>
				<li>更新预测器的序列化程序和反序列化程序配置。在我们的预测器对象中更新这些属性会改变序列化器和反序列化器的属性，以便对来自推理端点的数据进行编码和解码:<pre>from sagemaker.serializers import CSVSerializer from sagemaker.deserializers import JSONDeserializer predictor.serializer = <strong class="bold">CSVSerializer</strong>() predictor.deserializer = <strong class="bold">JSONDeserializer</strong>()</pre></li>
				<li>Perform a sample prediction using the predict() function:<pre>predictor.<strong class="bold">predict</strong>("42")</pre><p>我们应该得到一个结构和预测值类似于{ ' predictions ':[{ ' score ':126.60438671875 }]}的返回值。这应该与我们在使用Python 配方中的Apache MXNet加载线性学习者模型的<em class="italic">中的mxnet_predict()函数后得到的结果相匹配。</em></p></li>
				<li>Finally, let's <a id="_idIndexMarker177"/>try passing two management_experience_months values in our <a id="_idIndexMarker178"/>payload:<pre>predictor.predict(<strong class="bold">["42", "81"]</strong>) </pre><p>我们应该得到一个返回值，其结构和预测值类似于{ ' predictions ':[{ ' score ':1226.6004638671875 }，{ ' score ':15134765625 }]}。假设我们在有效负载中提供了两个management_experience_months值，那么我们在响应中也得到了两个预测的monthly_salary值。</p></li>
				<li>Delete the endpoint using the delete_enpoint() function:<pre>predictor.<strong class="bold">delete_endpoint()</strong> </pre><p>这将删除已部署的推理端点。当然，一旦我们运行了这行代码，我们将不再能够使用predict()函数。在删除端点之前，请随意尝试一下。如果您继续使用本章中boto3 方法中的SageMakerRuntime客户端<em class="italic">调用Amazon SageMaker模型端点，推理端点需要正在运行，所以暂时不要删除端点。如果您不小心删除了端点，您也可以按照这个方法中的步骤并通过调用deploy()函数来再次部署端点。</em></p></li>
			</ol>
			<p>请注意，有不同的方法来执行预测，但我们将在本书的后面讨论其他选项。现在，让我们深入了解<em class="italic">它是如何工作的… </em>部分！</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>工作原理……</h2>
			<p>在这个配方中，我们<a id="_idIndexMarker179"/>使用了来自<strong class="bold"> SageMaker Python SDK </strong>的模型和预测器类来部署<a id="_idIndexMarker180"/>我们在<em class="italic">用Python </em>配方训练您的第一个模型中训练的模型。</p>
			<p>下面是每次我们使用deploy()函数时SageMaker在内部执行的步骤:</p>
			<ol>
				<li value="1">当我们使用deploy()函数时，<strong class="bold"> SageMaker </strong>提供了一个新的ML实例来运行容器。在这个容器中，一旦部署步骤完成，推理web服务器就开始运行。推理web服务器只是为接受预测值(例如，x-管理经验的月数)并返回预测值(例如，y-薪水)的web端点提供服务</li>
				<li>在幕后，SageMaker从S3 bucket下载模型文件。然后，模型由充当推理端点的web服务器加载。</li>
				<li>ML实例中的容器公开了API端点，这允许我们发送包含预测变量的有效负载(例如，management_experience_months)并接收包含预测值的响应(例如，monthly_salary)</li>
			</ol>
			<p>您可能想知道为什么我们在使用estimator.fit()之后没有直接使用estimator.deploy()。在接下来的章节和食谱中，我们将使用这种方法。在这一章中，我们必须意识到幕后发生了什么，因为我们试图消除这样一种看法，即我们正在使用<strong class="bold">亚马逊SageMaker </strong>和<strong class="bold"> SageMaker Python SDK </strong>处理一个黑盒。</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>使用boto3中的SageMakerRuntime客户端调用Amazon SageMaker模型端点</h1>
			<p>使用SageMaker托管的<a id="_idIndexMarker182"/>服务将我们的模型<a id="_idIndexMarker181"/>部署在推理端点中，我们现在可以使用boto3中的SageMakerRuntime客户端来调用<a id="_idIndexMarker183"/>端点。这将帮助我们使用boto3或类似的SDK在任何应用程序代码中调用SageMaker推断端点。例如，我们可以在<a id="_idIndexMarker184"/>一个<strong class="bold"> AWS Lambda </strong>函数和<strong class="bold"> Amazon API Gateway </strong>中使用它来<a id="_idIndexMarker185"/>构建一个无服务器的API端点，该端点接受一个HTTP请求，该请求包含一个专业人员的管理经验的月数，并返回一个包含该个人的预测月薪的响应。</p>
			<p>在这个菜谱中，我们将使用boto3中SageMakerRuntime客户端的invoke_endpoint()函数来触发一个现有的SageMaker推断端点。我们可以使用来自<em class="italic">在Python </em>中部署您的第一个模型的部署端点。</p>
			<h2 id="_idParaDest-59">做好准备</h2>
			<p>这份食谱是从<em class="italic">在Python中部署你的第一个模型</em>开始的。我们需要一个运行中的SageMaker推理端点来完成这个菜谱。</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>怎么做……</h2>
			<p>下一组步骤集中于调用现有的SageMaker推理端点:</p>
			<ol>
				<li value="1">如果您还没有使用conda_python3内核创建一个新的笔记本，请在my-experiments/chapter01目录中创建一个新的笔记本，并将其重命名为这个食谱的标题。我们将在笔记本的下一组步骤中运行代码。</li>
				<li>用<strong class="bold"> Boto3 </strong> : <pre>import boto3 sagemaker_client = boto3.client('<strong class="bold">sagemaker-runtime</strong>')</pre>加载<a id="_idIndexMarker186"/>SageMakerRuntime客户端</li>
				<li>指定<a id="_idIndexMarker187"/>端点。如果您的<a id="_idIndexMarker188"/>端点有不同的名称，请随意修改下面的代码行。在这个菜谱中，我们将使用我们在<em class="italic">中部署的端点，在Python中部署您的第一个模型</em>菜谱:<pre>endpoint = '<strong class="bold">linear-learner-python</strong>'</pre></li>
				<li>将42个字符串值设置为有效载荷:<pre>payload="42"</pre></li>
				<li>使用invoke_endpoint()函数触发SageMaker推理端点:<pre>response = sagemaker_client.<strong class="bold">invoke_endpoint</strong>(     EndpointName=endpoint,      ContentType='text/csv',      Body=payload)</pre></li>
				<li>Inspect the structure and contents of response:<pre>response</pre><p>我们将得到一个类似于<em class="italic">图1.46 </em>所示的响应值:</p><div><img src="img/B16850_01_46.jpg" alt="Figure 1.46 – Response return value after using the invoke_endpoint() function&#13;&#10;" width="980" height="284"/></div><p class="figure-caption">图1.46–使用invoke_endpoint()函数后的响应返回值</p><p>正如我们<a id="_idIndexMarker189"/>在<em class="italic">图1.46 </em>中看到的，Body的值不是一个<a id="_idIndexMarker190"/>字符串。它被botocore的StreamingBody包裹着。StreamingBody是一个HTTP响应体的包装类，它提供了一些便利的功能。我们还可以看到，InvokedProductionVariant的值是AllTraffic。因为我们处理的是单一模型部署，所以这是预期值。当使用生产变量处理多个部署的模型时，该值会根据调用的模型而变化。</p></li>
				<li>Finally, we use the following code block to convert the StreamingBody object to a dictionary:<pre>import json
result = <strong class="bold">json.loads</strong>(
    response['Body'].read().decode('utf-8')
)
result</pre><p>运行这段代码后，我们应该会得到类似于{ ' predictions ':[{ ' score ':1209.7744140625 }]}的结构和值。</p></li>
			</ol>
			<p>现在，让我们看看这是如何工作的！</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>工作原理……</h2>
			<p>在这个<a id="_idIndexMarker192"/>配方中，我们演示了如何使用boto3中的SageMakerRuntime客户端来触发现有的SageMaker推断端点<a id="_idIndexMarker193"/>。以下是一些建立在我们食谱基础上的<a id="_idIndexMarker194"/>解决方案:</p>
			<ul>
				<li>boto3 + <strong class="bold"> AWS Lambda </strong> + <strong class="bold">亚马逊API网关</strong>(无服务器REST API)</li>
				<li>boto 3+<strong class="bold">AWS Lambda</strong>+<strong class="bold">AWS app sync</strong>(无服务器GraphQL API)</li>
				<li>boto3 + <strong class="bold">烧瓶</strong>网络框架</li>
				<li>boto3 + <strong class="bold"> Django </strong> web框架</li>
				<li>boto3 + <strong class="bold">芹菜</strong> + <strong class="bold"> RabbitMQ </strong></li>
			</ul>
			<p>假设boto3和SageMakerRuntime客户端为调用SageMaker API提供了一个低级抽象层，那么在将AWS SDKs用于其他语言(如Java、JavaScript、PHP、Go、C++)时，本方法中使用的相同技术和概念也适用。NET和Ruby。例如，如果我们需要从一个使用Ruby的应用程序中触发SageMaker推断端点，我们需要做的就是使用用于Ruby的<strong class="bold">AWS SDK</strong>和<a id="_idIndexMarker195"/>使用invoke_endpoint()函数，其行为或多或少与boto3中的invoke_endpoint()函数相同。你可以查看<a href="https://docs.aws.amazon.com/sdk-for-ruby/v2/api/Aws/SageMakerRuntime/Client.html">https://docs . Aws . Amazon . com/SDK-for-ruby/v2/API/Aws/SageMakerRuntime/client . html</a>了解更多信息。其他编程语言的AWS SDKs也应该有类似的参考。</p>
			<p class="callout-heading">重要说明</p>
			<p class="callout">既然我们已经完成了本章，我们可以使用predictor.delete_endpoint()删除在<em class="italic">在Python </em>中部署您的第一个模型中部署的现有推理端点，或者通过用户界面(<strong class="bold">推理</strong> &gt; <strong class="bold">端点</strong>)删除它。</p>
		</div>
	</div>
</body></html>