<html><head/><body>





<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style>
<div><div><h1 id="_idParaDest-224"><em class="italic"> <a id="_idTextAnchor267"/>第五章</em>:有效管理机器学习实验</h1>
			<p>在前一章中，我们研究了几个方法，重点是在将数据作为输入传递给培训作业之前准备和处理数据。在这一章中，我们将重点关注不同的解决方案和功能，以帮助我们管理<strong class="bold">机器学习</strong> ( <strong class="bold"> ML </strong>)在<strong class="bold">亚马逊SageMaker </strong>中的实验。</p>
			<p>一旦我们进行了一定数量的ML实验，我们就会意识到，并不是所有的实验都成功，建立高质量的ML模型需要一点试错。这有点类似于软件开发，在软件开发中，需要尽可能早地检测代码中的错误，以防止这些错误意外地部署到生产环境中。与调试软件代码中的问题相比，调试ML实验通常要困难得多，因为我们需要一个专门的工具来检查和监控实验中参数、度量和其他变量的值的变化，并在满足特定规则或条件时执行指定的动作。在运行分布式培训作业时，这个工具在处理ML实例集群时也非常有用。好消息是<strong class="bold"> SageMaker调试器</strong>是我们正在寻找的专用工具！</p>
			<p>除了使用正确的工具调试ML实验之外，数据科学和ML工程团队积极跟踪数据集、超参数以及多个ML实验的其他输入和输出值也至关重要。这将允许数据科学家和ML实践者轻松访问以前的ML实验，而不必花费大量时间试图大海捞针。也就是说，我们还有更多好消息要告诉你— <strong class="bold"> SageMaker Experiments </strong>可以帮助我们跟踪和管理越来越多的实体。</p>
			<p>在本章中，我们将演示如何使用<strong class="bold"> SageMaker调试器</strong>来检测我们培训工作中的问题。之后，我们将使用SageMaker实验来同时管理和跟踪多个实验。我们还将在示例ML实验中检查使用这些功能时生成的日志和实体。一旦我们非常熟悉本章中讨论的服务、工具和技术，我们将能够轻松地管理和调试多个ML实验。</p>
			<p>我们将在本章中介绍以下配方:</p>
			<ul>
				<li>分类问题的合成数据生成</li>
				<li>识别SageMaker调试器的问题</li>
				<li>检查SageMaker调试器日志和结果</li>
				<li>使用SageMaker实验运行和管理多个实验</li>
				<li>SageMaker实验的实验分析</li>
				<li>使用SageMaker实验检查实验、试验和试验组件</li>
			</ul>
			<p>随着您开始使用SageMaker进行更多的ML实验，您会发现本章中的配方非常有用，因为它们将帮助您管理和审核正在进行或已完成的ML实验。</p>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor268"/>技术要求</h1>
			<p>要执行本章中的配方，请确保您具备以下条件:</p>
			<ul>
				<li>正在运行的Amazon SageMaker笔记本实例(例如ml.t2.large)</li>
				<li>一个亚马逊S3桶</li>
			</ul>
			<p>如果您还没有准备好这些先决条件，请随时查看第1章  <em class="italic">中的<em class="italic">启动亚马逊SageMaker笔记本实例</em>和<em class="italic">准备亚马逊S3桶和线性回归实验的训练数据集</em>食谱，使用亚马逊SageMaker </em>开始机器学习。</p>
			<p>由于本章中的食谱涉及到一些代码，我们已经在这个资源库中提供了这些脚本和笔记本:<a href="https://github.com/PacktPublishing/Machine-Learning-with-Amazon-SageMaker-Cookbook/tree/master/Chapter05">https://github . com/packt publishing/Machine-Learning-with-Amazon-sage maker-Cookbook/tree/master/chapter 05</a>。</p>
			<div><div><img src="img/B16850_05_01.jpg" alt="Figure 5.1 – Machine-Learning-with-Amazon-SageMaker-Cookbook GitHub repository&#13;&#10;" width="1649" height="830"/>
				</div>
			</div>
			<p class="figure-caption">图5.1-机器学习与亚马逊-SageMaker-Cookbook GitHub知识库</p>
			<p>如<em class="italic">图5.1 </em>所示，我们在第05章目录中组织了本章食谱的脚本和笔记本的源代码。在开始本章的每一个食谱之前，确保my-experiments/chapter05目录已经准备好。如果它还没有被创建，请现在就创建，因为这样可以在我们浏览本书中的每一个食谱时保持事物的有序性。</p>
			<div><div><img src="img/B16850_05_02.jpg" alt="Figure 5.2 – Machine-Learning-with-Amazon-SageMaker-Cookbook GitHub repository&#13;&#10;" width="1382" height="614"/>
				</div>
			</div>
			<p class="figure-caption">图5.2-机器学习-亚马逊-SageMaker-Cookbook GitHub知识库</p>
			<p>在<em class="italic">图5.2 </em>中，我们可以看到页面左上角<strong class="bold">上传</strong>按钮旁边的<strong class="bold">新增</strong>按钮。要在my-experiments目录下创建一个新目录，点击<strong class="bold"> New </strong>按钮，在下拉选项列表中选择<strong class="bold">文件夹</strong>创建一个新目录。我们将在本章的这个目录中使用conda_python3内核创建多个Jupyter笔记本。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">由于我们在本章的食谱中没有使用<em class="italic">本地模式</em>，我们可以在SageMaker Studio笔记本中对食谱进行技术处理。如果你想知道我们将在本书中何时开始使用<strong class="bold"> SageMaker Studio </strong>，请不要担心，因为我们将在亚马逊SageMaker 的<a href="B16850_06_Final_ASB_ePub.xhtml#_idTextAnchor435"> <em class="italic">第6章</em> </a>、<em class="italic">自动机器学习中正确介绍和设置它。</em></p>
			<p>也就是说，让我们开始学习本章的食谱吧！</p>
			<p>请点击以下链接查看动作视频中的相关代码:</p>
			<p>【https://bit.ly/2YAwHMl】</p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor269"/>分类问题的综合数据生成</h1>
			<p>在这个配方中，我们<a id="_idIndexMarker933"/>将使用scikit-learn生成一个合成的<a id="_idIndexMarker934"/>数据集。该数据集将作为本章分类问题的虚拟数据集。该数据集只有三列——标签、a和b。在<em class="italic">图5.3 </em>中，我们有一个数据集的散点图，显示了按标签值分组的两组点:</p>
			<div><div><img src="img/B16850_05_03.jpg" alt="Figure 5.3 – Synthetic dataset for binary classification problems&#13;&#10;" width="792" height="526"/>
				</div>
			</div>
			<p class="figure-caption">图5.3–二元分类问题的合成数据集</p>
			<p>我们将把这个数据集分成训练、验证和测试数据集，并把它们上传到亚马逊S3桶。一旦我们准备好了它们，我们就可以在使用SageMaker调试器和SageMaker实验的同时运行ML实验。</p>
			<p class="callout-heading">小费</p>
			<p class="callout">由于我们将在这个配方中展示如何生成合成数据集的步骤，我们将有机会在以后调整这个配方以满足我们的需要。我们可以决定让这个数据集为label = 0生成更多的记录，并使用SageMaker调试器来检测生成的数据集是否存在类不平衡问题。我们将在<a href="B16850_07_Final_ASB_ePub.xhtml#_idTextAnchor602"> <em class="italic">第7章</em> </a>、<em class="italic">使用SageMaker特征库、SageMaker Clarify和SageMaker模型监视器</em>中的<em class="italic">使用SageMaker Clarify检测预训练偏差</em>方法中讨论类别不平衡以及其他ML偏差问题。在本章的以下配方中，我们将使用SageMaker调试器LossNotDecreasing规则来监控和检测正在运行的训练作业的目标指标的减少量(使用在该配方中生成的数据集)是否小于我们指定的阈值。</p>
			<h2 id="_idParaDest-227">准备就绪</h2>
			<p>以下是<a id="_idIndexMarker935"/>这个配方<a id="_idIndexMarker936"/>的先决条件:</p>
			<ul>
				<li>正在运行的Amazon SageMaker笔记本实例(例如ml.t2.large)</li>
			</ul>
			<h2 id="_idParaDest-228">我该怎么做…</h2>
			<p>此配方中的第一组步骤主要是设置包含生成的合成数据集的x和y值的数据框:</p>
			<ol>
				<li>导航到SageMaker笔记本实例中的my-experiments/chapter05目录。如果这个目录还不存在，请随意创建。</li>
				<li>在my-experiments/chapter05目录下使用conda_python3内核创建一个新的笔记本，用这个菜谱的名字命名(也就是分类问题的合成数据生成)。打开此笔记本进行编辑，因为我们将在接下来的几个步骤中使用代码更新此文件。</li>
				<li>使用scikit-learn中的make_blobs()函数生成一个可用于分类问题的数据集:<pre>from sklearn.datasets import <strong class="bold">make_blobs</strong> X, y = <strong class="bold">make_blobs</strong>(n_samples=5000, centers=2,                    cluster_std=[6, 4], n_features=2,                    random_state=40)<a id="_idTextAnchor272"/></pre></li>
				<li>Using<a id="_idIndexMarker937"/> the X and y variables <a id="_idIndexMarker938"/>from the previous step, create a pandas DataFrame with three columns: label, a, and b:<pre>import pandas as pd
<strong class="bold">all_dataset</strong> = pd.DataFrame(
    dict(label=y, a=X[:,0], b=X[:,1]))
     
print(<strong class="bold">all_dataset</strong>)</pre><p><em class="italic">图5.4 </em>向我们展示了运行前面的代码块后的输出:</p><div><img src="img/B16850_05_04.jpg" alt="Figure 5.4 – Dataset containing all the records after using the make_blobs() function&#13;&#10;" width="606" height="510"/></div><p class="figure-caption">图5.4–使用make_blobs()函数后包含所有记录的数据集</p><p>在<em class="italic">图5.4 </em>中，我们可以看到在all_dataset数据帧中，我们有三列——label，包含1和0，a和b，包含浮点值<a id="_idTextAnchor273"/>。</p></li>
				<li>Generate <a id="_idIndexMarker939"/>a scatterplot <a id="_idIndexMarker940"/>of all_dataset with the following lines of code:<pre>from matplotlib import pyplot
     
colors = {0:'red', 1:'blue'}
fig, ax = pyplot.subplots()
<strong class="bold">grouped</strong> = <strong class="bold">all_dataset.groupby('label')</strong>
     
for key, group in grouped:
    group.plot(ax=ax, kind='scatter', 
               x='a', y='b', 
               label=key, 
               color=colors[key])
    
pyplot.show()</pre><p>这将生成一个类似于<em class="italic">图5.5 </em>所示的散点图:</p><div><img src="img/B16850_05_05.jpg" alt="Figure 5.5 – Synthetic dataset for classification problems&#13;&#10;" width="792" height="526"/></div><p class="figure-caption">图5.5–分类问题的合成数据集</p><p>在<em class="italic">图5.5 </em>中，我们使用matplotlib生成了all_dataset的散点图。</p><p>既然我们<a id="_idIndexMarker941"/>已经生成了合成的<a id="_idIndexMarker942"/>数据集，我们将在将生成的训练、验证和测试数据集上传到亚马逊S3 buc <a id="_idTextAnchor274"/> ket之前执行训练-测试分割。</p></li>
				<li>Perform the train-test split step and get the training, validation, and test datasets:<pre>from sklearn.model_selection import <strong class="bold">train_test_split</strong>
     
train_val, test = <strong class="bold">train_test_split</strong>(all_dataset, 
                                   test_size=0.2, 
                                   random_state=0)
training, validation = <strong class="bold">train_test_split</strong>(
    train_val, 
    test_size=0.25, 
    random_state=0)</pre><p>这将为训练数据集提供3，000条记录，为验证数据集提供1，000条记录，为测试数据集<a id="_idTextAnchor275"/>提供1，000条记录。</p></li>
				<li>Inspect the training dataset by running the next line of code:<pre>training</pre><p>这将显示类似于图5.6 中<em class="italic">所示的数据帧:</em></p><div><img src="img/B16850_05_06.jpg" alt="Figure 5.6 – Training dataset with 3,000 records&#13;&#10;" width="456" height="730"/></div><p class="figure-caption">图5.6–包含3，000条记录的训练数据集</p><p><em class="italic">图5.6 </em>向<a id="_idIndexMarker943"/>用户展示了<a id="_idIndexMarker944"/>训练数据集的快速视图。注意，这个数据集有3000条记录，是all_dat <a id="_idTextAnchor276"/> aset中记录总数的60%。</p></li>
				<li>Inspect the validation dataset by running the next line of code:<pre>validation</pre><p>这将为我们提供一个类似于图5.7 所示的数据框架:</p><div><img src="img/B16850_05_07.jpg" alt="Figure 5.7 – Validation dataset with 1,000 records&#13;&#10;" width="480" height="732"/></div><p class="figure-caption">图5.7–包含1，000条记录的验证数据集</p><p><em class="italic">图5.7 </em>向<a id="_idIndexMarker945"/>用户展示了<a id="_idIndexMarker946"/>验证数据集的快速视图。请注意，该数据集有1，000条记录，占re <a id="_idTextAnchor277"/>记录总数的20%。</p></li>
				<li>Inspect the test dataset by running the next line of code:<pre>test</pre><p>这将给我们一个类似于图5.8 所示的数据框架:</p><div><img src="img/B16850_05_08.jpg" alt="Figure 5.8 – Test dataset with 1,000 records&#13;&#10;" width="462" height="722"/></div><p class="figure-caption">图5.8–包含1000条记录的测试数据集</p><p><em class="italic">图5.8 </em>向我们展示了<a id="_idIndexMarker947"/>测试<a id="_idIndexMarker948"/>数据集的快速视图。注意，这个数据集有1000条记录，占all_d <a id="_idTextAnchor278"/>数据集中记录总数的20%。</p></li>
				<li>使用mkdir Bash命令:<pre>!mkdir<a id="_idTextAnchor279"/> -p <strong class="bold">tmp</strong></pre>生成一个名为tmp的临时目录</li>
				<li>接下来，使用to_csv()函数从训练、验证和测试数据帧中生成一个csv文件:<pre><strong class="bold">training</strong>.to_csv('tmp/training_data.csv', header=False, index=False) <strong class="bold">validation</strong>.to_csv('tmp/validation_data.csv', header=False, index=False) <strong class="bold">test</strong>.to_csv('tmp/test_data.csv', header=False, index<a id="_idTextAnchor280"/>=False)</pre></li>
				<li>Use the <strong class="bold">AWS CLI</strong> Bash commands to<a id="_idIndexMarker949"/> copy the CSV files to our target S3 path. Make sure to replace the value of "&lt;insert S3 bucket name here&gt;" with the name of the bucket we have created in the <em class="italic">Preparing the Amazon S3 bucket and the training dataset for the linear regression experiment</em> recipe from <a href="B16850_01_Final_ASB_ePub.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a><em class="italic">, Getting Started with Machine Learning Using Amazon SageMaker</em>:<pre>s3_bucket = "<strong class="bold">&lt;insert S3 bucket name here&gt;</strong>"
prefix = "chapter05"
path = f"s3://{s3_bucket}/{prefix}/input"
!aws s3 cp tmp/training_data.csv {path}/<strong class="bold">training_data.csv</strong>
!aws s3 cp tmp/validation_data.csv {path}/<strong class="bold">validation_data.csv</strong>
!aws s3 cp tmp/test_data.csv {path}/<strong class="bold">test_data.csv</strong></pre><p>这将把训练、验证和测试数据集的CSV文件上传到S3存储桶中。</p></li>
			</ol>
			<p>让我们看看这是如何工作的！</p>
			<h2 id="_idParaDest-229">它是如何工作的…</h2>
			<p>在这个配方中，我们<a id="_idIndexMarker950"/>已经使用make_blobs()函数<a id="_idIndexMarker951"/>为分类问题生成了一个合成数据集。让我们描述一下调用这个函数时可以使用的几个选项:</p>
			<ul>
				<li>n_samples:样本数</li>
				<li>cluster_std:分类的标准偏差</li>
				<li>n_features:特征数量</li>
				<li>random_state:使操作可重现的随机状态值</li>
			</ul>
			<p>我们生成的数据集有三列——标签、a和b。我们在构建二元分类器时的目标是使用记录的a和b值来预测标签值。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">在现实生活的数据集和例子中，a和b可以很容易地映射到一个或多个预测变量。这方面的一个例子是使用乳房肿块图像的属性(例如周长均值、面积均值、凹度最差)来检测肿瘤是良性还是恶性。</p>
			<p>在生成包含5000条记录的数据集<a id="_idIndexMarker952"/>之后，我们<a id="_idIndexMarker953"/>已经使用了两次train_test_split()函数来获得训练、验证和测试集。我们对这些数据集进行了60-20-20的分割。然后，我们将这些数据集上传到目标S3桶中。稍后，当我们使用<em class="italic">识别SageMaker调试器</em>和<em class="italic">运行和管理SageMaker实验</em>配方的多个实验时，将会用到这些。</p>
			<p>如果您想知道我们可以使用哪些算法来使用该数据集训练分类器，这里有一些算法:</p>
			<ul>
				<li><strong class="bold">XGBoost</strong>with objective = ' binary:logistic '</li>
				<li><strong class="bold">线性学习器</strong>，带有预测器类型=‘二元分类器’</li>
				<li><strong class="bold">因子分解机</strong>带有预测器类型=‘二元分类器’</li>
				<li>使用自定义容器图像的自定义算法(例如，<strong class="bold">支持向量机</strong></li>
			</ul>
			<p>在这些选项中，我们将在后续的菜谱中使用XGBoost来解决我们的二进制分类问题。</p>
			<h2 id="_idParaDest-230">还有更多……</h2>
			<p>我们可以对这个食谱进行哪些调整来产生这个数据集的变体？</p>
			<ul>
				<li>我们可以(显著地)生成更多的记录，并测试后续配方中使用的算法的性能。根据数据集的大小，训练期间的问题可能会出现，也可能不会出现，所以这是我们完成本章后您可以尝试的事情。</li>
				<li>我们可以向生成的数据集中添加更多的列。例如，通过修改make_blobs()函数中传递的参数值，我们可以生成40个预测列，而不是只有2个预测列。同样，由于这一变化，训练期间可能会出现一些问题，我们希望检查某些SageMaker调试器规则是否可以用于检测这些问题。</li>
			</ul>
			<p>记住这些，让我们继续利用这个合成数据集的食谱吧！</p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor284"/>识别SageMaker调试器的问题</h1>
			<p>Amazon SageMaker <a id="_idIndexMarker954"/>调试器是Amazon SageMaker更强大的<a id="_idIndexMarker955"/>功能之一，可以帮助我们管理我们的ML实验。借助SageMaker调试器，我们可以使用<strong class="bold">调试器规则</strong>自动检测问题并分析培训工作。然后我们<a id="_idIndexMarker956"/>能够消除这些问题和瓶颈，这将有助于缩短培训时间并显著降低成本。SageMaker调试器还可以用来监控培训作业的硬件资源使用情况。此功能有助于显著降低成本，因为我们能够分析培训工作，及早检测硬件资源使用导致的问题，并优化培训时间和资源使用。<strong class="bold"> SageMaker调试器</strong>支持<strong class="bold"> XGBoost </strong>、<strong class="bold"> PyTorch </strong>、<strong class="bold"> TensorFlow </strong>、<strong class="bold"> MXNet </strong>等ML框架和算法。</p>
			<p>有几个内置的调试器规则可供选择。这些规则包括(但不限于)VanishingGradient、PoorWeightInitialization、ExplodingTensor、DeadRelu和LossNotDecreasing规则。在大多数情况下，我们可以用这些规则配置SageMaker Debugger，而不需要对我们的定制培训脚本进行任何更改。</p>
			<p>在这个方法中，我们将使用SageMaker调试器LossNotDecreasing规则来监视和检测使用XGBoost内置算法的训练作业的目标度量的减少是否小于我们指定的阈值。</p>
			<p class="callout-heading">小费</p>
			<p class="callout">使用SageMaker调试器是免费的！通常，我们只根据计算和存储资源的使用情况为其付费。这意味着我们将为使用SageMaker调试器时启动的<strong class="bold"> SageMaker处理</strong>作业(几分钟)付费。更多信息，请参考这里的定价页面:<a href="https://aws.amazon.com/sagemaker/pricing/">https://aws.amazon.com/sagemaker/pricing/</a>。</p>
			<h2 id="_idParaDest-232">做好准备</h2>
			<p>下面的<a id="_idIndexMarker957"/>是该配方的<a id="_idIndexMarker958"/>先决条件:</p>
			<ul>
				<li>该配方上接<em class="italic">分类问题<a id="_idTextAnchor287"/>合成数据生成</em>。</li>
			</ul>
			<h2 id="_idParaDest-233">如何去做…</h2>
			<p>以下说明向我们展示了如何使用SageMaker调试器来检测我们的训练作业中的问题，包括几行代码:</p>
			<ol>
				<li value="1">导航到SageMaker笔记本实例中的my-experiments/chapter05目录。如果这个目录还不存在，请随意创建。</li>
				<li>在my-experiments/chapter05目录中使用conda_python3内核创建一个新的笔记本，并用这个配方的名称命名它(也就是用SageMaker调试器识别问题)。打开此笔记本进行编辑，因为我们将在接下来的几个步骤中使用代码更新该文件。</li>
				<li>使用下面几行代码导入并准备一些先决条件，如session、role_arn、boto3和get_execution_role()函数:<pre>import <strong class="bold">sagemaker</strong>  import <strong class="bold">boto3</strong> from sagemaker import <strong class="bold">g<a id="_idTextAnchor291"/>et_execution_role</strong>  <strong class="bold">role_arn</strong> = get_execution_role() <strong class="bold">session</strong> = sa<a id="_idTextAnchor292"/>gemaker.Session()</pre></li>
				<li>Specify <a id="_idIndexMarker959"/>the S3 location of the training, validation, and<a id="_idIndexMarker960"/> test CSV files. Make sure to replace the value of "&lt;insert S3 bucket name here&gt;" with the name of the bucket we created in the <em class="italic">Preparing the Amazon S3 bucket and the training dataset for the linear regression experiment</em> recipe from <a href="B16850_01_Final_ASB_ePub.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Machine Learning Using Amazon SageMaker</em>:<pre>s3_bucket = '<strong class="bold">&lt;insert S3 bucket name here&gt;</strong>'
prefix = "chapter05"
path = f"s3://{s3_bucket}/{prefix}/input"
     
training_path = f"{path}/training_data.csv" 
validation_path = f"{path}/validation_data.csv" </pre><p>请注意，s3_bucket值应与本章中用于分类问题的<em class="italic">合成数据集生成</em> reci <a id="_idTextAnchor293"/> pe的值相同。</p></li>
				<li>使用retrieve()函数获取XGBoost容器映像的ECR存储库URI:<pre>from sagemaker.image_uris import <strong class="bold">retrieve</strong> container = <strong class="bold">retrieve</strong>('xgboost',                       boto3.Session().region_name,                     <a id="_idTextAnchor294"/>  version="0.90-2")</pre></li>
				<li>在我们的实验中，导入并初始化使用SageMaker调试器的先决条件:<pre>from sagemaker.debugger import <strong class="bold">rule_configs</strong> from sagemaker.debugger import <strong class="bold">Rule</strong>  from sagemaker.debugger import <strong class="bold">DebuggerHookConfig</strong> from sagemaker.debugger import <strong class="bold">CollectionConfig</strong>       save_interval = 2 prefix = "debugger" bucket_path = 's3://{}/{}'.format<a id="_idTextAnchor295"/>(s3_bucket, prefix)</pre></li>
				<li>Initialize <a id="_idIndexMarker961"/>and <a id="_idIndexMarker962"/>configure the CollectionConfig and DebuggerHookConfig objects:<pre><strong class="bold">metrics_collection_config</strong> = <strong class="bold">CollectionConfig</strong>(
    name="metrics",
    parameters={
        "save_interval": str(save_interval)
    })
     
<strong class="bold">debugger_hook_config</strong> = <strong class="bold">DebuggerHookConfig</strong>(
    s3_output_path=bucket_path,  
    collection_configs=[<strong class="bold">metrics_collection_config</strong>]
)</pre><p>这里，我们指定要收集的数据以及其他配置参数。</p><p class="callout-heading">注意</p><p class="callout">有关SageMaker调试器可用的内置集合的完整列表<a id="_idIndexMarker963"/>，请随意查看<a href="https://github.com/awslabs/sagemaker-debugger/blob/master/docs/api.md#built-in-collections">https://github . com/aw slabs/sage maker-Debugger/blob/master/docs/API . MD #内置集合</a>。</p></li>
				<li>使用下面几行代码准备<a id="_idIndexMarker964"/>SageMaker调试器<a id="_idIndexMarker965"/>规则:<pre><strong class="bold">loss_not_decreasing_rule</strong> = Rule.sagemaker(     <strong class="bold">rule_configs.loss_not_decreasing()</strong>,     rule_parameters={         "collection_names": "metrics",         "diff_percent": "5",         "num_steps": "2",     }, ) rules = [<strong class="bold">l<a id="_idTextAnchor297"/>oss_not_decreasing_rule</strong>]</pre></li>
				<li>Next, initialize the Estimator function:<pre>estimator = sagemaker.estimator.Estimator( 
    role=role_arn,
    instance_count=1,
    instance_type='ml.m5.xlarge',
    image_uri=container,
    debugger_hook_config=<strong class="bold">debugger_hook_config</strong>,
    rules=<strong class="bold">rules</strong>,
    sagemaker_session=session)</pre><p>注意，我们在这个菜谱中使用XGBoost作为内置算法。当使用XGBoost作为内置算法时，我们不会使用SageMaker Python SDK中的XGBoost类，因为它是在使用开源XGBoost算法时使用的。</p><p class="callout-heading">注意</p><p class="callout">我们可以使用XGBoost作为内置算法，或者使用开源的XGBoost算法，这涉及到编写自定义的训练脚本。有关XGBoost内置算法的更多信息，请随意查看<a id="_idIndexMarker966"/>以下链接获取更多信息:<a href="https://sagemaker.readthedocs.io/en/stable/frameworks/xgboost/using_xgboost.html">https://sagemaker . readthe docs . io/en/stable/frameworks/XGBoost/using _ XGBoost . html</a>。</p></li>
				<li>使用set_hyperparameters()函数:<pre>estimator.<strong class="bold">set_hyperparameters</strong>(max_depth=16,                              objective='binary:logistic',                    <a id="_idTextAnchor299"/>          num_round=10000)</pre>指定<a id="_idIndexMarker967"/>超参数<a id="_idIndexMarker968"/></li>
				<li>使用TrainingInput: <pre>from sagemaker.inputs import <strong class="bold">TrainingInput</strong> s3_input_training = <strong class="bold">TrainingInput</strong>(     training_path, content_type="text/csv") s3_input_validation = <strong class="bold">TrainingInput</strong>(     validation_pat<a id="_idTextAnchor300"/>h, content_type="text/csv")</pre>为培训工作准备输入</li>
				<li>使用fit()函数开始训练步骤。请注意，wait参数被设置为False，这允许我们在训练作业运行时运行下面的步骤:<pre>estimator.<strong class="bold">fit</strong>({'train': s3_input_training,                'validation': s3_input_validation},<a id="_idTextAnchor301"/>                <strong class="bold">wait=False</strong>)</pre></li>
				<li>导入、初始化和加载打印规则作业摘要的一些先决条件:<pre>import time job_name = <strong class="bold">estimator.latest_training_job.name</strong> client = \ estimator.sagemaker_session.sagemaker_client print("Job Name:", job_name) <strong class="bold">EVALUATION_STOP_STATES</strong> = [     "Stopped", "IssuesFound",     <a id="_idTextAnchor302"/> "NoIssuesFound", "Error" ]</pre></li>
				<li>Define<a id="_idIndexMarker969"/> the display_rule_job_summary() function. This function will help display the details of<a id="_idIndexMarker970"/> the SageMaker Processing job running the SageMaker Debugger rule logic:<pre>def <strong class="bold">display_rule_job_summary</strong>(rule_job_summary):
    break_after_this = False 
     
    for rule_job in rule_job_summary:
        rj = rule_job
        rule_name = rj["<strong class="bold">RuleConfigurationName</strong>"]
        es = rj["<strong class="bold">RuleEvaluationStatus</strong>"]
        evaluation_status = es
        print("Rule [{}]: {}".format(
            rule_name, evaluation_status))
     
        <strong class="bold">if evaluation_status == 'IssuesFound'</strong>:
            summary = rule_job_summary[0]
            sd = summary['StatusDetails']        
            status_details = sd
            print("{}".format(status_details))
            
        stopped = es in EVALUATION_STOP_STATES
        np = 'ProfilerReport' not in rule_name
        not_profiler = np
     
        if stopped and not_profiler:
            break_after_this = True
            
    return break_after_this</pre><p>我们将在下一步中使用<a id="_idIndexMarker971"/>该函数来<a id="_idIndexMarker972"/>帮助我们查看SageMaker调试器作业是否检测到了违反LossNotDecreasing规则的情况<a id="_idTextAnchor303"/>。</p></li>
				<li>Run the <a id="_idIndexMarker973"/>following lines of code to <a id="_idIndexMarker974"/>display the status of the training and processing jobs. The describe_training_job() function accepts the training job name and returns the details and metadata associated with the training job. Inside this loop, we also make use of the display_rule_job_summary() function to help us extract and print a quick summary of <a id="_idIndexMarker975"/>the rule job and the current status of the training job:<pre>for _ in range(200):
    description = client.<strong class="bold">describe_training_job</strong>(
        TrainingJobName=job_name
    )
    ts = description["TrainingJobStatus"]
    training_job_status = ts
    print("\nTraining job Status: {}".format(
          training_job_status))
    latest_job = estimator.latest_training_job
    rule_job_summary = latest_job.rule_job_summary()
    break_after_this = <strong class="bold">display_rule_job_summary</strong>(
        rule_job_summary
    )
    if break_after_this:
        break
     
    time.sleep(10)</pre><p><em class="italic">图5.9 </em>显示了<a id="_idIndexMarker976"/>运行前一个代码块后打印日志的某一部分:</p><div><img src="img/B16850_05_09.jpg" alt="Figure 5.9 – Logs showing the status of the training and processing jobs&#13;&#10;" width="907" height="586"/></div><p class="figure-caption">图5.9–显示培训和处理作业状态的日志</p><p>我们可以在<em class="italic">图5.9 </em>中看到前面代码块中的循环生成的日志。此日志摘要包括培训作业状态和LossNotDecreasing规则作业状态。</p><p class="callout-heading">重要说明</p><p class="callout">这个步骤可能需要30多分钟才能完成，所以在等待的时候，请随意阅读<em class="italic">它是如何工作的……</em>和<em class="italic">这个食谱还有更多……</em>部分。你也可以继续学习本章的后续食谱！</p><p>大约在<a id="_idIndexMarker977"/> 30分钟后，我们应该看到<a id="_idIndexMarker978"/>在作业摘要日志的末尾检测到违反了LossNotDecreasing规则。</p></li>
				<li>使用%store magic存储调试器工件的S3路径。我们将在上半年使用这个<em class="italic">检查SageMaker调试器日志和结果</em>配方:<pre>e = estimator ap = e.<strong class="bold">latest_job_debugger_artifacts_path</strong>() artifacts_path = ap %store <strong class="bold">artifacts_path</strong></pre></li>
				<li>Similarly, store the rule job summary dictionary value using %store magic as well. We will use this in the second half of the <em class="italic">Inspecting SageMaker Debugger logs and results</em> recipe:<pre>rjs = e.latest_training_job.rule_job_summary()
rule_job_summary = rjs
%store <strong class="bold">rule_job_summary</strong></pre><p>我们<a id="_idIndexMarker979"/>将在<em class="italic">检查SageMaker调试器日志和结果</em>配方中使用稍后<a id="_idIndexMarker980"/>的rule_job_summary的值。</p><p class="callout-heading">注意</p><p class="callout">SageMaker培训和SageMaker处理作业在后台提供的ML实例在这些作业完成时会自动删除。这意味着我们不必像在其他章节中那样手动关闭正在运行的资源。就成本而言，我们将只支付作业运行的时间。有关这方面的更多信息，请随时查看定价计算器以及这里提供的定价示例:<a href="https://aws.amazon.com/sagemaker/pricing/">https://aws.amazon.com/sagemaker/pricing/</a>。</p></li>
			</ol>
			<p>现在，让我们看看这是如何工作的！</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor305"/>工作原理……</h2>
			<p>在这个菜谱中，我们使用了SageMaker调试器来帮助我们检测培训工作中的问题。它的工作方式是在训练步骤中收集调试数据，并在处理和分析调试数据时检查是否满足某些规则条件。</p>
			<p>让我们定义一些东西，以便我们能够理解SageMaker调试器是如何工作的:</p>
			<ul>
				<li><strong class="bold">调试器挂钩</strong>:在训练步骤中捕获<a id="_idIndexMarker981"/>调试数据(例如，train-error、validation-error)。在初始化Estimator时，我们可以用一个或多个CollectionConfig对象指定DebuggerHookConfig。</li>
				<li><strong class="bold">调试器规则</strong>:代码<a id="_idIndexMarker982"/>检测是否满足某些条件。当执行训练步骤时，规则处理容器将自动处理调试数据并识别是否发现问题。请注意，在初始化估计器时，我们可以指定任意多的规则。</li>
			</ul>
			<p>一旦<a id="_idIndexMarker983"/>调试器钩子和调试器规则<a id="_idIndexMarker984"/>配置已经准备好并在初始化评估器对象时作为参数值传递，我们需要做的就是调用fit()函数来启动训练作业。</p>
			<div><div><img src="img/B16850_05_10.jpg" alt="Figure 5.10 – What happens behind the scenes when using SageMaker Debugger&#13;&#10;" width="1351" height="805"/>
				</div>
			</div>
			<p class="figure-caption">图5.10–使用SageMaker调试器时，幕后发生了什么</p>
			<p>参考<em class="italic">图5.10 </em>快速查看使用SageMaker调试器时幕后发生的情况。让我们详细讨论每个步骤，看看它是如何工作的:</p>
			<ol>
				<li value="1">当估计器的fit()函数被调用时，一个或多个ML训练实例被启动以开始训练作业。</li>
				<li>SageMaker将使用调试器规则容器来检查和监控训练作业，从而启动SageMaker处理作业。有关SageMaker处理作业的更多信息，请随意查看第4章 、<em class="italic">准备、处理和分析数据</em>中的<em class="italic">使用Python </em>中的SageMaker处理管理的数据处理<a href="B16850_04_Final_ASB_ePub.xhtml#_idTextAnchor200"> <em class="italic">。</em></a></li>
				<li>基于<a id="_idIndexMarker985"/>DebuggerHookConfig的配置方式，在每个间隔的指定数量的步骤后，某些值，如损耗、重量和梯度<a id="_idIndexMarker986"/>被提取并存储在S3中。</li>
				<li>一旦上一步的数据在S3可用，来自<em class="italic">步骤2 </em>的SageMaker处理任务将运行配置的规则逻辑并检查是否违反了规则。</li>
				<li>触发<strong class="bold">云监控事件</strong>。</li>
			</ol>
			<p>请注意，我们可以使用AWS Lambda进行快速集成，以帮助我们对SageMaker调试器触发的CloudWatch事件做出反应，并停止正在运行的培训作业。有关如何实现这一点的更多信息，请随时查看<a href="https://github.com/aws/amazon-sagemaker-examples/blob/master/sagemaker-debugger/tensorflow_action_on_rule/tf-mnist-stop-training-job.ipynb">https://github . com/AWS/Amazon-sage maker-examples/blob/master/sage maker-debugger/tensor flow _ action _ on _ rule/TF-Mn ist-stop-training-job . ipynb</a>。</p>
			<h2 id="_idParaDest-235">还有更多…</h2>
			<p>您可能想知道为什么有第二个规则作业使用ProfilerReport前缀运行，即使我们在初始化Estimator对象时只指定了LossNotDecreasing规则。这是因为SageMaker调试器默认运行ProfilerReport规则来生成分析报告。生成的分析报告从每个工作节点的训练作业摘要和系统使用统计开始。</p>
			<div><div><img src="img/B16850_05_11.jpg" alt="Figure 5.11 – Profiler report rules summary&#13;&#10;" width="1505" height="939"/>
				</div>
			</div>
			<p class="figure-caption">图5.11–探查器报告规则摘要</p>
			<p>它还会提供调试器内置规则<a id="_idIndexMarker987"/>的概要，类似于图5.11 中的<em class="italic">所示。请随意查看<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-profiling-report.html">https://docs . AWS . Amazon . com/sage maker/latest/DG/debugger-profiling-report . html</a>了解更多信息。</em></p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor307"/>亦见</h2>
			<p>如果我们想要创建和使用一个定制规则，我们可以使用SageMaker Python SDK中的Rule.custom()函数。创建自定义规则超出了本书的范围，因此我们将在此提供一些参考和示例:</p>
			<ul>
				<li>使用SageMaker调试器自定义规则训练TensorFlow Keras模型:<a href="https://sagemaker-examples.readthedocs.io/en/latest/sagemaker-debugger/tensorflow_keras_custom_rule/tf-keras-custom-rule.html">https://sage maker-examples . readthe docs . io/en/latest/sage maker-Debugger/tensor flow _ Keras _ custom _ rule/TF-Keras-custom-rule . html</a></li>
				<li>使用SageMaker调试器自定义规则运行迭代<a id="_idIndexMarker989"/>模型修剪:<a href="https://github.com/aws/amazon-sagemaker-examples/blob/master/sagemaker-debugger/pytorch_iterative_model_pruning/iterative_model_pruning_alexnet.ipynb">https://github . com/AWS/Amazon-sage maker-examples/blob/master/sage maker-Debugger/py torch _ iterative _ model _ pruning/iterative _ model _ pruning _ Alex net . ipynb</a></li>
			</ul>
			<p>有关<a id="_idIndexMarker990"/>为培训工作分析创建定制调试器规则的更多信息，请随时查看<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-custom-rules.html">https://docs . AWS . Amazon . com/sage maker/latest/DG/debugger-custom-rules . html</a>。</p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor308"/>检查SageMaker调试器日志和结果</h1>
			<p>在前面的配方中，我们使用SageMaker调试器<a id="_idIndexMarker992"/>来帮助我们检测训练作业运行时的违规情况。在这个菜谱中，我们将使用smdebug库、AWS CLI工具和awslogs命令行工具来检查SageMaker调试器生成的文件和日志。当调试SageMaker调试器本身的结果时，这将非常有用。</p>
			<p>有时，如果我们有一个错误配置的SageMaker调试器，我们可能最终会得到NoIssuesFound结果，即使已经满足了某些DebuggerRule条件。也就是说，重要的是我们知道如何调试我们的设置，以及在哪里查找由SageMaker调试器生成的文件。</p>
			<h2 id="_idParaDest-238">做好准备</h2>
			<p>以下是该配方的先决条件:</p>
			<ul>
				<li>本配方延续了<em class="italic">中的<a id="_idTextAnchor311"/>确定SageMaker调试器</em>的问题。</li>
			</ul>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor312"/>怎么做……</h2>
			<p>以下说明向我们展示了检查由SageMaker调试器处理作业生成的文件和日志的步骤:</p>
			<ol>
				<li value="1">导航到SageMaker笔记本实例中的my-experiments/chapter05目录。如果这个目录还不存在，请随意创建。</li>
				<li>在my-experiments/chapter05目录中使用conda_python3内核创建一个新的笔记本，并用这个配方的名称命名它(即检查SageMaker调试器日志和结果)。打开此笔记本进行编辑，因为我们将在接下来的几个步骤中使用代码更新此文件。</li>
				<li>使用%store magic <a id="_idIndexMarker993"/>命令加载artifacts_path的值<a id="_idIndexMarker994"/>。请注意，我们将该值存储在IPython的数据库中的<em class="italic"> Insp <a id="_idTextAnchor313"/>检查SageMaker调试器日志和结果</em>配方:<pre>%store -r artifacts_path</pre></li>
				<li>使用pip install安装smdebug:<pre>!pip install smdebug</pre></li>
				<li>Import create_trial and run the create_trial() function with the path of the artifacts generated by SageMaker Debugger:<pre>from smdebug.trials import <strong class="bold">create_trial</strong>
trial = <strong class="bold">create_trial</strong>(artifacts_path)</pre><p>这个试验对象让我们查询培训作业的张量，我们将在下一组步骤中看到。</p></li>
				<li>Use the tensor_names() function to list the available tensors of the trial:<pre>trial.<strong class="bold">tensor_names</strong>()</pre><p>运行前一行代码将返回一个包含训练错误和验证错误字符串值的列表。</p></li>
				<li>使用试验对象的bucket_name和prefix_name属性准备target_path变量。target_path变量指向包含调试输出文件的S3路径:<pre>target_path<a id="_idTextAnchor316"/> = f"s3://{trial.bucket_name}/{trial.prefix_name}"</pre></li>
				<li>Use the AWS CLI to show all the files inside the target S3 path:<pre>s3_contents = !aws s3 ls {target_path} --recursive
s3_contents</pre><p>这将产生一组<a id="_idIndexMarker995"/>结果，类似于图5<em class="italic">中的<a id="_idIndexMarker996"/>。<a id="_idTextAnchor317"/> 12 </em>:</p><div><img src="img/B16850_05_12.jpg" alt="Figure 5.12 – SageMaker Debugger output files &#13;&#10;" width="1524" height="586"/></div><p class="figure-caption">图5.12–sage maker调试器输出文件</p><p><em class="italic">图5.12 </em>向我们展示了使用aws s3 ls命令后t <a id="_idTextAnchor318"/> h <a id="_idTextAnchor319"/> e目标S3路径中的一些文件。</p></li>
				<li>Copy the path of one of the files in the previous step and store it inside the chosen_fullpath variable:<pre>chosen_path = s3_contents[-1].split(" ")[-1]
chosen_fullpath = f"s3://{trial.bucket_name}/{chosen_path}"</pre><p>chosen _ fullpath变量应该包含指向JSON文件的S3路径。</p></li>
				<li>如果tm <a id="_idTextAnchor320"/> p目录尚不存在，则创建该目录:<pre>!mkdir -p <strong class="bold">tmp</strong></pre></li>
				<li>使用AWS CLI将文件从S3直接复制到tmp<a id="_idTextAnchor321"/>ory:<pre>!aws s3 cp {chosen_fullpath} tmp/worker_0.json</pre></li>
				<li>Inspect the contents of the file<a id="_idTextAnchor322"/> we just downloaded from S3:<pre>!cat tmp/worker_0.json</pre><p>我们应该得到一个类似于图5.13 所示的JSON值:</p><div><img src="img/B16850_05_13.jpg" alt="Figure 5.13 – JSON value inside worker_0.json&#13;&#10;" width="1377" height="107"/></div><p class="figure-caption">图5.13–worker _ 0 . JSON中的JSON值</p><p>我们在<em class="italic">图5.13 </em>中有<a id="_idIndexMarker997"/>我们<a id="_idIndexMarker998"/>从S3桶<a id="_idTextAnchor323"/> <a id="_idTextAnchor324"/>下载的JSON文件的值，包含SageMaker调试器生成的日志。</p></li>
				<li>Run the following lines of code to print the train-error and validation-error tensor values:<pre>for i in <strong class="bold">[2, 4, 6, 8, 10, 12, 14, 16]</strong>:
    traint = trial.tensor("<strong class="bold">train-error</strong>")
    train_error = traint.value(i)[0]
    <strong class="bold">train_error</strong> = "{0:.4f}".format(train_error)
    valt = trial.tensor("<strong class="bold">validation-error</strong>")
    validation_error = valt.value(i)[0]
    <strong class="bold">validation_error</strong> = "{0:.4f}".format(validation_error)
    print(f"STEP {i}: [TRAIN ERROR]={<strong class="bold">train_error</strong>} " +
          f"[VALIDATION ERROR]={<strong class="bold">validation_error</strong>}")</pre><p>在前面的代码块中，我们已经迭代了[2，4，6，8，10，12，14，16]列表，因为我们配置了调试器挂钩来每两步收集一次指标值。<em class="italic">图5.14 </em>向我们展示了运行前面的代码块后的输出:</p><div><img src="img/B16850_05_14.jpg" alt="Figure 5.14 – Training and validation error values&#13;&#10;" width="1002" height="246"/></div><p class="figure-caption">图5.14–训练和验证错误值</p><p>在<em class="italic">图5.14 </em>中，我们有由<a id="_idIndexMarker999"/> SageMaker调试器收集的训练误差和验证误差值。如果您想知道<a id="_idIndexMarker1000"/>我们是如何每两步收集度量值的，请记住在<em class="italic">识别SageMaker调试器的问题</em>方法中，我们在初始化CollectionConfig对象时在参数字典<a id="_idTextAnchor325"/> nary中为save_interval指定了值2。</p></li>
				<li>Use the %store magic command to load the value of rule_job_summary:<pre>%store -r rule_job_summary</pre><p>请记住，我们使用%store magic在IPython数据库中的<em class="italic"> I <a id="_idTextAnchor326"/>检查SageMaker调试器日志和结果</em>方法中存储了这个值。</p></li>
				<li>Get the specific rule job summary for the LossNotDecreasing rule:<pre>def lfx(r):
    return r["RuleConfigurationName"] == "LossNotDecreasing"
     
loss_not_decreasing_summary = list(filter(
    lfx, 
    rule_job_summary))[0]
     
loss_not_decreasing_summary</pre><p>前面的代码块<a id="_idIndexMarker1001"/>帮助我们提取LossNotDecreasing规则的规则作业<a id="_idIndexMarker1002"/>摘要，因为有两个规则作业是在我们调用fit()函数之后执行的，如前面的配方中所述。这将产生一个类似于图5.15所示的字典:</p><div><img src="img/B16850_05_15.jpg" alt="Figure 5.15 – Rule job summary for the LossNotDecreasing rule&#13;&#10;" width="1606" height="262"/></div><p class="figure-caption">图5.15–loss not reducing规则的规则作业摘要</p><p>在图5.15 中，我们可以看到字典中的RuleEvaluationStatus键映射到IssuesFound值。我们可以在映射到StatusDetails键的值中看到更多的<a id="_idTextAnchor327"/>细节。</p></li>
				<li>Get and inspect the rule evaluation job ARN:<pre>summary = loss_not_decreasing_summary
rule_evaluation_job_arn = summary['RuleEvaluationJobArn']
rule_evaluation_job_arn</pre><p>这应该会给出一个类似于' arn:AWS:sage maker:us-east-1:1234567890:processing-job/s<a id="_idTextAnchor328"/>age maker-xgboost-2021-04-lossnotdecoding-ee 3d F9 a 4 '的字符串值。</p></li>
				<li>使用processing job . from _ processing _ arn()函数加载处理作业，该函数带有上一步获得的评估作业ARN:<pre>import sagemaker  from sagemaker.processing import ProcessingJob       session = sagemaker.Session() processing_job = <strong class="bold">ProcessingJob.from_processing_arn</strong>(     sagemaker_session=session,      proce<a id="_idTextAnchor329"/><a id="_idTextAnchor330"/><a id="_idTextAnchor331"/>ssing_job_arn=rule_evaluation_job_arn)       processing_job</pre></li>
				<li>接下来，设置并<a id="_idIndexMarker1003"/>准备区域、组和前缀变量<a id="_idIndexMarker1004"/>的值:<pre>region = "us-east-1" group = "/aws/sa<a id="_idTextAnchor332"/>gemaker/ProcessingJobs" prefix = processing_job.job_name</pre></li>
				<li>使用pip: <pre>!pip install <strong class="bold">awslogs</strong></pre>安装a <a id="_idTextAnchor333"/> wslogs命令行工具</li>
				<li>Run the following Bash command to load the logs generated by the processing job:<pre>!awslogs get {group} --log-stream-name-prefix {prefix} -s3h --aws-region {region}</pre><p>这将产生一组类似于图5.16 中所示的日志:</p></li>
			</ol>
			<div><div><img src="img/B16850_05_16.jpg" alt="Figure 5.16 – Logs generated after running the awslogs CLI tool&#13;&#10;" width="1580" height="609"/>
				</div>
			</div>
			<p class="figure-caption">图5.16–运行awslogs CLI工具后生成的日志</p>
			<p><em class="italic">图5.16 </em>向我们<a id="_idIndexMarker1005"/>展示了在<a id="_idIndexMarker1006"/>运行awslogs命令行工具后生成的一部分日志。正如我们在<em class="italic">图5.16 </em>所示日志的第二行中所看到的，在运行<a id="_idTextAnchor334"/>培训作业之前，我们在估算器中指定的LossNotDecreasing规则的条件得到了满足。</p>
			<p>现在，让我们看看这是如何工作的！</p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor335"/>工作原理……</h2>
			<p>在这个方法中，我们使用了smdebug来检查用SageMaker调试器创建的实体的属性。让我们快速仔细地看一下使用smdebug库时的一些相关术语和概念:</p>
			<ul>
				<li><strong class="bold">步骤</strong>:一批培训作业所完成的<a id="_idIndexMarker1007"/>工作的单位</li>
				<li><strong class="bold">集合</strong>:一个集合<a id="_idIndexMarker1008"/>或一组张量(类似矩阵的容器或结构)</li>
				<li><strong class="bold">钩子</strong>:保持<a id="_idIndexMarker1009"/>对集合的跟踪，并根据指定的配置在每一步之后生成相关的输出文件</li>
				<li><strong class="bold">试用</strong>:实现<a id="_idIndexMarker1010"/>对培训作业张量的查询和分析</li>
			</ul>
			<p>现在，让我们检查<em class="italic">中的一个步骤的代码行，确定SageMaker调试器</em>的问题:</p>
			<pre><strong class="bold">metrics_collection_config</strong> = <strong class="bold">CollectionConfig</strong>(
    name="metrics",
    parameters={
        "save_interval": str(save_interval)
    })
     
debugger_hook_config = <strong class="bold">DebuggerHookConfig</strong>(
    s3_output_path=bucket_path,  
    collection_configs=[<strong class="bold">metrics_collection_config</strong>]
)</pre>
			<p>这里，<a id="_idIndexMarker1011"/>初始化了DebuggerHookConfig，而<a id="_idIndexMarker1012"/>在初始化Estimator时用作参数。使用DebuggerHookConfig，我们可以指定和配置如何发出和收集调试信息。此DebuggerHookConfig配置SageMaker调试器以执行以下操作:</p>
			<ul>
				<li>每两个间隔(save_interval = 2)保存一次调试数据(例如，train-error)。</li>
				<li>将调试数据存储在我们指定的亚马逊S3 bucket_path中。</li>
			</ul>
			<p>运行训练作业时，调试数据存储在目标S3路径中。如果我们想从这些日志中提取调试数据，我们使用smdebug库中的trial.tensor()函数，然后使用value()函数获取指定索引处的值。最后，如果满足一个或多个规则条件，rule_job_summary()函数应该反映问题的适当状态和描述。</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor336"/>还有更多…</h2>
			<p>请注意，在<em class="italic">如何做……</em>一节中，我们只是触及了smdebug库的皮毛。一旦我们将度量数据收集到S3存储桶中，我们就可以使用smdebug库通过以下代码行创建一个系统读取器对象。请随意用我们在<em class="italic">识别SageMaker调试器问题</em>配方中执行的XGBoost培训作业的名称替换“&lt;在此插入培训作业名称&gt;”字符串:</p>
			<pre><strong class="bold"># set up the TrainingJob object from the job name</strong>
from smdebug.profiler.analysis.notebook_utils.training_job import <strong class="bold">TrainingJob</strong>
training_job_name = "<strong class="bold">&lt;insert training job name here&gt;</strong>"
training_job = <strong class="bold">TrainingJob</strong>(training_job_name, "us-east-1")
     
<strong class="bold"># prepare a system reader object</strong>
training_job.wait_for_sys_profiling_data_to_be_available()
<strong class="bold">reader</strong> = training_job.get_systems_metrics_reader()</pre>
			<p>一旦我们有了<a id="_idIndexMarker1013"/>系统阅读器对象，我们就可以使用来自smdebug库的MetricsHistogram类来计算和<a id="_idIndexMarker1014"/>绘制直方图:</p>
			<pre>from smdebug.profiler.analysis.notebook_utils.metrics_histogram import <strong class="bold">MetricsHistogram</strong>
     
endtime = reader.get_timestamp_of_latest_available_file()
     
metrics_histogram = <strong class="bold">MetricsHistogram</strong>(reader)
metrics_histogram.plot(
    starttime=0, 
    endtime=endtime
)</pre>
			<p>这将为我们提供一组类似于图5.17 所示的图表:</p>
			<div><div><img src="img/B16850_05_17.jpg" alt="Figure 5.17 – Generated plots of the metrics histograms&#13;&#10;" width="745" height="257"/>
				</div>
			</div>
			<p class="figure-caption">图5.17–生成的指标直方图</p>
			<p>请注意，如果您<a id="_idIndexMarker1015"/>自己执行这些代码块，您<a id="_idIndexMarker1016"/>将获得超过28个图表，因为我们在使用plot()函数时没有指定一组特定的维度和事件。</p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor337"/>参见</h2>
			<p>也可以随意查看这里的一些参考资料和链接:</p>
			<ul>
				<li>使用smdebug库分析系统和<a id="_idIndexMarker1017"/>框架指标:<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-analyze-data.html">https://docs . AWS . Amazon . com/sagemaker/latest/DG/debugger-analyze-data . html</a></li>
				<li>SageMaker Studio上的SageMaker调试器<a id="_idIndexMarker1018"/>:<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/debugger-on-studio.html">https://docs . AWS . Amazon . com/sage maker/latest/DG/Debugger-on-Studio . html</a></li>
				<li>SageMaker <a id="_idIndexMarker1019"/>用于分析的调试器编程模型:<a href="https://github.com/awslabs/sagemaker-debugger/blob/master/docs/analysis.md">https://github . com/aw slabs/sage maker-Debugger/blob/master/docs/analysis . MD</a></li>
			</ul>
			<p>现在，让我们继续下一个食谱吧！</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor338"/>使用SageMaker实验运行和管理多个实验</h1>
			<p>管理单个机器学习(ML)实验很容易。当<a id="_idIndexMarker1020"/>我们处理单个ML实验时，很容易<a id="_idIndexMarker1021"/>定位和审计输入和<a id="_idIndexMarker1022"/>输出工件、配置参数、超参数值以及所有其他相关元数据<a id="_idIndexMarker1023"/>和与该单个ML实验相关的细节。当我们必须处理多个ML实验以及检索过去执行的实验和培训工作的信息时，事情变得有点棘手。</p>
			<p>在本食谱中，我们将使用<strong class="bold"> SageMaker Experiments </strong>运行并跟踪多个实验。每个实验都对应于我们将用于训练工作的超参数的特定组合。我们将使用XGBoost内置算法来帮助我们使用我们在<em class="italic">分类问题综合数据生成</em>配方中生成的综合数据集来训练和构建分类器。在设置实验时，我们将利用smexperiments库中的类和函数来帮助我们在配置和运行每个实验时记录相关信息。</p>
			<p class="callout-heading">小费</p>
			<p class="callout">使用SageMaker实验是免费的！通常，我们只根据计算和存储资源的使用情况为其付费。这意味着我们只需支付运行培训作业、运行SageMaker笔记本实例的成本，以及与在S3存储桶中存储文件相关的成本。关于这个话题的更多信息，请参考这里的定价页面:<a href="https://aws.amazon.com/sagemaker/pricing/">https://aws.amazon.com/sagemaker/pricing/</a>。</p>
			<h2 id="_idParaDest-244">正在准备中</h2>
			<p>以下是该配方的先决条件:</p>
			<ul>
				<li>这个rec <a id="_idTextAnchor341"/> ipe从<em class="italic">分类问题综合数据生成</em>继续<a id="_idTextAnchor342"/> s。</li>
			</ul>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor343"/>怎么做……</h2>
			<p>该配方中的<a id="_idIndexMarker1024"/>第一步集中在<a id="_idIndexMarker1025"/>为<a id="_idIndexMarker1027"/>实验设置先决条件<a id="_idIndexMarker1026"/>:</p>
			<ol>
				<li value="1">导航到SageMaker笔记本实例中的my-experiments/chapter05目录。如果这个目录还不存在，请随意创建。</li>
				<li>在my-experiments/chapter05目录下使用conda_python3内核创建一个新的笔记本，用这个配方的名字命名(也就是用SageMaker Experiments运行和管理多个实验)。打开此笔记本进行编辑，因为我们将在接下来的几个步骤中使用代码更新此文件。</li>
				<li>通过运行下面几行代码，导入培训作业的一些先决条件(如会话、角色、sagemaker_session和sage maker _ client):<pre>import sagemaker, boto3 <strong class="bold">session</strong> = boto3.Session() <strong class="bold">sagemaker_session</strong> = sagemaker.Session(boto_session=session) <strong class="bold">sagemak<a id="_idTextAnchor344"/>er_client</strong> = session.client('sagemaker') <strong class="bold">role</strong> = sagemaker.get_execution_role()</pre></li>
				<li>接下来，再导入一些必备的库和实用程序，比如time、numpy、pandas、itertools和pprint: <pre>import time, os, sys imp<a id="_idTextAnchor345"/>ort numpy as np import pandas as pd import itertools from pprint import pprint</pre></li>
				<li><a id="_idTextAnchor346"/>安装<a id="_idIndexMarker1028"/>sagemaker-experiments包:<pre>!pip install <strong class="bold">sagemaker-experiments</strong></pre></li>
				<li>从smexperiments导入实验、试验组件、试验和跟踪器:<pre>from smexperiments.experiment import <strong class="bold">Experiment</strong> from smexperiments.trial import <strong class="bold">Trial</strong> from smexperiments.t<a id="_idTextAnchor347"/>rial_component import <strong class="bold">TrialComponent</strong> from smexperiments.tracker import <strong class="bold">Tracker</strong></pre></li>
				<li>定义<a id="_idIndexMarker1029"/>生成随机字符串()函数:<pre>import random import string       def <strong class="bold">generate_random_string</strong>():     list_of_chars = random.choices(  <a id="_idTextAnchor348"/><a id="_idTextAnchor349"/>       string.ascii_uppercase,          k=10)     return ''.join(list_of_chars)</pre></li>
				<li>使用<a id="_idIndexMarker1031"/>create()函数<pre>label = generate_random_string()  training_experiment = <strong class="bold">Experiment.create</strong>(     experiment_name = f"experiment-{label}",     descri<a id="_idTextAnchor350"/>ption     = "Experiment Description",     sagemaker_boto_client=sagemaker_client)</pre>创建<a id="_idIndexMarker1030"/>一个实验实例</li>
				<li>Prepare <a id="_idIndexMarker1032"/>the hyperparam_options dictionary:<pre><strong class="bold">hyperparam_options</strong> = {
    'max_depth': [2, 8],
    'eta': [0.2],
    'gamma': [3, 4],
    'min_child_weight': [6],
    'subsample': [0.4],
    'num_round': [10, 20],
    'objective': ['binary:logistic']
}</pre><p class="callout-heading">重要说明</p><p class="callout">注意<a id="_idIndexMarker1033"/>增加超参数选项字典中指定的<a id="_idIndexMarker1034"/>选项的数量会增加实验用来配置训练任务的超参数的<a id="_idIndexMarker1035"/>组合的总数。也就是说，这将增加执行的训练任务的数量以及整个实验的总持续时间。由于我们为ML培训实例的运行时间付费，成本也可能相应增加。在这个配方中，我们总共有2 x 1 x 2 x 1 x 2 x 1的超参数组合。如果每个实验需要大约5分钟完成，我们将支付8 x 5分钟的培训时间。</p></li>
				<li>定义prepare_hyperparam_variations()函数。该函数接受一个超参数选项列表，生成并返回一个包含所有超参数配置值变化的字典列表:<pre>def <strong class="bold">prepare_hyperparam_variations</strong>(options):     names, values = zip(*options.items())     <a id="_idTextAnchor352"/>return [dict(zip(names, value))              for value in itertools.product(*values)]</pre></li>
				<li>Use the<a id="_idIndexMarker1036"/> function from the <a id="_idIndexMarker1037"/>previous step <a id="_idIndexMarker1038"/>to generate <a id="_idIndexMarker1039"/>a list of hyperparameter configurations:<pre>hyperparam_variations = <strong class="bold">prepare_hyperparam_variations</strong>(
    hyperparam_options
)
hyperparam_variations</pre><p>这将产生一个类似于图5.18所示的字典数组:</p><div><img src="img/B16850_05_18.jpg" alt="Figure 5.18 – Hyperparameter variations (showing 3 of 8 variations)&#13;&#10;" width="576" height="721"/></div><p class="figure-caption">图5.18–超参数变化(显示了8个变化中的3个)</p><p>在<em class="italic">图5.18 </em>中，我们可以看到使用prepare_hyperparam_variations()函数后不同hyperpara <a id="_idTextAnchor353"/>仪表配置变化的列表。</p></li>
				<li>Specify the<a id="_idIndexMarker1040"/> S3 bucket and the<a id="_idIndexMarker1041"/> location of the<a id="_idIndexMarker1042"/> training, validation, and <a id="_idIndexMarker1043"/>test datasets. Make sure to replace the value of "&lt;insert S3 bucket name here&gt;" with the name of the bucket we created in the <em class="italic">Preparing the Amazon S3 bucket and the training dataset for the linear regression experiment</em> recipe in <a href="B16850_01_Final_ASB_ePub.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a><em class="italic">, Getting Started with Machine Learning Using Amazon SageMaker</em>:<pre>s3_bucket = '<strong class="bold">&lt;insert S3 bucket name here&gt;</strong>'
prefix = "chapter05"
path = f"s3://{s3_bucket}/{prefix}/input"
<strong class="bold">training_path</strong> = f"{path}/training_data.csv" 
<strong class="bold">validation_path</strong> = f"{path}/validation_data.csv" 
<strong class="bold">output_path</strong> = f"s3://{s3_bucket}/{prefix}/output/"</pre><p>请注意，s3_bucket值应与本章中分类问题配方的<em class="italic">合成数据集生成中使用的值<a id="_idTextAnchor354"/>相同。</em></p></li>
				<li>Use the retrieve() function to get the ECR container image URI for XGBoost:<pre>from sagemaker.image_uris import <strong class="bold">retrieve</strong>
container = <strong class="bold">retrieve</strong>('xgboost', 
                     boto3.Session().region_name, 
                     version="0.90-2")
container</pre><p>这应该会给我们一个类似于683313688378 . dkr . ECR . us-east-1 . amazonaws . com/sage maker-xgboost:0.90-2-CPU-py3的字符串值。</p><p class="callout-heading">注意</p><p class="callout">我们可以使用XGBoost作为内置算法，或者使用开源的XGBoost算法，这涉及到编写自定义的训练脚本。请随意查看以下链接，了解更多关于使用XGBoost和<a id="_idTextAnchor355"/> SageMaker的信息:<a href="https://sagemaker.readthedocs.io/en/stable/frameworks/xgboost/using_xgboost.html">https://SageMaker . readthe docs . io/en/stable/frameworks/XGBoost/using _ XGBoost . html</a>。</p></li>
				<li>Use TrainingInput to<a id="_idIndexMarker1044"/> specify the training <a id="_idIndexMarker1045"/>channel configuration for the training <a id="_idIndexMarker1046"/>and validation<a id="_idIndexMarker1047"/> inputs:<pre>from sagemaker.inputs import <strong class="bold">TrainingInput</strong>
s3_input_training = <strong class="bold">TrainingInput</strong>(
    training_path, content_typ<a id="_idTextAnchor356"/>e="text/csv")
s3_input_validation = <strong class="bold">TrainingInput</strong>(
    validation_path, content_type="text/csv")</pre><p>现在<a id="_idIndexMarker1048"/>我们已经准备好了<a id="_idIndexMarker1049"/>先决条件，我们将继续让我们的实验运行在<a id="_idIndexMarker1050"/>下一组<a id="_idIndexMarker1051"/>步骤中。</p></li>
				<li>创建一个名为experiment_tracker的跟踪器，并使用log_input(): <pre>ex_name = training_experiment.experiment_name with <strong class="bold">Tracker.create</strong>(     display_name="xgboost-experiment-display-name",      artifact_bucket=s3_bucket,     artifact_prefix=ex_name,     sagemaker_boto_client=sagemaker_client ) as experiment_tracker:         experiment_tracker.<strong class="bold">log_input</strong>(         name="training-input",                                    media_type="s3/uri",          value=training_path)          experiment_tracker.<strong class="bold">log_input</strong>(         name="validation-input",          media_type="s3/uri",   <a id="_idTextAnchor357"/> <a id="_idTextAnchor358"/><a id="_idTextAnchor359"/>      value=validation_path)          experiment_tracker.<strong class="bold">log_parameters</strong>(         hyperparam_options)</pre>在跟踪器中记录training_path、validation_path和hyperparam_options的值</li>
				<li>定义<a id="_idIndexMarker1052"/>track _ and _ generate _ config()函数。该功能有三个部分:<ul><li>为特定的培训作业创建<a id="_idIndexMarker1053"/>试验跟踪器<a id="_idIndexMarker1054"/>，并使用log_parameters()记录培训<a id="_idIndexMarker1055"/>作业的超参数</li><li>创建一个试验对象，并使用add_trial_component()函数添加试验组件</li><li>返回包含ExperimentName、TrialName和TrialComponentDisplayName键的实验配置字典:<pre>def <strong class="bold">track_and_generate_config</strong>(     experiment_tracker,      experiment_name,      job_name,      random_string,      hyperparameters):          tdn = f"trial-metadata-{random_string}"     tracker_display_name = tdn     print(f"{label} Create Tracker: {tdn}")          <strong class="bold"># Step # 1: Creating a Trial Tracker</strong>     prefix = f"{experiment_name}/{job_name}"     with <strong class="bold">Tracker.create</strong>(         display_name=tracker_display_name,         artifact_bucket=s3_bucket,         artifact_prefix=prefix,         sagemaker_boto_client=sagemaker_client     ) as trial_tracker:         trial_tracker.<strong class="bold">log_parameters</strong>(             hyperparameters         )           trial_name = f'trial-{random_string}'     print(f"Create Trial: {trial_name}")          <strong class="bold"># Step # 2A: Creating a Trial object </strong>     trial = <strong class="bold">Trial.create</strong>(         trial_name=trial_name,          experiment_name=experiment_name,         sagemaker_boto_client=sagemaker_client)          <strong class="bold"># Step # 2B: Adding the trial components</strong>     trial.<strong class="bold">add_trial_component</strong>(         experiment_tracker.trial_component)     time.sleep(1)      trial.<strong class="bold">add_trial_component</strong>(         trial_tracker.trial_component)          <strong class="bold"># Step # 3: Returning the config dictionary</strong>     return {         "<strong class="bold">ExperimentName</strong>": expe<a id="_idTextAnchor360"/>riment_name,          "<strong class="bold">TrialName</strong>": trial.trial_name,         "<strong class="bold">TrialComponentDisplayName</strong>": job_name     }</pre></li></ul></li>
				<li>Run the <a id="_idIndexMarker1056"/>following block of code to<a id="_idIndexMarker1057"/> loop through<a id="_idIndexMarker1058"/> each of the hyperparameter configuration variations and trigger a training job for<a id="_idIndexMarker1059"/> each one. This block of code has three parts—setting up the variable values for iteration, label, random_string, and job_name, tracking the experiment and generating the experiment configuration dictionary using the track_and_generate_config() function we have prepared in the previous step, and running the training job with the experiment configuration specified as a parameter to the fit() function call:<pre>import time
<strong class="bold">experiment_name</strong> = training_experiment.experiment_name
     
for index, <strong class="bold">hyperparameters</strong> in enumerate(
    hyperparam_variations
):
    <strong class="bold"># Step # 1: Setting up the variable values</strong>
    <strong class="bold">iteration</strong> = index + 1
    print(f"Iteration # {iteration}")
    <strong class="bold">label</strong> = f"[Iteration # {iteration}]"
    <strong class="bold">random_string</strong> = generate_random_string()
    <strong class="bold">job_name</strong> = f"job-{random_string}"
    
    <strong class="bold"># Step # 2: Tracking trials and trial </strong>
    <strong class="bold"># components and generating the</strong>
    <strong class="bold"># experiment configuration </strong>
    print(f"{label} Track and Generate Config")
    <strong class="bold">experiment_config</strong> = <strong class="bold">track_and_generate_config</strong>(
        experiment_tracker=<strong class="bold">experiment_tracker</strong>,
        experiment_name=<strong class="bold">experiment_name</strong>,
        job_name=<strong class="bold">job_name</strong>,
        random_string=<strong class="bold">random_string</strong>,
        hyperparameters=<strong class="bold">hyperparameters</strong>)
    
    time.sleep(1)
    <strong class="bold"># Step # 3: Running the training job</strong>
    print(f"{label} Initialize Estimator")
    estimator = sagemaker.estimator.Estimator( 
        container,
        role,
        instance_count=1, 
        instance_type='ml.m5.large', 
        output_path=output_path, 
        hyperparameters=<strong class="bold">hyperparameters</strong>,
        enable_sagemaker_metrics = True,
        sagemaker_session=sagemaker_session
    )
    
    print(f"{label} Call fit() function")
    data = {'train': s3_input_training, 
            'validation': s3_input_validation}
    exc = <strong class="bold">experiment_config</strong>
    estimator.<strong class="bold">fit</strong>(data,
                  job_name = job_name, 
                  wait=False,
                  experiment_config=exc)</pre><p>正如您<a id="_idIndexMarker1060"/>将在<a id="_idIndexMarker1061"/>的最后部分注意到的那样，在调用fit()函数时，我们已经将使用track_and_generate_config()生成的字典作为值传递给了experiment_config参数。正如在前面的<a id="_idIndexMarker1062"/>步骤中所看到的，实验_配置参数期望实验管理<a id="_idIndexMarker1063"/>配置以具有三个可选关键字的字典的形式出现:“实验名称”、“实验名称”和“实验组件显示名称”。</p><p class="callout-heading">注意</p><p class="callout">如果您使用的是全新的AWS帐户，在使用fit()和deploy()函数启动ML实例时，您可能会遇到ResourceLimitExceeded错误(或类似的错误)。要解决此问题，请打开AWS支持中心并创建一个案例。如需了解更多信息，请随时访问此链接:<a href="https://aws.amazon.com/premiumsupport/knowledge-center/resourcelimitexceeded-sagemaker/">https://AWS . Amazon . com/premium support/knowledge-center/resourcelimitexceed-sage maker/</a>。</p><p><em class="italic">图5.19 </em>向<a id="_idIndexMarker1064"/>展示了运行前一个代码块后的日志输出示例:</p><div><img src="img/B16850_05_19.jpg" alt="" width="1109" height="402"/></div><p class="figure-caption">图5.19–运行使用XGBoost内置算法运行和跟踪多个实验的循环时，日志输出的特定部分</p><p>在<em class="italic">图5.19 </em>中，我们有前面代码块中的循环生成的日志。请注意，我们正在<a id="_idIndexMarker1065"/>使用超参数<a id="_idIndexMarker1066"/>值的不同配置运行几个训练任务，并为每个训练任务附加一个试用。</p><p class="callout-heading">重要说明</p><p class="callout">这一步可能需要30多分钟才能完成，所以在等待的时候，请随意阅读<em class="italic">它是如何工作的… </em>和<em class="italic">这份食谱还有更多… </em>章节。你也可以继续学习本章中的以下食谱！</p></li>
				<li>Finally, we use %store magic to save the value of experiment_name:<pre>%store experiment_name</pre><p>我们将在稍后使用SageMaker实验配方的<em class="italic">实验分析中使用实验名称v <a id="_idTextAnchor361"/>变量值。</em></p></li>
			</ol>
			<p>现在，让我们看看这是如何工作的！</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor362"/>工作原理……</h2>
			<p>在这个配方中，<a id="_idIndexMarker1067"/>我们使用了sagemaker-experiments库来帮助我们跟踪和组织ML实验中的不同变量、值和<a id="_idIndexMarker1068"/>工件。</p>
			<p>让我们定义几个重要术语:</p>
			<ul>
				<li><strong class="bold">实验</strong>:对应<a id="_idIndexMarker1070"/>到ML实验，目的是达到某个目标</li>
				<li><strong class="bold">试验</strong>:对应一个<a id="_idIndexMarker1071"/>训练迭代或训练作业</li>
				<li><strong class="bold">试验组件</strong>:将<a id="_idIndexMarker1072"/>对应到参数、元数据或工件</li>
			</ul>
			<p>使用smexperiments库<a id="_idIndexMarker1073"/>相当简单。我们创建一个实验资源，并在运行培训作业时链接试用和试用组件对象。您可能认为这就像一棵树，实验资源作为根，试验对象作为实验资源下的第一级子对象。这同样适用于每个试验下的TrialComponent对象。</p>
			<div><div><img src="img/B16850_05_20.jpg" alt="Figure 5.20 – How Experiment, Trial, TrialComponent, and Tracker resources are connected&#13;&#10;" width="1468" height="796"/>
				</div>
			</div>
			<p class="figure-caption">图5.20-试验、试用、试用组件和跟踪器资源是如何连接的</p>
			<p>在<em class="italic">图5.20 </em>中，我们可以<a id="_idIndexMarker1074"/>看到每个实验可以<a id="_idIndexMarker1075"/>有一个或多个试验，每个试验可以有一个或多个试验组件。我们还可以<a id="_idIndexMarker1076"/>看到度量、参数以及输入和输出工件信息和细节都<a id="_idIndexMarker1077"/>链接到了TrialComponent对象。</p>
			<p>在下一个菜谱中，我们将看到如何用几行代码来分析和处理多个实验的训练结果。</p>
			<h2 id="_idParaDest-247">还有更多…</h2>
			<p>当处理<a id="_idIndexMarker1078"/>多个实验、模型谱系、搜索和跟踪需求时，我想到了另外两个相关的功能— <strong class="bold"> SageMaker ML谱系跟踪</strong>和<strong class="bold"> SageMaker搜索</strong>。</p>
			<p>SageMaker ML沿袭跟踪有助于保存ML模型的历史。这包括配置参数、超参数集以及用于训练模型的数据和算法。这可能还包括工作流元数据，以帮助我们定位、复制和比较模型。在大多数情况下，会自动跟踪和记录沿袭关联，我们可以使用以下代码行生成包含SageMaker资源(例如，培训作业、处理作业或模型包)沿袭关联的快速数据帧:</p>
			<pre>from sagemaker.session import Session
from sagemaker.lineage.visualizer import <strong class="bold">LineageTableVisualizer</strong>
session = Session()
viz = <strong class="bold">LineageTableVisualizer</strong>(session)
viz.show(training_job_name="<strong class="bold">&lt;insert job name here&gt;</strong>")</pre>
			<p>这将给我们一个类似于图5.21 中所示的数据框架:</p>
			<div><div><img src="img/B16850_05_21.jpg" alt="Figure 5.21 – DataFrame containing the lineage associations of a training job&#13;&#10;" width="651" height="145"/>
				</div>
			</div>
			<p class="figure-caption">图5.21–包含培训工作沿袭关联的数据框架</p>
			<p>在<em class="italic">图5.21 </em>中，我们可以看到连接到指定训练作业的<a id="_idIndexMarker1079"/>资源——训练和验证CSV文件的位置，XGBoost算法容器图像，以及训练作业产生的输出工件的位置。我们不会在本书中讨论SageMaker ML沿袭跟踪的细节，因此可以随意查看此链接以了解有关此主题的更多信息:<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/lineage-tracking.html">https://docs . AWS . Amazon . com/sage maker/latest/DG/Lineage-Tracking . html</a>。</p>
			<p>另一方面，SageMaker搜索<a id="_idIndexMarker1080"/>帮助我们定位SageMaker资源，如培训工作、实验、端点和模型包。使用SageMaker搜索的一个实际例子是搜索和停止一个实验的所有运行中的训练作业。这意味着我们不需要等到培训作业完成后再重试。我们可以使用以下脚本来搜索和停止所有正在运行的培训作业:</p>
			<pre><strong class="bold">sagemaker</strong> = boto3.client(service_name='sagemaker')
     
def <strong class="bold">stop_all_running_training_jobs</strong>():
    search_params={
       "MaxResults": 50,
       "Resource": "TrainingJob",
       "SearchExpression": {
          "Filters": [
             {
                "Name": "<strong class="bold">TrainingJobStatus</strong>",
                "Operator": "<strong class="bold">Equals</strong>",
                "Value": "<strong class="bold">InProgress</strong>"
             }
          ]
       }
    }
     
    results = <strong class="bold">sagemaker.search</strong>(**search_params)
    count = len(results['Results'])
    
    for result in results['Results']:
        job_name = result['TrainingJob']['TrainingJobName']
        <strong class="bold">stop_training_job</strong>(job_name)</pre>
			<p>该函数首先搜索TrainingJobStatus等于InProgress的所有<a id="_idIndexMarker1081"/>训练任务，然后使用stop_training_job()函数停止这些训练任务。stop_training_job()函数(未在前面的代码块中显示)简单地使用sagemaker.stop_training_job()函数来停止给定TrainingJobName的训练作业。这样，我们将能够立即停止运行培训作业，这样我们就不必等到它们完成后再重试。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">注意，为了简洁起见，这里省略了一些代码行。你可以在这里查看更完整的代码版本:<a href="https://gist.github.com/joshualat/c420ff645730034387c39b62f5d3296a">https://gist . github . com/Joshua lat/c 420 ff 645730034387 c 39 b 62 f 5d 3296 a</a>。</p>
			<p>想了解更多关于SageMaker搜索的信息，请随时查看以下链接:<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/search.html">https://docs.aws.amazon.com/sagemaker/latest/dg/search.html</a>。</p>
			<p>现在，让我们继续下一个食谱吧！</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor364"/>使用SageMaker实验进行实验分析</h1>
			<p>在<a id="_idIndexMarker1083"/>之前的配方中，我们运行了多个<a id="_idIndexMarker1084"/>训练作业，并使用SageMaker实验来跟踪参数、输入和输出工件、度量值和其他元数据，以及使用smexperiments库的实验、试验、试验组件和跟踪器资源。</p>
			<p>在本食谱中，我们将使用sagemaker.analytics的ExperimentAnalytics加载和分析数据帧，该数据帧包含我们使用SageMaker Experiments执行和跟踪的先前实验的详细信息<a id="_idTextAnchor365"/>。这使得我们只需要几行代码就可以检查和分析培训工作的结果。</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor366"/>准备就绪</h2>
			<p>以下是该配方的先决条件网站:</p>
			<ul>
				<li>该配方上接<em class="italic">使用SageMaker实验</em>运行和管理多个实验。</li>
			</ul>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor369"/>怎么做……</h2>
			<p>该配方中的第一组<a id="_idIndexMarker1085"/>步骤主要是<a id="_idIndexMarker1086"/>准备和加载先决条件:</p>
			<ol>
				<li value="1">导航到SageMaker笔记本实例中的my-experiments/chapter05目录。如果这个目录还不存在，请随意创建。</li>
				<li>在my-experiments/chapter05目录下使用conda_python3内核创建一个新的笔记本，并以这个配方的名称命名(即带有SageMaker实验的实验分析)。打开此笔记本进行编辑，因为我们将在接下来的几个步骤中使用代码更新此文件。</li>
				<li>使用%store magic命令加载experiment_name的值。请记住，我们使用%store magic命令将该值保存在使用SageMaker Experiments 配方运行和管理多个实验的<em class="italic">中:<pre>%store -r experiment_name</pre></em></li>
				<li>初始化实验分析对象:<pre>from sagemaker.analytics import <strong class="bold">ExperimentAnalytics</strong> import sagemaker, boto3       session = boto3.Session() sagemaker_session = sagemaker.Session(boto_session=se<a id="_idTextAnchor370"/>ssion)       experiment_analytics = <strong class="bold">ExperimentAnalytics</strong>(     sagemaker_session=sagemaker_session,      experiment_name=experiment_name, )</pre></li>
				<li>使用<a id="_idTextAnchor371"/> dataframe()函数<a id="_idIndexMarker1088"/>加载<a id="_idIndexMarker1087"/>数据帧，并将其存储在实验_细节_df变量:<pre>experiment_details_df = experiment_analytics.<strong class="bold">dataframe()</strong></pre>中</li>
				<li>Use the following lines of code to display the contents of the DataFrame:<pre>import pandas as pd
from IPython.display import display
pd.options.display.max_columns = None
<strong class="bold">display</strong>(experiment_details_df)</pre><p>在<em class="italic">图5.22 </em>中，我们可以看到使用display()函数后，一个包含所有experiment_details_df数据帧值的表格:</p><div><img src="img/B16850_05_22.jpg" alt="Figure 5.22 – Table containing all the values of the DataFrame&#13;&#10;" width="1490" height="869"/></div><p class="figure-caption">图5.22-包含数据帧所有值的表格</p><p>在<em class="italic">图5.22 </em>中，我们有包含我们在实验中执行的不同训练任务的参数、超参数和度量值的数据帧。请注意，如果我们在训练作业完成之前使用<a id="_idTextAnchor372"/>g experiment _ analytics . data frame()加载此数据帧，我们可能还没有一些列和列值。</p></li>
				<li>To<a id="_idIndexMarker1089"/> make sure that the columns are<a id="_idIndexMarker1090"/> ready before proceeding with the next step, we run the following block of code: <pre>from time import sleep
     
metric = "<strong class="bold">validation:error - Avg</strong>"
<strong class="bold">while metric not in experiment_details_df</strong>:
    eddf = experiment_analytics.dataframe()
    experiment_details_df = eddf
    print("Not yet ready. Sleeping for 10 seconds")
    sleep(10)
    
print("Ready")</pre><p>这段代码将无限循环，直到在使用DataFrame()函数返回的dataframe中检测到指定的度量列。在这种情况下，我们在继续下一步之前，等待“验证:错误平均值”出现。</p></li>
				<li>用一组选定的列准备一个新的数据框架:<pre><strong class="bold">target_fields</strong> = [     "TrialComponentName",     "DisplayName",     "eta",     "gamma",     "max_depth",     "min_child_weight",     "num_round",     "objective",     "subsample",     "validation:error - Avg"<a id="_idTextAnchor373"/>,     "train:error - Avg",     "Trials",     "Experiments", ]       eddf = experiment_details_df experiment_summary_df = eddf[<strong class="bold">target_fields</strong>]</pre></li>
				<li>Use<a id="_idIndexMarker1091"/> the display() function to show<a id="_idIndexMarker1092"/> the contents of the new DataFrame:<pre><strong class="bold">display</strong>(experiment_summary_df)</pre><p><em class="italic">图5.23 </em>向我们展示了运行<a id="_idTextAnchor374"/>上一行代码后的输出:</p><div><img src="img/B16850_05_23.jpg" alt="Figure 5.23 – The updated DataFrame&#13;&#10;" width="1434" height="685"/></div><p class="figure-caption">图5.23-更新后的数据框</p><p>在<em class="italic">图5.23 </em>中，我们有一个只包含所选列的数据帧。</p></li>
				<li>当<a id="_idIndexMarker1093"/>一些实验仍在运行时，我们<a id="_idIndexMarker1094"/>可能会看到一些带有NaN值的行。在这一步中，我们删除具有NaN值的行:<pre>import math       def <strong class="bold">is_not_nan</strong>(num):     return not math.isnan(num)       def <strong class="bold">remove_nan_rows</strong>(df): <a id="_idTextAnchor375"/>    return df[df['train:error - Avg'].map(         is_not_nan     )]       experiment_summary_df = <strong class="bold">remove_nan_rows</strong>(     experiment_summary_df )</pre></li>
				<li>根据训练错误的值对行进行排序:<pre>sorted_df = experiment_summary_df.<strong class="bold">sort_values</strong>(     'train:error - Avg', ascending=True )</pre></li>
				<li>Finally, prepare <a id="_idIndexMarker1095"/>the DataFrame <a id="_idIndexMarker1096"/>containing only the display name of the training job and the corresponding training error:<pre>final_df = sorted_df[["DisplayName", "train:error - Avg"]]
final_df</pre><p>这将产生一个类似于图5.24 中所示的数据帧:</p><div><img src="img/B16850_05_24.jpg" alt="Figure 5.24 – The final_df DataFrame containing the display name and the average training error&#13;&#10;" width="381" height="373"/></div><p class="figure-caption">图5.24–包含显示名称和平均训练误差的最终测向数据帧</p><p>在<em class="italic">图5.24 </em>中，我们可以看到平均训练误差值按升序排列的训练作业。</p></li>
				<li>Use the plot() function to generate the horizontal bar chart:<pre>final_df.<strong class="bold">plot</strong>(kind='barh', x="DisplayName", fontsize=8)</pre><p>这应该<a id="_idIndexMarker1097"/>产生一个类似于<a id="_idIndexMarker1098"/>图5.25 所示的图:</p></li>
			</ol>
			<div><div><img src="img/B16850_05_25.jpg" alt="Figure 5.25 – Horizontal bar chart showing the average training error values of each job&#13;&#10;" width="1491" height="829"/>
				</div>
			</div>
			<p class="figure-caption">图5.25-显示每项工作的平均训练误差值的水平条形图</p>
			<p><em class="italic">图5.25 </em>向我们展示了使用plot()函数后生成的<a id="_idIndexMarker1099"/>水平条形图。请注意，这只是我们可以生成的一个<a id="_idTextAnchor378"/>示例图表，因此可以随意使用ExperimentAnalytics返回的数据框架。</p>
			<p>现在，让我们看看这是如何工作的！</p>
			<h2 id="_idParaDest-251">它是如何工作的…</h2>
			<p>在这个配方中，我们使用从experiment_analytics.dataframe()加载的数据执行了一个简单的端到端流程，生成了一个快速报告。</p>
			<p>我们执行了以下数据操作步骤:</p>
			<ul>
				<li>删除了NaN值</li>
				<li>将列限制为我们要关注的几个列</li>
				<li>根据列值对行进行排序</li>
			</ul>
			<p>请注意，这只是一个例子，说明一旦我们有了包含我们用SageMaker实验跟踪的实验结果和细节的数据框架，我们可以做些什么。</p>
			<p>AnalyticsMetricsBase是ExperimentAnalytics的基类。除了dataframe()函数，我们还可以使用export_csv()函数将分析数据帧值导出并保存到一个文件中。</p>
			<p>实际上有几个从AnalyticsMetricsBase类继承了<a id="_idIndexMarker1102"/>的类——hyperparameterningjobanalytics、TrainingJobAnalytics和ExperimentAnalytics。这些类分别侧重于提供对超参数调整作业、培训作业和实验数据的即时访问。如需了解更多信息，您可以在此处查看SageMaker Python SDK GitHub资源库中的analytics.py文件:<a href="https://github.com/aws/sagemaker-python-sdk/blob/master/src/sagemaker/analytics.py">https://GitHub . com/AWS/SageMaker-Python-SDK/blob/master/src/SageMaker/analytics . py</a>。</p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor380"/>用SageMaker实验检查实验、试验和试验部件</h1>
			<p>在<a id="_idIndexMarker1103"/>该配方中，我们将使用sagemaker-experiments库<a id="_idIndexMarker1104"/>检查<a id="_idIndexMarker1105"/>不同的实验、试验和<a id="_idIndexMarker1106"/>试验组件，这些实验组件是由<a id="_idIndexMarker1107"/>创建并与SageMaker <a id="_idIndexMarker1108"/>实验链接的。能够理解我们可以用sagemaker-experiments库做什么，将允许我们更好地管理我们的实验，并检查过程中创建的实体的属性。</p>
			<h2 id="_idParaDest-253">获得rea <a id="_idTextAnchor382"/> dy</h2>
			<p>这道菜的先决条件是:</p>
			<ul>
				<li>该配方上接<em class="italic">使用SageMaker实验</em>运行和管理多个实验。</li>
			</ul>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor384"/>怎么做……</h2>
			<p>该方法的第一步主要是准备先决条件，并确保安装和加载sagemaker-experiments库:</p>
			<ol>
				<li value="1">导航到SageMaker笔记本实例中的my-experiments/chapter05目录。如果这个目录还不存在，请随意创建。</li>
				<li>使用my-experiments/chapter05目录<a id="_idIndexMarker1112"/>中的<a id="_idIndexMarker1110"/>conda _ python 3内核<a id="_idIndexMarker1111"/>创建一个新的<a id="_idIndexMarker1109"/>笔记本，并用这个配方的<a id="_idIndexMarker1114"/>名称为其命名<a id="_idIndexMarker1113"/>(即使用SageMaker实验检查实验、试验和试验组件)。打开此笔记本进行编辑，因为我们将在接下来的几个步骤中使用代码更新此文件。</li>
				<li>安装sagemaker-使用pip安装实验:<pre>!pip install <strong class="bold">sagemaker-experiments</strong></pre></li>
				<li>Import a few prerequisites from the smexperiments library:<pre>from smexperiments.experimen<a id="_idTextAnchor385"/>t import <strong class="bold">Experiment</strong>
from smexperiments.trial import <strong class="bold">Trial</strong>
from smexperiments.trial_component import <strong class="bold">TrialComponent</strong>
from smexperiments.tracker import <strong class="bold">Tracker</strong></pre><p>既然已经加载了先决条件，我们将在下一组步骤中加载实验、试用和试用组件对象。</p></li>
				<li>Use Experiment.list() to load all the experiments stored as ExperimentSummary objects:<pre>for experiment_summary in <strong class="bold">Experiment.list()</strong>:
    print(experiment_summary)</pre><p><em class="italic">图5.26 </em>向我们展示了运行前面的代码块后的输出:</p><div><img src="img/B16850_05_26.jpg" alt="Figure 5.26 – Sample output after using Experiment.list()&#13;&#10;" width="1401" height="529"/></div><p class="figure-caption">图5.26–使用Experiment.list()后的示例输出</p><p>我们<a id="_idIndexMarker1115"/>在<em class="italic">图5.26 </em>中有<a id="_idIndexMarker1116"/>实验总结对象列表。注意<a id="_idIndexMarker1117"/>实验总结对象不同于<a id="_idIndexMarker1118"/>实验对象，因为实验总结对象<a id="_idTextAnchor386"/> <a id="_idTextAnchor387"/> cts <a id="_idIndexMarker1119"/>包含更少的<a id="_idIndexMarker1120"/>信息。ExperimentSummary对象具有experiment_name值，该值可用于通过Experiment.load()加载实验对象。</p></li>
				<li>Load the experiment using Experiment.load(). The load() function accepts the experiment name as the argument and returns an Experiment object instead of an ExperimentSummary object:<pre>experiment = <strong class="bold">Experiment.load</strong>(
    experiment_summary.experiment_name
)
experiment</pre><p class="callout-heading">重要说明</p><p class="callout">请注意实验对象和实验摘要对象之间的差异，因为实验对象比实验摘要对象包含更多的属性。</p><p>图5.27 向我们展示了运行前面的代码块后的输出:</p><div><img src="img/B16850_05_27.jpg" alt="Figure 5.27 – Sample output [Experiment object] after using the Experiment.load() function&#13;&#10;" width="1507" height="276"/></div><p class="figure-caption">图5.27–使用<a id="_idTextAnchor388"/>experience . load()函数后的样本输出[实验对象]</p><p>正如您<a id="_idIndexMarker1121"/>在<em class="italic">图5.27 </em>中看到的，加载的实验对象包含更多的<a id="_idIndexMarker1122"/>属性，如描述和响应_元数据。</p></li>
				<li>Inspect<a id="_idIndexMarker1123"/> the functions by using dir():<pre><strong class="bold">dir</strong>(experiment)</pre><p>这个sho <a id="_idTextAnchor389"/>会<a id="_idIndexMarker1124"/>给我们一个实验对象的有效属性<a id="_idIndexMarker1125"/>和<a id="_idIndexMarker1126"/>函数的列表，比如create_trial、delete_all、display_name、experiment_name和experiment_arn。</p></li>
				<li>List the Trials of the Experiment using the list_trials() function:<pre>experiment_trials = list(
    experiment.<strong class="bold">list_trials</strong>()
)
experiment_trials</pre><p>这将产生一组类似于图5.28 中所示的结果:</p><div><img src="img/B16850_05_28.jpg" alt="Figure 5.28 – List of TrialSummary objects after using the list_trials() function&#13;&#10;" width="1522" height="473"/></div><p class="figure-caption">图5.28–使用list_trials()函数后的TrialSummary对象列表</p><p>在<em class="italic">图5.28 </em>中，我们<a id="_idIndexMarker1127"/>可以看到<a id="_idTextAnchor390"/>对应于<a id="_idIndexMarker1128"/>链接到实验对象的每个试验的试验汇总对象列表。与实验摘要对象相似，试验摘要对象<a id="_idIndexMarker1129"/>包含的信息<a id="_idIndexMarker1130"/>比它们对应的<a id="_idIndexMarker1132"/>试验对象少。</p></li>
				<li>Load the corresponding Trial object using Trial.load():<pre>trial = <strong class="bold">Trial.load</strong>(experiment_trials[0].t<a id="_idTextAnchor391"/><a id="_idTextAnchor392"/>rial_name)</pre><p class="callout-heading">重要说明</p><p class="callout">请注意Trial和TrialSummary对象之间的差异，因为Trial对象包含的属性比TrialSummary对象多。</p></li>
				<li>Check the properties and functions of the Trial object using the dir() function:<pre><strong class="bold">dir</strong>(trial)</pre><p>这个shou <a id="_idTextAnchor393"/> ld <a id="_idTextAnchor394"/>给我们一个试验对象的有效属性和函数(方法)的列表，比如add_trial_component、delete_all、list_trial_components、trial_name和trial_arn。</p></li>
				<li>Load the trial components linked to the trial as a list of TrialComponentSummary objects using the list_trial_components() function:<pre>trial_component_summary_list = list(
    trial.<strong class="bold">list_trial_components</strong>()
)
trial_component_summary_list</pre><p>这将产生一组类似于图5.29 中所示的结果:</p><div><img src="img/B16850_05_29.jpg" alt="Figure 5.29 – List of TrialComponentSummary objects after using the list_trial_components() function&#13;&#10;" width="1532" height="714"/></div><p class="figure-caption">图5.29–使用list_trial_components()函数后的TrialComponentSummary对象列表</p><p>在<em class="italic">图5.29 </em>中，我们可以<a id="_idIndexMarker1133"/>看到一个列表<a id="_idIndexMarker1134"/>中的TrialComponentSummary对象<a id="_idIndexMarker1135"/>对应于<a id="_idIndexMarker1136"/>每个试验<a id="_idTextAnchor395"/>组件所链接的试验。与实验摘要对象类似的<a id="_idIndexMarker1137"/>，TrialComponentSumary对象包含的信息比其对应的【TrialComponent对象少。</p></li>
				<li>使用TrialComponent.load(): <a id="_idTextAnchor396"/> <pre><a id="_idTextAnchor397"/>tcs = trial_component_summary_list[0] trial_component_summary = tcs tc_name = tcs.trial_component_name       trial_component = <strong class="bold">TrialComponent.load</strong>(     trial_component_name=tc_name)</pre>加载相应的试验对象</li>
				<li>List the properties and functions using the dir() function:<pre><strong class="bold">dir</strong>(trial_component)</pre><p>这将为我们提供一个trial_component对象的有效属性列表，比如input_artifacts、output_artifacts、parameters、trial_component_name和trial_component_arn。</p></li>
				<li>Inspect<a id="_idIndexMarker1139"/> the input_artifacts value <a id="_idIndexMarker1140"/>of trial_component:<pre>trial_component.<strong class="bold">input_artifacts</strong></pre><p>这应该给<a id="_idIndexMarker1141"/>我们一个类似于<a id="_idIndexMarker1143"/>的<a id="_idIndexMarker1142"/>值字典，如图<em class="italic">图5.30 </em>所示:</p><div><img src="img/B16850_05_30.jpg" alt="Figure 5.30 – trial_component.input_artifacts&#13;&#10;" width="1519" height="135"/></div><p class="figure-caption">图5.30–试验组件输入工件</p><p>在<em class="italic">图5.30 </em>中，我们有一个字典，其中包含分别指向training_data.csv和validation_csv数据集的S3路径。</p></li>
				<li>Inspect the output_artifacts value of trial_component:<pre>trial_component.<strong class="bold">output_artifacts</strong></pre><p>以下是输出:</p><div><img src="img/B16850_05_31.jpg" alt="Figure 5.31 – trial_component.output_artifacts&#13;&#10;" width="1528" height="75"/></div><p class="figure-caption">图5.31–试验_组件.输出_工件</p><p>在<em class="italic">图5.31 </em>中，我们有一本带有SageMaker的字典。ModelArtifact键和设置为TrialComponentArtifact对象的<a id="_idIndexMarker1144"/>值，S3路径指向model.tar.gz文件。</p></li>
				<li>Inspect <a id="_idIndexMarker1145"/>the parameters value of trial_component:<pre>trial_component.<strong class="bold">parameters</strong></pre><p>这应该会给我们一个类似于图5.32 中所示的值的字典:</p><div><img src="img/B16850_05_32.jpg" alt="Figure 5.32 – trial_component.parameters&#13;&#10;" width="792" height="212"/></div><p class="figure-caption">图5.32–试验组件参数</p><p>我们在<em class="italic">图5.32 </em>中有<a id="_idIndexMarker1146"/>一个<a id="_idIndexMarker1147"/>字典<a id="_idIndexMarker1148"/>，带有用于<a id="_idIndexMarker1149"/>培训作业<a id="_idIndexMarker1150"/>配置的键值对，包括SageMaker。ImageURI和SageMaker。InstanceCount和超参数，如eta、gamma和max_depth。</p></li>
				<li>Inspect the metrics value of trial_component:<pre>trial_component.<strong class="bold">metrics</strong></pre><p>这应该<a id="_idIndexMarker1151"/>给我们一个类似于<em class="italic">图5.33 </em>所示的对象列表:</p></li>
			</ol>
			<div><div><img src="img/B16850_05_33.jpg" alt="Figure 5.33 – trial_component.metrics&#13;&#10;" width="1539" height="244"/>
				</div>
			</div>
			<p class="figure-caption">图5.33–试用组件.度量</p>
			<p>在图5.33中，我们有两个TrialComponentMetricSummary对象，一个用于训练:误差度量，另一个用于验证:误差度量。</p>
			<p>现在，让我们看看这是如何工作的！</p>
			<h2 id="_idParaDest-255">它是如何工作的…</h2>
			<p>当使用smexperiments库时，必须注意实验、试验和试验组件类和对象有它们自己相应的摘要副本，具有最少数量的属性和特性。</p>
			<p>正如在这个食谱的<em class="italic">如何做… </em>部分中所看到的，在使用Experiment.list()函数之后，我们将获得一个实验摘要对象的列表。然后，我们必须使用Experiment.load()函数来获取完整的实验对象，该对象包含更多的属性，包括描述和response_metadata。以类似的方式，在使用<a id="_idIndexMarker1153"/>Experiment . list _ trials()函数后，我们将获得一个链接到实验对象的TrialSummary对象列表。为了获得完整的试验对象，我们需要<a id="_idIndexMarker1154"/>通过传递<a id="_idIndexMarker1156"/>Trial summary对象的trial_name值来使用Trial.load()函数<a id="_idIndexMarker1155"/>。最后，一旦有了试用对象，我们只需使用trial.list_trial_components()函数和TrialComponent.load()函数来获取TrialComponent对象。这些TrialComponent对象包含度量值、位置、输入和输出工件的详细信息、训练作业开始时指定的超参数以及实验运行时跟踪的其他属性<a id="_idIndexMarker1157"/>。</p>
			<h2 id="_idParaDest-256">还有更多…</h2>
			<p>我们实际上可以<a id="_idIndexMarker1158"/>在SageMaker Studio中搜索、检查和比较<a id="_idIndexMarker1159"/>实验、试验和试验组件实体的不同属性和特性。</p>
			<div><div><img src="img/B16850_05_34.jpg" alt="Figure 5.34 – Inspecting Trial components in SageMaker Studio&#13;&#10;" width="1160" height="641"/>
				</div>
			</div>
			<p class="figure-caption">图5.34-在SageMaker Studio中检查试验组件</p>
			<p>在<em class="italic">图5.34 </em>中，我们可以看到所选试验组件内部跟踪的不同参数。这些参数包括训练配置参数以及训练作业开始前指定的超参数值。</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor401"/>参见</h2>
			<p>我们将无法讨论SageMaker实验的<a id="_idIndexMarker1160"/>其他功能和解决方案，因此我们将提供相关参考和示例的链接:</p>
			<ul>
				<li>清理SageMaker实验资源:<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/experiments-cleanup.html">https://docs . AWS . Amazon . com/sage maker/latest/DG/experiments-clean up . html</a></li>
				<li>使用SageMaker Studio和SageMaker Experiments简化建模:<a href="https://github.com/aws-samples/modeling-with-amazon-sagemaker-experiments/blob/dad91afb3ed4a0f0c0dff00cc978825972eb2936/modeling-with-amazon-sagemaker-experiments.ipynb">https://github . com/AWS-samples/modeling-with-Amazon-sage maker-Experiments/blob/dad 91 AFB 3 ed 4 a 0 f 0 c 0 dff 00 cc 978825972 EB 2936/modeling-with-Amazon-sage maker-Experiments . ipynb</a></li>
			</ul>
			<p>注意，在这一点上我们还没有正式介绍<strong class="bold"> SageMaker Studio </strong>。不要担心，我们将在下一章讨论这个问题！</p>
		</div>
	</div>
</body></html>