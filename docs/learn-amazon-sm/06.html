<html><head/><body>





<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style>
<div><div><h1 id="_idParaDest-71"><a id="_idTextAnchor069"/>第四章:训练机器学习模型</h1>
			<p>在前一章中，您学习了亚马逊 SageMaker Autopilot 如何轻松地自动构建、训练和优化模型，而无需编写一行机器学习代码。</p>
			<p>对于 SageMaker Autopilot 不支持的问题类型，下一个最佳选择是使用 SageMaker 中已经实现的算法之一，并在您的数据集上对其进行训练。这些算法被称为<strong class="bold">内置算法</strong>，它们涵盖了许多典型的机器学习问题，从分类到时间序列再到异常检测。</p>
			<p>在本章中，您将了解用于监督和非监督学习的内置算法，使用它们可以解决什么类型的问题，以及如何将它们与 SageMaker SDK 一起使用:</p>
			<ul>
				<li>发现 Amazon SageMaker 中的内置算法</li>
				<li>使用内置算法训练和部署模型</li>
				<li>使用带有内置算法的 SageMaker SDK</li>
				<li>使用更多内置算法</li>
			</ul>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor070"/>技术要求</h1>
			<p>您将需要一个 AWS 帐户来运行本章中包含的示例。如果您还没有，请将浏览器指向<a href="https://aws.amazon.com/getting-started/">https://aws.amazon.com/getting-started/</a>来创建一个。您还应该熟悉 AWS 免费层(<a href="https://aws.amazon.com/free/">https://aws.amazon.com/free/</a>)，它允许您在一定的使用限制内免费使用许多 AWS 服务。</p>
			<p>您需要为您的帐户(<a href="https://aws.amazon.com/cli/">https://aws.amazon.com/cli/</a>)安装和配置 AWS 命令行界面(CLI)。</p>
			<p>您将需要一个工作的 Python 3.x 环境。安装 Anaconda 发行版(<a href="https://www.anaconda.com/">https://www.anaconda.com/</a>)不是强制性的，但是强烈建议安装，因为它包含了我们将需要的许多项目(Jupyter、<code>pandas</code>、<code>numpy</code>等等)。</p>
			<p>书中包含的代码示例可在 GitHub 上获得，网址为<a href="https://github.com/PacktPublishing/Learn-Amazon-SageMaker-second-edition">https://GitHub . com/packt publishing/Learn-Amazon-sage maker-second-edition</a>。你需要安装一个 Git 客户端来访问它们(<a href="https://git-scm.com/">https://git-scm.com/</a>)。</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor071"/>发现亚马逊 SageMaker 中的内置算法</h1>
			<p>内置算法是由亚马逊(<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html</a>)实现的，在某些情况下是发明的机器学习算法。他们让你快速训练<a id="_idIndexMarker263"/>和部署你自己的<a id="_idIndexMarker264"/>模型，而不用写一行机器学习代码。的确，既然训练和预测代码唾手可得，你就不必担心实现它，你可以专注于手头的机器学习问题。和往常一样，SageMaker 的基础设施得到了全面管理，为您节省了更多时间。</p>
			<p>在本节中，您将了解传统机器学习问题的内置算法。计算机视觉和自然语言处理的算法将在接下来的两章中讨论。</p>
			<h2 id="_idParaDest-74">监督学习</h2>
			<p>监督学习侧重于<a id="_idIndexMarker265"/>需要<a id="_idIndexMarker266"/>标记数据集的问题，例如回归或分类:</p>
			<ul>
				<li><strong class="bold">线性学习器</strong>构建线性模型来解决回归问题，正如<a id="_idIndexMarker267"/>以及分类问题(二元或多类)。</li>
				<li><strong class="bold">因式分解机器</strong>构建线性模型来解决<a id="_idIndexMarker268"/>回归问题，以及分类问题(二元或多类)。因式分解机器是线性模型的推广，它们非常适合高维、稀疏的<a id="_idIndexMarker269"/>数据集，例如推荐问题中的<a id="_idIndexMarker270"/>用户-项目交互矩阵。</li>
				<li><strong class="bold">K-最近邻</strong> ( <strong class="bold"> KNN </strong>)为回归和分类问题建立非参数模型<a id="_idIndexMarker271"/>。</li>
				<li><strong class="bold"> XGBoost </strong>为回归、分类和排序<a id="_idIndexMarker272"/>问题建立模型。XGBoost 可能是目前使用最广泛的机器学习算法，SageMaker 使用在 https://github.com/dmlc/xgboost<a href="https://github.com/dmlc/xgboost">可用的开源实现</a><a id="_idIndexMarker273"/>。</li>
				<li><strong class="bold"> DeepAR </strong>为多元时间序列建立预测模型。DeepAR <a id="_idIndexMarker274"/>是亚马逊发明的基于<strong class="bold">递归神经网络</strong>的<a id="_idIndexMarker275"/>算法，你可以在<a href="https://arxiv.org/abs/1704.04110">https://arxiv.org/abs/1704.04110</a>了解更多信息。</li>
				<li><strong class="bold"> Object2Vec </strong>从通用高维对象中学习低维<a id="_idIndexMarker276"/>嵌入。Object2Vec 是亚马逊发明的算法。</li>
				<li><strong class="bold"> BlazingText </strong>建立文本分类模型。这种算法是亚马逊发明的，你可以在 https://dl.acm.org/doi/10.1145/3146347.3146354 了解更多。</li>
			</ul>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor073"/>无监督学习</h2>
			<p>无监督的<a id="_idIndexMarker278"/>学习<a id="_idIndexMarker279"/>不需要带标签的数据集，并且包括聚类或异常检测等问题:</p>
			<ul>
				<li><strong class="bold"> K-means </strong>建立聚类模型。SageMaker 使用了网络规模 k-means 聚类算法的修改版本<a id="_idIndexMarker280"/>(<a href="https://www.eecs.tufts.edu/~dsculley/papers/fastkmeans.pdf">https://www.eecs.tufts.edu/~dsculley/papers/fastkmeans.pdf</a>)。</li>
				<li><strong class="bold">主成分分析</strong> ( <strong class="bold"> PCA </strong>)建立降维模型<a id="_idIndexMarker281"/>。</li>
				<li><strong class="bold">随机砍伐森林</strong>建立<a id="_idIndexMarker282"/>异常检测模型。</li>
				<li><strong class="bold"> IP Insights </strong>构建模型来识别 IPv4 地址的使用模式。这对于监控、网络安全等等很方便。</li>
				<li>BlazingText 计算单词向量，这是自然语言处理任务的一种非常有用的表示。</li>
			</ul>
			<p>我们将在本章的剩余部分详细讨论这些算法。</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor074"/>关于可扩展性的一句话</h2>
			<p>在我们开始用算法训练和部署模型之前，你<a id="_idIndexMarker285"/>可能想知道为什么你应该使用它们而不是它们在众所周知的库中的对应物，比如<code>scikit-learn</code>和<code>R</code>。</p>
			<p>首先，这些算法是由亚马逊团队实现和调整的，他们并不是机器学习的新手！已经投入了大量的努力来确保这些算法在 AWS 基础设施上尽可能快地运行，不管你使用什么类型的实例。此外，这些算法中的许多都支持开箱即用的<strong class="bold">分布式训练</strong>，允许您在一个完全托管的实例集群中分割模型训练。</p>
			<p>由于这一点，基准测试表明，这些算法通常比竞争对手的实现要好 10 倍。在许多情况下，它们也更具成本效益。您可以通过以下网址了解更多信息:</p>
			<ul>
				<li>2018 年 AWS 特拉维夫峰会:<em class="italic">通过内置算法加快您的机器学习工作流程</em>:<a href="https://www.youtube.com/watch?v=IeIUr78OrE0">https://www.youtube.com/watch?v=IeIUr78OrE0</a></li>
				<li><em class="italic">亚马逊的弹性机器学习算法</em>，Liberty 等人，SIGMOD ' 20:sage maker:<a href="https://www.amazon.science/publications/elastic-machine-learning-algorithms-in-amazon-sagemaker">https://www . Amazon . science/publications/Elastic-Machine-Learning-Algorithms-in-Amazon-sage maker</a></li>
			</ul>
			<p>当然，这些算法受益于 SageMaker 中的所有特性，这一点你会在本书末尾发现。</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor075"/>使用内置算法训练和部署模型</h1>
			<p>Amazon SageMaker 让你在<a id="_idIndexMarker287"/>许多不同的配置中训练和部署模型。尽管它鼓励最佳实践，但它是一种模块化服务，让你可以用自己的方式做事情。</p>
			<p>在这一节中，我们将首先看一个典型的<a id="_idIndexMarker289"/>端到端工作流，其中我们使用 SageMaker <a id="_idIndexMarker290"/>从数据上传一直到模型部署。然后，我们将讨论替代工作流，以及如何挑选您需要的功能。最后，我们将深入了解一下，从基础架构的角度来看，当我们进行培训和部署时会发生什么。</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor076"/>了解端到端工作流程</h2>
			<p>让我们看一个典型的 SageMaker 工作流。你会在我们的例子中以及 GitHub(<a href="https://github.com/awslabs/amazon-sagemaker-examples/">https://github.com/awslabs/amazon-sagemaker-examples/</a>)上的 AWS 笔记本中再次看到它:</p>
			<ol>
				<li>【https://developers.google.com/protocol-buffers】(<a href="https://developers.google.com/protocol-buffers"/>)。</li>
				<li><strong class="bold">配置训练作业</strong>:在这里，您可以选择想要训练的算法，设置超参数，并定义训练作业的基础设施要求。</li>
				<li><strong class="bold">启动培训作业</strong>:这是我们传递你的数据集在 S3 的位置的地方。培训在托管基础架构上进行，根据您的需求自动创建和配置。一旦训练完成，<strong class="bold">模型工件</strong>被保存在 S3。培训基础设施自动终止，您只需为您使用的内容付费。</li>
				<li><strong class="bold">部署模型</strong>:您可以在<strong class="bold">实时 HTTPS 端点</strong>上部署模型，用于实时<a id="_idIndexMarker293"/>预测或<strong class="bold">批量转换</strong>。同样，您只需要定义基础设施需求。</li>
				<li><strong class="bold">预测数据</strong>:调用实时端点或批量转换器。如您所料，这里也管理基础设施。对于生产，您还需要监控数据和预测的质量。</li>
				<li><strong class="bold">清理！</strong>:这包括关闭终端，以避免不必要的费用。</li>
			</ol>
			<p>理解这个工作流程对亚马逊 SageMaker 的<a id="_idIndexMarker294"/>工作效率至关重要。幸运的是，SageMaker SDK 有与这些步骤非常匹配的简单 API，所以您不应该对使用哪一个或何时使用它感到困惑。</p>
			<p>在我们开始研究 SDK 之前，让我们考虑一下在您的业务和技术环境中有意义的替代工作流。</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor077"/>使用替代工作流程</h2>
			<p>亚马逊 SageMaker 是一个模块化服务<a id="_idIndexMarker295"/>，让你按照自己的方式工作。让我们首先考虑一个工作流，在这个工作流中，您将在 SageMaker 上进行培训，并在您自己的服务器上进行部署，不管原因是什么。</p>
			<h3>导出模型</h3>
			<p>步骤 1-3 将与前面的<a id="_idIndexMarker296"/>示例相同，然后您将执行以下操作:</p>
			<ol>
				<li value="1">从 S3 下载训练神器，物化为<code>model.tar.gz</code>文件。</li>
				<li>提取存储在工件中的模型。</li>
				<li>在您自己的服务器上，用适当的机器学习库加载模型:<ul><li><code>fastText</code>在<a href="https://fasttext.cc/">https://fasttext.cc/</a>实施。</li><li><strong class="bold">对于所有其他型号</strong>:使用<strong class="bold">阿帕奇 MXNet</strong>(<a href="https://mxnet.apache.org/">https://mxnet.apache.org/</a>)。</li></ul></li>
			</ol>
			<p>现在，让我们看看如何导入一个现有的模型并将其部署在 SageMaker 上。</p>
			<h3>导入模型</h3>
			<p>步骤同样简单:</p>
			<ol>
				<li value="1">将您的<a id="_idIndexMarker298"/>模型打包到一个模型工件中(<code>model.tar.gz</code>)。</li>
				<li>把藏物上传到 S3 桶里。</li>
				<li>将工件注册为 SageMaker 模型。</li>
				<li>部署模型并预测。</li>
			</ol>
			<p>这只是快速浏览一下。我们将在第 11 章 、<em class="italic">部署机器学习模型</em>中运行两个工作流的完整示例。</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor078"/>使用完全托管的基础设施</h2>
			<p>所有 SageMaker 的工作都是在托管的<a id="_idIndexMarker299"/>基础设施上运行的。让我们看一下引擎盖下面，看看当我们训练和部署模型时会发生什么。</p>
			<h3>Docker 容器中的打包算法</h3>
			<p>所有 SageMaker 算法必须打包在<strong class="bold"> Docker </strong>容器中。别担心，为了使用 SageMaker，你不需要太了解 Docker。如果你对它不熟悉，我推荐你阅读这篇教程来理解关键概念和工具:<a href="https://docs.docker.com/get-started/">https://docs.docker.com/get-started/</a>。知道的比实际需要的多一点总是好的！</p>
			<p>正如你所期望的，内置算法是预先打包好的，容器很容易用于训练和部署。它们托管在<strong class="bold">亚马逊弹性容器注册中心</strong> ( <strong class="bold"> ECR </strong>)，AWS 的 Docker <a id="_idIndexMarker303"/>注册服务中心(<a href="https://aws.amazon.com/ecr/">https://aws.amazon.com/ecr/</a>)。由于 ECR 是基于地区的服务，您将在 SageMaker 可用的每个地区找到一组容器。</p>
			<p>你可以<a id="_idIndexMarker304"/>在<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html">https://docs . AWS . Amazon . com/sage maker/latest/DG/sage maker-algo-docker-registry-paths . html</a>找到内置算法容器列表。例如，eu-west-1 区域中线性学习算法的容器名称是<code>438346466558.dkr.ecr.eu-west-1.amazonaws.com/linear-learner:latest</code>。这些容器只能被拉至 SageMaker 管理的实例，因此您将无法在本地机器上运行它们。</p>
			<p>现在，让我们看看底层基础架构。</p>
			<h3>创建培训基础设施</h3>
			<p>当您启动一个培训任务时，SageMaker 会根据您的<a id="_idIndexMarker305"/>需求(实例类型和实例数量)启动基础设施。</p>
			<p>一旦培训实例投入使用，它就会从 ECR 中提取适当的培训容器。超参数应用于算法，该算法还接收数据集的位置。默认情况下，该算法会从 S3 复制完整的数据集，然后开始训练。如果配置了分布式训练，SageMaker 会自动将数据集批次分发到集群中的不同实例。</p>
			<p>一旦训练完成，模型就被打包到保存在 S3 的模型工件中。然后，训练基础设施被<a id="_idIndexMarker306"/>自动关闭。日志可以在<strong class="bold">亚马逊 CloudWatch 日志</strong>中找到。最后但并非最不重要的是，你只需支付确切的培训时间。</p>
			<h3>创建预测基础设施</h3>
			<p>当您启动一个部署作业时，SageMaker 会根据您的需求再次创建基础设施<a id="_idIndexMarker307"/>。</p>
			<p>现在让我们关注实时端点，而不是批量转换。</p>
			<p>一旦一个端点实例投入使用，它将从 ECR 中提取适当的预测容器，并从 S3 加载您的模型。然后，HTTPS 端点被调配，并在几分钟内准备好进行预测。</p>
			<p>如果您为端点配置了多个实例，负载平衡和高可用性会自动设置。如果您配置了<strong class="bold">自动缩放</strong>，这同样适用。</p>
			<p>如您所料，端点会一直保持运行，直到被显式删除，无论是在 AWS 控制台中还是通过 SageMaker API 调用。在此期间，您将被收取端点费用，因此<strong class="bold">请务必删除您不需要的端点！</strong></p>
			<p>既然我们已经了解了全局，让我们开始看看 SageMaker SDK，以及我们如何使用它来训练和部署模型。</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor079"/>使用带有内置算法的 SageMaker SDK</h1>
			<p>熟悉 SageMaker SDK 对于充分利用 SageMaker 非常重要。你可以在<a href="https://sagemaker.readthedocs.io">https://sagemaker . readthedocs . io</a>找到它的文档。</p>
			<p>完成一个简单的例子是最好的开始方式。在本节中，我们将使用线性学习器算法在波士顿住房数据集(<a href="https://www.kaggle.com/c/boston-housing">https://www.kaggle.com/c/boston-housing</a>)上训练一个回归模型。我们会慢慢来，不遗余力。同样，这些概念是必不可少的，所以请慢慢来，并确保你完全理解每一步。</p>
			<p class="callout-heading">催单</p>
			<p class="callout">我建议您跟随并运行配套的 GitHub 资源库中的代码。我们已经尽了最大努力来检查文本中出现的所有代码示例。然而，对于那些有电子版的人来说，复制和粘贴可能会产生不可预知的结果:格式问题、奇怪的引用等等。</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor080"/>准备数据</h2>
			<p>内置算法期望数据集是某种格式，比如<strong class="bold"> CSV </strong>、<strong class="bold"> protobuf </strong>或者<strong class="bold"> libsvm </strong>。算法文档中列出了支持的格式。例如，线性学习者支持 CSV 和 RecordIO 包装的 proto buf(<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/linear-learner.html#ll-input_output">https://docs . AWS . Amazon . com/sage maker/latest/DG/Linear-Learner . html # ll-input _ output</a>)。</p>
			<p>我们的输入数据集已经以 CSV 格式存在于存储库中，所以让我们使用它。数据集准备将非常简单，我们将手动运行它:</p>
			<ol>
				<li value="1">使用<code>pandas</code>，我们用熊猫<pre>import pandas as pd dataset = pd.read_csv('housing.csv')</pre>加载<a id="_idIndexMarker311"/> CSV 数据集</li>
				<li>Then, we print the shape of the dataset:<pre>print(dataset.shape)</pre><p>它包含 506 个样品和 13 列:</p><pre><strong class="bold">(506, 13)</strong></pre></li>
				<li>Now, we display the first 5 lines of the dataset:<pre>dataset[:5]</pre><p>这将打印出下图中可见的表格。对于每栋房子，我们看到 12 个特征，以及一个目标属性(<code>medv</code>)设置为房子的中值，单位为千美元:</p><div><img src="img/B17705_04_1.jpg" alt="Figure 4.1 – Viewing the dataset&#13;&#10;" width="618" height="163"/></div><p class="figure-caption">图 4.1–查看数据集</p></li>
				<li>阅读<a id="_idIndexMarker312"/>算法文档(<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/cdf-training.html">https://docs . AWS . Amazon . com/SageMaker/latest/DG/CDF-training . html</a>，我们看到<em class="italic"> Amazon SageMaker 要求 CSV 文件没有头记录，目标变量在第一列</em>。相应地，我们将<code>medv</code>列移动到数据帧的前面:<pre>dataset = pd.concat([dataset['medv'],                      dataset.drop(['medv'], axis=1)],                       axis=1)</pre></li>
				<li>一点<code>scikit-learn</code>的魔力有助于将数据框架分成两部分——90%用于训练，10%用于验证:<pre>from sklearn.model_selection import train_test_split training_dataset, validation_dataset =       train_test_split(dataset, test_size=0.1)</pre></li>
				<li>我们将这两个分割保存到单独的 CSV 文件中，没有索引或标题:<pre>training_dataset.to_csv('training_dataset.csv',                          index=False, header=False) validation_dataset.to_csv('validation_dataset.csv',                            index=False, header=False)</pre></li>
				<li>我们现在需要将这两个文件上传到 S3。我们可以使用任何 bucket，这里我们将使用 SageMaker 在我们正在运行的区域中方便地创建的默认 bucket。我们可以用<code>sagemaker.Session.default_bucket()</code> API 找到它的名字:<pre>import sagemaker sess = sagemaker.Session() bucket = sess.default_bucket()</pre></li>
				<li>Finally, we use the <code>sagemaker.Session.upload_data()</code> API to upload the two <strong class="bold">CSV</strong> files to the default bucket. Here, the training and validation datasets are made of a single file each, but we could upload multiple files if needed. For this reason, <strong class="bold">we must upload the datasets under different S3 prefixes</strong>, so that their files won't be mixed up:<pre>prefix = 'boston-housing'
training_data_path = sess.upload_data(
    path='training_dataset.csv', 
    key_prefix=prefix + '/input/training')
validation_data_path = sess.upload_data(
    path='validation_dataset.csv', 
    key_prefix=prefix + '/input/validation')
print(training_data_path)
print(validation_data_path)</pre><p>两条 S3 路径如下所示。当然，默认存储桶名称中的帐号会有所不同:</p><pre><strong class="bold">s3://sagemaker-eu-west-1-123456789012/boston-housing/input/training/training_dataset.csv</strong>
<strong class="bold">s3://sagemaker-eu-west-1-123456789012/boston-housing/input/validation/validation_dataset.csv</strong></pre></li>
			</ol>
			<p>既然数据已经在 S3 准备好了，我们就可以配置培训作业了。</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor081"/>配置培训工作</h2>
			<p><code>Estimator</code>对象(<code>sagemaker.estimator.Estimator</code>)是模型<a id="_idIndexMarker314"/>训练的基石。它允许您选择适当的算法，定义您的培训基础设施要求，等等。</p>
			<p>SageMaker SDK 还包括特定于算法的估算器，如<code>sagemaker.LinearLearner</code>或<code>sagemaker.PCA</code>。我通常发现它们没有一般的估计器灵活(首先，没有 CSV 支持)，我不推荐使用它们。使用<code>Estimator</code>对象还可以让您跨示例重用代码，我们将在接下来的章节中看到:</p>
			<ol>
				<li value="1">在本章的前面，我们了解到 SageMaker 算法被打包在 Docker 容器中。使用<code>boto3</code>和<code>image_uris.retrieve()</code> API，我们可以很容易地在我们运行的区域找到线性学习算法的名字:<pre>from sagemaker import get_execution_role from sagemaker.image_uris import retrieve region = sess.boto_session.region_name container = retrieve('linear-learner', region)</pre></li>
				<li>Now that we know the name of the container, we can configure our training job with the <code>Estimator</code> object. In addition to the container name, we also pass the IAM role that SageMaker instances will use, the instance type and instance count to use for training, as well as the output location for the model. <code>Estimator</code> will generate a training job automatically, and we could also set our own prefix with the <code>base_job_name</code> parameter:<pre>from sagemaker.estimator import Estimator
ll_estimator = Estimator(
    container,
    role=sagemaker.get_execution_role(),
    instance_count=1,
    instance_type='ml.m5.large',
    output_path='s3://{}/{}/output'.format(bucket, 
                                           prefix))</pre><p>SageMaker <a id="_idIndexMarker315"/>支持大量不同的实例类型，在不同的 AWS 区域之间会有一些差异。你可以在<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/instance-types-az.html">https://docs . AWS . Amazon . com/sage maker/latest/DG/instance-types-az . html</a>找到完整的列表。</p><p>我们应该在这里使用哪一个？查看线性学习器文档(<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/linear-learner.html#ll-instances">https://docs . AWS . Amazon . com/sagemaker/latest/DG/Linear-Learner . html # ll-instances</a>)，我们看到<em class="italic">可以在单机或多机 CPU 和 GPU 实例上训练线性学习器算法</em>。这里，我们正在使用一个很小的数据集，所以让我们选择我们区域中可用的最小的训练实例:<code>ml.m5.large</code>。</p><p>检查定价页面(<a href="https://aws.amazon.com/sagemaker/pricing/">https://aws.amazon.com/sagemaker/pricing/</a>)，我们看到这个实例在欧盟-西方-1 地区每小时花费 0.128 美元(我在这个工作中使用的就是这个)。</p></li>
				<li>Next, we have to set <code>predictor_type</code>. It defines the type of problem that Linear Learner is training on (regression, binary classification, or multiclass classification). <p>更深入地看，我们看到<code>mini_batch_size</code>的默认值是 1000:这个<a id="_idIndexMarker318"/>不适合我们的 506 样本数据集，所以让我们把它设置为 32。我们还了解到<code>normalize_data</code>参数在默认情况下被设置为 true，这使得我们没有必要自己标准化数据:</p><pre>ll_estimator.set_hyperparameters(
    predictor_type='regressor', 
    mini_batch_size=32)</pre></li>
				<li>Now, let's define the data channels: a channel is a named source of data passed to a SageMaker estimator. All built-in algorithms need at least a training channel, and many also accept additional channels for validation and testing. Here, we have two channels, which both provide data in CSV format. The <code>TrainingInput()</code> API lets us define their location, their format, whether they are compressed, and so on:<pre>from sagemaker import TrainingInput
training_data_channel = TrainingInput(
    s3_data=training_data_path, 
    content_type='text/csv')
validation_data_channel = TrainingInput(
    s3_data=validation_data_path,  
    content_type='text/csv')</pre><p>默认情况下，由通道提供的数据<a id="_idIndexMarker319"/>将被完全复制到每个训练实例，这对于小数据集来说很好。我们将在<a href="B17705_10_Final_JM_ePub.xhtml#_idTextAnchor206"> <em class="italic">第十章</em></a><em class="italic">高级训练技巧</em>中研究替代方案。</p></li>
			</ol>
			<p>现在，培训的一切准备就绪，让我们开始工作吧。</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor082"/>启动培训工作</h2>
			<p>它只需要一行代码:</p>
			<ol>
				<li value="1">We simply pass a Python dictionary containing the two channels to the <code>fit()</code> API:<pre>ll_estimator.fit(
    {'train': training_data_channel, 
     'validation': validation_data_channel})</pre><p>培训工作立即开始:</p><pre><strong class="bold">Starting - Starting the training job.</strong></pre></li>
				<li>一旦作业启动，它就会出现在<strong class="bold"> SageMaker 组件和注册表</strong> | <strong class="bold">实验和试验</strong>面板中。在那里，您可以看到所有的作业元数据:数据集的位置、超参数等等。</li>
				<li>训练日志在笔记本中可见，也存储在亚马逊 CloudWatch 日志中，前缀为<code>/aws/sagemaker/TrainingJobs</code>。下面是前几行，显示了正在调配的基础架构，如前面的<em class="italic">使用完全托管的基础架构</em>部分所述:<pre><strong class="bold">Starting - Starting the training job...</strong> <strong class="bold">Starting - Launching requested ML instances......</strong> <strong class="bold">Starting - Preparing the instances for training...</strong> <strong class="bold">Downloading - Downloading input data...</strong> <strong class="bold">Training - Training image download completed.</strong></pre></li>
				<li>在训练日志的最后，我们看到了关于<strong class="bold">均方误差</strong> ( <strong class="bold"> MSE </strong>)和损失度量的信息:<pre><strong class="bold">#quality_metric: host=algo-1, validation mse &lt;loss&gt;=13.7226685169</strong> <strong class="bold">#quality_metric: host=algo-1, validation absolute_loss &lt;loss&gt;=2.86944983987</strong></pre></li>
				<li>一旦训练完成，模型会自动复制到 S3，SageMaker 会告诉我们这项工作花了多长时间:<pre><code>ml.m5.large</code> instance is $0.128 per hour. As we trained for 49 seconds, this job cost us (49/3600)*0.128= $0.00174 – less than a fifth of a penny. Any time spent setting up infrastructure ourselves would have certainly cost more!</pre></li>
				<li>查看我们的 S3 存储桶中的输出<a id="_idIndexMarker321"/>位置，我们看到模型工件:<pre><code>model.tar.gz</code>.</pre></li>
			</ol>
			<p>我们将在<a href="B17705_11_Final_JM_ePub.xhtml#_idTextAnchor237"> <em class="italic">第十一章</em> </a>、<em class="italic">部署机器学习模型</em>中看到，那个工件里面有什么，以及如何在 SageMaker 之外部署模型。现在，让我们将它部署到一个实时端点。</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor083"/>部署模型</h2>
			<p>这是我最喜欢的 SageMaker 的<a id="_idIndexMarker322"/>部分；我们只需要一行代码就可以将一个模型部署到一个 HTTPS 端点上:</p>
			<ol>
				<li value="1">It's good practice to create identifiable and unique endpoint names. We could also let SageMaker create one for us during deployment:<pre>from time import strftime, gmtime
timestamp = strftime('%d-%H-%M-%S', gmtime())
endpoint_name = 'linear-learner-demo-'+timestamp
print(endpoint_name)</pre><p>这里，端点名为<code>linear-learner-demo-29-08-37-25</code>。</p></li>
				<li>We deploy the model using the <code>deploy()</code> API. As this is a test endpoint, we use the smallest endpoint instance available, <code>ml.t2.medium</code>. In the eu-west-1 region, this will only cost us $0.07 per hour:<pre>ll_predictor = ll_estimator.deploy(
    endpoint_name=endpoint_name,
    initial_instance_count=1,
    instance_type='ml.t2.medium')</pre><p>当端点被创建时，我们可以在 SageMaker Studio 的<strong class="bold"> SageMaker 组件和注册表</strong> | <strong class="bold">端点</strong>面板中看到它。</p></li>
				<li>A few minutes later, the endpoint is in service. We can use the <code>predict()</code> API to send it a CSV sample for prediction. We set serialization using built-in functions:<pre>ll_predictor.serializer =   
    sagemaker.serializers.CSVSerializer()
ll_predictor.deserializer =
    sagemaker.deserializers.CSVDeserializer()
test_sample = '0.00632,18.00,2.310,0,0.5380,6.5750,65.20,4.0900,1,296.0,15.30,4.98'
response = ll_predictor.predict(test_sample)
print(response)</pre><p>预测结果告诉我们，这栋房子的价格应该是 30，173 美元:</p><pre> <strong class="bold">[['30.17342185974121']]</strong></pre><p>我们还可以一次预测多个样本:</p><pre>test_samples = [
'0.00632,18.00,2.310,0,0.5380,6.5750,65.20,4.0900,1,296.0,15.30,4.98',
'0.02731,0.00,7.070,0,0.4690,6.4210,78.90,4.9671,2,242.0,17.80,9.14']
response = ll_predictor.predict(test_samples)
print(response)</pre><p>现在<a id="_idIndexMarker324"/>预测输出如下:</p><pre><strong class="bold"> [['30.413358688354492'],['24.884408950805664']]</strong></pre></li>
			</ol>
			<p>当我们使用完端点后，<strong class="bold">我们不应该忘记删除它，以避免不必要的费用</strong>。</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor084"/>清理</h2>
			<p>删除一个<a id="_idIndexMarker325"/>端点就像调用<code>delete_endpoint()</code> API 一样简单:</p>
			<pre>ll_predictor.delete_endpoint()</pre>
			<p>冒着重复我自己的风险，这一部分涉及的主题非常重要，所以请确保你完全熟悉它们，因为我们将在本书的其余部分不断使用它们。请花些时间阅读服务和 SDK 文档:</p>
			<ul>
				<li><a href="https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html">https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html</a></li>
				<li><a href="https://sagemaker.readthedocs.io">https://sagemaker . readthedocs . io</a></li>
			</ul>
			<p>现在让我们探索其他内置算法。你会发现工作流程和代码非常相似！</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor085"/>使用更多内置算法</h1>
			<p>在本章的剩余部分，我们将运行<a id="_idIndexMarker327"/>更多内置算法的例子，包括监督和非监督模式。这将帮助您非常熟悉 SageMaker SDK，并学习如何解决实际的机器学习问题。以下列表显示了其中的一些算法:</p>
			<ul>
				<li>使用 XGBoost 分类</li>
				<li>因子分解机推荐</li>
				<li>主成分分析降维</li>
				<li>随机砍伐森林的异常检测</li>
			</ul>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor086"/>用 XGBoost 回归</h2>
			<p>让我们用<strong class="bold"> XGBoost </strong>算法(<a href="https://github.com/dmlc/xgboost">https://github.com/dmlc/xgboost</a>)在波士顿住房数据集上训练一个模型<a id="_idIndexMarker328"/>。正如我们将在<a href="B17705_07_Final_JM_ePub.xhtml#_idTextAnchor130"> <em class="italic">第 7 章</em> </a>、<em class="italic">使用内置框架扩展机器学习服务</em>中看到的，SageMaker <a id="_idIndexMarker329"/>也支持 XGBoost 脚本:</p>
			<ol>
				<li value="1">我们重用前面示例中的数据集准备步骤。</li>
				<li>我们找到 XGBoost 容器的名称。由于支持多个版本，我们选择最新的版本(撰写本文时为 1 . 3 . 1):<pre>from sagemaker import image_uris region = sess.boto_session.region_name      container = image_uris.retrieve('xgboost', region,                                  version='latest')</pre></li>
				<li>我们配置<code>Estimator</code>功能。该代码与<code>LinearLearner</code> : <pre>xgb_estimator = Estimator(    container,    role=sagemaker.get_execution_role(),    instance_count=1,    instance_type='ml.m5.large',    output_path='s3://{}/{}/output'.format(bucket,                                            prefix))</pre>使用的代码完全相同</li>
				<li>看一下超参数(<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/xgboost_hyperparameters.html">https://docs . AWS . Amazon . com/sagemaker/latest/DG/xgboost _ hyperparameters . html</a>)，我们看到唯一需要的是<code>num_round</code>。由于设置哪个<a id="_idIndexMarker330"/>值并不明显，我们将选择一个较大的值，并且我们还将定义<code>early_stopping_rounds</code>参数以避免过度拟合。当然，我们需要为一个回归问题设定目标:<pre>xgb_estimator.set_hyperparameters(     objective='reg:linear',     num_round=200,     early_stopping_rounds=10)</pre></li>
				<li>我们定义训练输入，就像前面的例子一样:<pre>from sagemaker import TrainingInput training_data_channel = TrainingInput(     s3_data=training_data_path,      content_type='text/csv') validation_data_channel = TrainingInput(     s3_data=validation_data_path,       content_type='text/csv')</pre></li>
				<li>然后，我们启动培训作业:<pre>xgb_estimator.fit(     {'train': training_data_channel,       'validation': validation_data_channel})</pre></li>
				<li>该作业仅运行了 22 轮，这意味着<strong class="bold">提前停止</strong>被触发。查看训练日志，我们<a id="_idIndexMarker331"/>看到第 12 轮实际上是<a id="_idIndexMarker332"/>最好的一轮，其<strong class="bold">均方根误差</strong> ( <strong class="bold"> RMSE </strong>)为 2.43126: <pre><strong class="bold">[12]#011train-rmse:1.25702#011validation-rmse:2.43126</strong> <strong class="bold">&lt;output removed&gt;</strong> <strong class="bold">[22]#011train-rmse:0.722193#011validation-rmse:2.43355</strong></pre></li>
				<li>部署仍然需要一行代码:<pre>from time import strftime, gmtime timestamp = strftime('%d-%H-%M-%S', gmtime()) endpoint_name = 'xgb-demo'+'-'+timestamp xgb_predictor = xgb_estimator.deploy(     endpoint_name=endpoint_name,     initial_instance_count=1,     instance_type='ml.t2.medium')</pre></li>
				<li>Once the model is deployed, we use the <code>predict()</code> API again to send it a CSV sample:<pre>test_sample = '0.00632,18.00,2.310,0,0.5380,6.5750,65.20,4.0900,1,296.0,15.30,4.98'
xgb_predictor.serializer =
    sagemaker.serializers.CSVSerializer()
xgb_predictor.deserializer =
    sagemaker.deserializers.CSVDeserializer()
response = xgb_predictor.predict(test_sample)
print(response)</pre><p>结果<a id="_idIndexMarker333"/>告诉我们这栋房子应该值 23，754 美元:</p><pre><strong class="bold">[['23.73023223876953']]</strong></pre></li>
				<li>最后，我们完成后删除端点:<pre>xgb_predictor.delete_endpoint()</pre></li>
			</ol>
			<p>正如您所看到的，SageMaker 工作流非常简单，可以很容易地快速试验不同的算法，而不必重写所有的代码。</p>
			<p>让我们继续讨论因式分解机算法。在这个过程中，我们将了解高效的 RecordIO 包装的 protobuf 格式。</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor087"/>用因式分解机推荐</h2>
			<p>因式分解机器是线性模型(<a href="https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf">https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf</a>)的概括<a id="_idIndexMarker334"/>。它非常适合高维稀疏数据集，例如用于推荐的用户-项目交互矩阵。</p>
			<p>在这个例子中，我们将<a id="_idIndexMarker336"/>基于<strong class="bold"> MovieLens </strong>数据集(<a href="https://grouplens.org/datasets/movielens/">https://grouplens.org/datasets/movielens/</a>)训练一个推荐模型。</p>
			<p>该数据集有多个版本。为了尽量减少培训时间，我们将使用 100k 版本。它包含 943 个用户对 1，682 部电影的 100，000 个评级(从 1 到 5 的整数值)。数据集已被拆分用于训练和验证。</p>
			<p>正如您现在所知道的<a id="_idIndexMarker337"/>，使用 SageMaker 进行培训和部署非常简单。大部分代码将与前两个示例相同，这太棒了！这让我们专注于理解和准备数据。</p>
			<h3>了解稀疏数据集</h3>
			<p>想象一下构建一个矩阵来存储这个数据集。它有 943 行(每个用户一行)和 1682 列(每个电影一列)。单元格将存储评级。下图显示了一个基本示例:</p>
			<div><div><img src="img/B17705_04_2.jpg" alt="Figure 4.2 – Sparse matrix&#13;&#10;" width="1134" height="388"/>
				</div>
			</div>
			<p class="figure-caption">图 4.2–稀疏矩阵</p>
			<p>因此，矩阵将具有 943*1，682=1，586，126 个单元。然而，由于只有 100，000 个评级，93.69%的单元格将是空的。以这种方式存储我们的数据集是非常低效的。存储和传输大量的零值会不必要地消耗 RAM、存储和网络带宽！</p>
			<p>事实上，情况要糟糕得多，因为算法预期输入数据集如下图所示:</p>
			<div><div><img src="img/B17705_04_3.jpg" alt="Figure 4.3 – Sparse matrix&#13;&#10;" width="1217" height="568"/>
				</div>
			</div>
			<p class="figure-caption">图 4.3–稀疏矩阵</p>
			<p>为什么我们需要以这种方式存储数据？答案很简单:因式分解机器是一种<strong class="bold">监督学习</strong>算法，所以我们需要在带标签的<a id="_idIndexMarker339"/>样本上训练它。</p>
			<p>看前面的图表，我们看到每一行代表一个电影评论。左边的矩阵<a id="_idIndexMarker340"/>存储它的独热编码特征(用户和电影)，右边的向量存储它的标签。例如，最后一行告诉我们用户 4 给了电影 5 一个“5”的评级。</p>
			<p>这个矩阵的大小是 100，000 行乘以 2，625 列(943 部电影加上 1，682 部电影)。细胞总数为 262，500，000，其中只有 0.076%充满(200，000 / 262，500，000)。如果我们对每个单元使用 32 位的值，我们将需要几乎 1gb 的内存来存储这个矩阵。这是非常低效的，但仍然是可管理的。</p>
			<p>只是为了好玩，让我们对最大版本的 MovieLens 做同样的练习，它有 2500 万个收视率，62，000 部电影，162，000 个用户。该矩阵将有 2500 万行和 224，000 列，总共有 5，600，000，000，000 个单元。是的，这是 5.6 万亿个单元，尽管它们有 99.999%是空的，但我们仍然需要超过 20tb 的 RAM 来存储它们。哎哟。如果这还不够糟糕，考虑一下拥有数百万用户和产品的推荐模型:这些数字令人难以置信！</p>
			<p>我们不使用<a id="_idIndexMarker341"/>普通矩阵，而是使用一个<code>SciPy</code>正好有我们需要的对象，名为<code>lil_matrix</code>(<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.lil_matrix.html">https://docs . scipy . org/doc/scipy/reference/generated/scipy . sparse . lil _ matrix . html</a>)。这将帮助我们摆脱所有这些讨厌的零。</p>
			<h3>了解 protobuf 和 RecordIO</h3>
			<p>那么我们如何将这个稀疏矩阵传递给 SageMaker 算法呢？如您所料，我们将序列化该对象并将其存储在 S3。然而，我们不打算使用 Python 序列化。相反，我们打算<a id="_idIndexMarker343"/>使用<code>protobuf</code>(<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>)，一种流行且高效的序列化机制。</p>
			<p>此外，我们将把 protobuf 编码的数据存储在名为<strong class="bold">RecordIO</strong>(【https://mxnet.apache.org/api/faq/recordio/】T21)的<a id="_idIndexMarker344"/>记录格式中。我们的数据集将作为一系列记录存储在一个文件中。这有以下好处:</p>
			<ul>
				<li>单个文件更容易移动:谁想处理成千上万可能丢失或损坏的单个文件呢？</li>
				<li>顺序文件的读取速度更快，这使得训练过程更有效。</li>
				<li>对于分布式训练来说，记录序列很容易拆分。</li>
			</ul>
			<p>如果您不熟悉 protobuf 和 RecordIO，也不用担心。SageMaker SDK 包括隐藏其复杂性的实用函数。</p>
			<h3>在 MovieLens 上建立因式分解机模型</h3>
			<p>我们将通过以下步骤开始<a id="_idIndexMarker346"/>构建模型:</p>
			<ol>
				<li value="1">在 Jupyter <a id="_idIndexMarker347"/>笔记本中，我们首先下载并提取 MovieLens 数据集:<pre>%%sh wget <strong class="bold">http://files.grouplens.org/datasets/movielens/ml-100k.zip</strong> unzip ml-100k.zip</pre></li>
				<li>As the dataset is ordered by user ID, we shuffle it as a precaution. Then, we take a look at the first few lines:<pre>%cd ml-100k
!shuf ua.base -o ua.base.shuffled
!head -5 ua.base.shuffled</pre><p>我们看到四列:用户 ID、电影 ID、评级和时间戳(在我们的模型中我们将忽略这一点):</p><pre><strong class="bold">378  43  3  880056609</strong>
<strong class="bold">919  558 5  875372988</strong>
<strong class="bold">90   285 5  891383687</strong>
<strong class="bold">249  245 2  879571999</strong>
<strong class="bold">416  64  5  893212929</strong></pre></li>
				<li>我们定义尺寸常数:<pre>num_users = 943 num_movies = 1682 num_features = num_users+num_movies num_ratings_train = 90570 num_ratings_test = 9430</pre></li>
				<li>现在，让我们编写一个函数<a id="_idIndexMarker348"/>将数据集<a id="_idIndexMarker349"/>加载到一个稀疏矩阵中。基于前面的解释，我们逐行检查数据集。在 X 矩阵中，我们将适当的用户和电影列设置为<code>1</code>。我们还将评级存储在 Y 向量中:<pre>import csv import numpy as np from scipy.sparse import lil_matrix def loadDataset(filename, lines, columns):     X = lil_matrix((lines, columns)).astype('float32')     Y = []     line=0     with open(filename,'r') as f:         samples=csv.reader(f,delimiter='\t')         for userId,movieId,rating,timestamp in samples:             X[line,int(userId)-1] = 1             X[line,int(num_users)+int(movieId)-1] = 1             Y.append(int(rating))             line=line+1            Y=np.array(Y).astype('float32')     return X,Y</pre></li>
				<li>然后我们处理<a id="_idIndexMarker350"/>训练和<a id="_idIndexMarker351"/>测试数据集:<pre>X_train, Y_train = loadDataset('ua.base.shuffled',                                 num_ratings_train,                                  num_features) X_test, Y_test = loadDataset('ua.test',                              num_ratings_test,                               num_features)</pre></li>
				<li>We check that the shapes are what we expect:<pre>print(X_train.shape)
print(Y_train.shape)
print(X_test.shape)
print(Y_test.shape)</pre><p>这将显示数据集形状:</p><pre><strong class="bold">(90570, 2625)</strong>
<strong class="bold">(90570,)</strong>
<strong class="bold">(9430, 2625)</strong>
<strong class="bold">(9430,)</strong></pre></li>
				<li>Now, let's <a id="_idIndexMarker352"/>write a function that converts a dataset to RecordIO-wrapped <code>protobuf</code>, and uploads it to an S3 bucket. We first create an in-memory binary <a id="_idIndexMarker353"/>stream with <code>io.BytesIO()</code>. Then, we use the lifesaving <code>write_spmatrix_to_sparse_tensor()</code> function to write the sample matrix and the label vector to that buffer in <code>protobuf</code> format. Finally, we use <code>boto3</code> to upload the buffer to S3:<pre>import io, boto3
import sagemaker.amazon.common as smac
def writeDatasetToProtobuf(X, Y, bucket, prefix, key):
    buf = io.BytesIO()
    smac.write_spmatrix_to_sparse_tensor(buf, X, Y)
    buf.seek(0)
    obj = '{}/{}'.format(prefix, key)  
    
    boto3.resource('s3').Bucket(bucket).Object(obj).
    upload_fileobj(buf)
    return 's3://{}/{}'.format(bucket,obj)</pre><p>如果我们的<a id="_idIndexMarker354"/>数据存储在<code>numpy</code>数组中的<a id="_idIndexMarker355"/>而不是<code>lilmatrix</code>，我们将会使用<code>write_numpy_to_dense_tensor()</code>函数。有异曲同工之妙。</p></li>
				<li>我们将这个函数应用于两个数据集，并存储它们的 S3 路径:<pre>import sagemaker sess   = sagemaker.Session() bucket = sess.default_bucket() prefix = 'fm-movielens' train_key      = 'train.protobuf' train_prefix   = '{}/{}'.format(prefix, 'train') test_key       = 'test.protobuf' test_prefix    = '{}/{}'.format(prefix, 'test') output_prefix  = 's3://{}/{}/output'.format(bucket,                                              prefix) train_data = writeDatasetToProtobuf(X_train, Y_train,               bucket, train_prefix, train_key)     test_data  = writeDatasetToProtobuf(X_test, Y_test,               bucket, test_prefix, test_key)    </pre></li>
				<li>看一看终端中的 S3 桶，我们看到训练数据集仅占用 5.5 MB。稀疏矩阵、protobuf 和 RecordIO 的组合已经得到了回报:<pre><strong class="bold">$ aws s3 ls s3://sagemaker-eu-west-1-123456789012/fm-movielens/train/train.protobuf</strong> <strong class="bold">5796480 train.protobuf</strong></pre></li>
				<li>What <a id="_idIndexMarker356"/>comes next is SageMaker <a id="_idIndexMarker357"/>business as usual. We find the name of the Factorization Machines container, configure the <code>Estimator</code> function, and set the hyperparameters:<pre>from sagemaker.image_uris import retrieve
region = sess.boto_session.region_name    
container=retrieve('factorization-machines', region)
fm=sagemaker.estimator.Estimator(
    container,
    role=sagemaker.get_execution_role(),
    instance_count=1,
    instance_type='ml.c5.xlarge',
    output_path=output_prefix)
fm.set_hyperparameters(
    feature_dim=num_features,
    predictor_type='regressor',
    num_factors=64,
    epochs=10)</pre><p>查看文档(<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/fact-machines-hyperparameters.html">https://docs . AWS . Amazon . com/sagemaker/latest/DG/fact-machines-hyperparameters . html</a>，我们看到所需的超参数是<code>feature_dim</code>、<code>predictor_type</code>和<code>num_factors</code>。<code>epochs</code>的默认设置是<code>1</code>，感觉有点低，我们用<code>10</code>代替。</p></li>
				<li>然后我们启动培训<a id="_idIndexMarker358"/>工作。你有没有注意到我们没有配置训练输入？我们只是传递两个<code>protobuf</code>文件的位置。由于<code>protobuf</code>是因式分解机器(以及其他内置算法)的默认格式，我们可以省去一个步骤:<pre>fm.fit({'train': train_data, 'test': test_data})</pre></li>
				<li>一旦工作结束，我们将模型部署到一个实时端点:<pre>endpoint_name = 'fm-movielens-100k' fm_predictor = fm.deploy(     endpoint_name=endpoint_name,     instance_type='ml.t2.medium',      initial_instance_count=1)</pre></li>
				<li>我们现在将以 JSON 格式(https://docs . AWS . Amazon . com/sage maker/latest/DG/fact-machines . html # FM-input output)向端点发送样本。为此，我们编写了一个定制的序列化程序来将输入数据转换成 JSON。因为我们将内容类型设置为<code>'application/json'</code> : <pre>import json from sagemaker.deserializers import JSONDeserializer from sagemaker.serializers import JSONSerializer class FMSerializer(JSONSerializer):     def serialize(self, data):         js = {'instances': []}         for row in data:             js['instances'].append({'features':                                row.tolist()})         return json.dumps(js) fm_predictor.serializer = FMSerializer() fm_predictor.deserializer = JSONDeserializer()</pre>，所以将自动使用默认的 JSON 反序列化器</li>
				<li>We send the first three samples of the test set for prediction:<pre>result = fm_predictor.predict(X_test[:3].toarray())
print(result)</pre><p>预测看起来是这样的:</p><pre><strong class="bold">{'predictions': [{'score': 3.3772034645080566}, {'score': 3.4299235343933105}, {'score': 3.6053106784820557}]}</strong></pre></li>
				<li>使用这个<a id="_idIndexMarker360"/>模型，我们可以填充推荐矩阵中所有的空单元格。对于每个用户，我们将简单地预测所有电影的分数，并存储前 50 部电影。该信息将存储在后端，相应的元数据(标题、流派等)将在前端应用程序中显示给用户。</li>
				<li>最后，我们删除端点:<pre>fm_predictor.delete_endpoint()</pre></li>
			</ol>
			<p>到目前为止，我们只使用了监督学习算法。在下一节中，我们将继续讨论主成分分析的无监督学习。</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor088"/>使用主成分分析</h2>
			<p><code>protobuf</code>因式分解机器示例中构建的数据集。它的 2625 列是一个很好的降维候选！我们将通过以下步骤使用 PCA:</p>
			<ol>
				<li value="1">从处理过的数据集开始，我们为 PCA 配置<code>Estimator</code>。现在，你应该(几乎)闭着眼睛就能做到:<pre>from sagemaker.image_uris import retrieve region = sess.boto_session.region_name    container = retrieve('pca', region)  pca = sagemaker.estimator.Estimator(     container=container,     role=sagemaker.get_execution_role(),     instance_count=1,                                    instance_type='ml.c5.xlarge',     output_path=output_prefix)</pre></li>
				<li>然后我们设置超参数。需要的是特征的初始数量、要计算的主成分的数量和批量:<pre>pca.set_hyperparameters(feature_dim=num_features,                         num_components=64,                         mini_batch_size=1024)</pre></li>
				<li>我们训练和部署模型:<pre>pca.fit({'train': train_data, 'test': test_data}) pca_predictor = pca.deploy(     endpoint_name='pca-movielens-100k',     instance_type='ml.t2.medium',     initial_instance_count=1)</pre></li>
				<li>Then, we predict the first test sample, using <a id="_idIndexMarker364"/>the same serialization code as in the previous example:<pre>import json
from sagemaker.deserializers import JSONDeserializer
from sagemaker.serializers import JSONSerializer
class PCASerializer(JSONSerializer):
    def serialize(self, data):
        js = {'instances': []}
        for row in data:
            js['instances'].append({'features': 
                            row.tolist()})
        return json.dumps(js)
pca_predictor.serializer = PCASerializer()
pca_predictor.deserializer = JSONDeserializer()
result = pca_predictor.predict(X_test[0].toarray())
print(result)</pre><p>这将打印出测试样本的 64 个主要成分。在现实生活中，我们通常会用这个模型处理数据集，保存结果，并用它们来训练回归模型:</p><pre><strong class="bold">{'projections': [{'projection': [-0.008711372502148151, 0.0019895541481673717, 0.002355781616643071, 0.012406938709318638, -0.0069608548656105995, -0.009556426666676998, &lt;output removed&gt;]}]} </strong></pre></li>
			</ol>
			<p>完成后，不要忘记<a id="_idIndexMarker366"/>删除端点。然后，让我们再运行一个无监督学习的例子来结束这一章！</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor089"/>用随机采伐森林检测异常</h2>
			<p><strong class="bold">随机砍伐森林</strong>(<strong class="bold">https://proceedings.mlr.press/v48/guha16.pdf</strong>)是一种用于异常检测的无监督<a id="_idIndexMarker367"/>学习算法(<a href="https://proceedings.mlr.press/v48/guha16.pdf">T16)。我们将把它应用于本书 GitHub 资源库中可用的</a><a id="_idIndexMarker368"/>家庭电力消耗<a id="_idIndexMarker369"/>数据集(<a href="https://archive.ics.uci.edu/ml/">https://archive.ics.uci.edu/ml/</a>)的子集。在不到一年的时间内，每小时汇总一次<a id="_idIndexMarker370"/>数据(不到 8000 个值):</p>
			<ol>
				<li value="1">In a Jupyter notebook, we load the dataset with <code>pandas</code>, and we display the first few lines:<pre>import pandas as pd
df = pd.read_csv('item-demand-time.csv', dtype = object, names=['timestamp','value','client'])
df.head(3)</pre><p>如以下屏幕截图所示，数据集有三列——每小时时间戳、功耗值(千瓦时)和客户端 ID:</p><div><img src="img/B17705_04_4.jpg" alt="Figure 4.4 – Viewing the columns&#13;&#10;" width="658" height="216"/></div><p class="figure-caption">图 4.4–查看列</p></li>
				<li>Using <code>matplotlib</code>, we plot the dataset to get a quick idea of what it looks like:<pre>import matplotlib
import matplotlib.pyplot as plt
df.value=pd.to_numeric(df.value)
df_plot=df.pivot(index='timestamp',columns='item',
                 values='value')
df_plot.plot(figsize=(40,10))</pre><p>图<a id="_idIndexMarker371"/>如下图<a id="_idIndexMarker372"/>所示。我们看到对应于三个不同客户的三个时间序列:</p><div><img src="img/B17705_04_5.jpg" alt="Figure 4.5 – Viewing the dataset&#13;&#10;" width="1272" height="327"/></div><p class="figure-caption">图 4.5–查看数据集</p></li>
				<li>There are two issues with this dataset. First, it contains several time series: RCF can only train a model on a single series. Second, RCF requires <code>pandas</code> – we only keep the <code>"client_12"</code> time series, we multiply its values by 100, and cast them to the integer type:<pre>df = df[df['item']=='client_12']
df = df.drop(['item', 'timestamp'], axis=1)
df.value *= 100
df.value = df.value.astype('int32')
df.head()</pre><p>下图显示了转换数据集的第一行:</p><div><img src="img/B17705_04_6.jpg" alt="Figure 4.6 – The values of the first lines&#13;&#10;" width="143" height="223"/></div><p class="figure-caption">图 4.6–第一行的值</p></li>
				<li>We plot it <a id="_idIndexMarker374"/>again to check that it looks as expected. Note the large drop right after step 2000, highlighted by a box in the following screenshot. This is clearly an anomaly, and hopefully, our model will catch it:<div><img src="img/B17705_04_7.jpg" alt="Figure 4.7 – Viewing a single time series&#13;&#10;" width="533" height="407"/></div><p class="figure-caption">图 4.7–查看单个时间序列</p></li>
				<li>和前面的例子一样，我们将数据集保存到一个 CSV 文件中，然后上传到 S3: <pre>import sagemaker sess = sagemaker.Session() bucket = sess.default_bucket() prefix = 'electricity' df.to_csv('electricity.csv', index=False,            header=False) training_data_path = sess.upload_data(                        path='electricity.csv',                         key_prefix=prefix +                                    '/input/training')</pre></li>
				<li>Then, we define the <code>label_size=1</code>). Even though the training channel never has labels, we still need to tell RCF.<p>二、唯一的<code>ShardedByS3Key</code>。该策略将数据集拆分到训练群集中的不同实例，而不是向它们发送完整的副本。我们不会在这里运行分布式培训，但是我们仍然需要设置该策略:</p><pre>training_data_channel = 
    sagemaker.TrainingInput(
        s3_data=training_data_path,                                                            
        content_type='text/csv;label_size=0',                                         
        distribution='ShardedByS3Key')
rcf_data = {'train': training_data_channel}</pre></li>
				<li>剩下的就是一切如常:训练和部署！再来一次<a id="_idIndexMarker377"/>，我们重用前面例子的<a id="_idIndexMarker378"/>代码，它几乎没有变化:<pre>from sagemaker.estimator import Estimator from sagemaker.image_uris import retrieve region = sess.boto_session.region_name container = retrieve('randomcutforest', region) rcf_estimator = Estimator(container,     role= sagemaker.get_execution_role(),     instance_count=1,     instance_type='ml.m5.large',     output_path='s3://{}/{}/output'.format(bucket,                                             prefix)) rcf_estimator.set_hyperparameters(feature_dim=1) rcf_estimator.fit(rcf_data) endpoint_name = 'rcf-demo' rcf_predictor = rcf_estimator.deploy(     endpoint_name=endpoint_name,     initial_instance_count=1,     instance_type='ml.t2.medium')</pre></li>
				<li>After a few <a id="_idIndexMarker379"/>minutes, the model is deployed. We convert the input time series to a Python list, and we send it to <a id="_idIndexMarker380"/>the endpoint for prediction. We use CSV and JSON, respectively, for serialization and deserialization:<pre>rcf_predictor.serializer =
    sagemaker.serializers.CSVSerializer()
rcf_predictor.deserializer =
    sagemaker.deserializers.JSONDeserializer()
values = df['value'].astype('str').tolist()
response = rcf_predictor.predict(values)
print(response)</pre><p>响应包含时间序列中每个值的异常值。看起来是这样的:</p><pre><strong class="bold">{'scores': [{'score': 1.0868037776}, {'score': 1.5307718138}, {'score': 1.4208102841} …</strong></pre></li>
				<li>然后，我们将这个响应转换成一个 Python 列表，然后计算它的平均值和标准差:<pre>from statistics import mean,stdev scores = [] for s in response['scores']:     scores.append(s['score']) score_mean = mean(scores) score_std = stdev(scores)</pre></li>
				<li>We plot a subset of the time series and the corresponding scores. Let's focus on the "[2000:2500]" interval, as this is where we saw a large drop. We also plot a line <a id="_idIndexMarker381"/>representing the mean plus <a id="_idIndexMarker382"/>three standard deviations (99.7% of the score distribution) – any score largely exceeding the line is likely to be an anomaly:<pre>df[2000:2500].plot(figsize=(40,10))
plt.figure(figsize=(40,10))
plt.plot(scores[2000:2500])
plt.autoscale(tight=True)
plt.axhline(y=score_mean+3*score_std, color='red')
plt.show()</pre><p>该落差在下图中清晰可见:</p><div><img src="img/B17705_04_8.jpg" alt="Figure 4.8 – Zooming in on an anomaly&#13;&#10;" width="1265" height="319"/></div><p class="figure-caption">图 4.8-放大异常</p><p>在下面的评分图上可以看到，它的评分是天价！毫无疑问，这个值是一个异常值:</p><div><img src="img/B17705_04_9.jpg" alt="Figure 4.9 – Viewing anomaly scores&#13;&#10;" width="1263" height="320"/></div><p class="figure-caption">图 4.9–查看异常分数</p><p>探索<a id="_idIndexMarker384"/>时间序列的其他区间，我们当然可以找到更多。谁说机器学习不好玩？</p></li>
				<li>最后，我们删除端点:<pre>rcf_predictor.delete_endpoint()</pre></li>
			</ol>
			<p>看完了五个完整的例子，您现在应该熟悉内置算法、SageMaker 工作流和 SDK。为了完全掌握这些主题，我建议使用您的数据集进行实验，并运行其他示例，这些示例可从<a href="https://github.com/awslabs/amazon-sagemaker-examples/tree/master/introduction_to_amazon_algorithms">https://github . com/aw slabs/Amazon-sage maker-examples/tree/master/introduction _ to _ Amazon _ algorithms</a>获得。</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor090"/>总结</h1>
			<p>正如你所看到的，内置算法是一种快速训练和部署模型的好方法，而无需编写任何机器学习代码。</p>
			<p>在本章中，您了解了 SageMaker 工作流，以及如何使用 SageMaker SDK 中的一些 API 来实现它，而无需担心基础设施。</p>
			<p>您了解了如何处理 CSV 和 RecordIO 包装的 protobuf 格式的数据，后者是在大规模数据集上进行大规模训练的首选格式。您还学习了如何使用监督和非监督学习的重要算法构建模型:线性学习器、XGBoost、因式分解机器、PCA 和随机切割森林。</p>
			<p>在下一章，你将学习如何使用额外的内置算法来构建计算机视觉模型。</p>
		</div>
	</div>
</body></html>