

# 五、理解机器学习

在过去的几年里，你可能已经听说过一些流行词汇，如**人工智能** ( **AI** )、**机器学习** ( **ML** )和**深度学习** ( **DL** )，这些词汇已经席卷了大多数主要行业。尽管这些短语中有许多在全公司的全体员工和领导会议上可以互换使用，但每个短语实际上都指一个不同的概念。所以，让我们仔细看看这些短语实际上指的是什么。

人工智能通常是指由软件和机器展示的类人智能的总体领域。我们可以把人工智能看作是包含我们将在本书范围内讨论的许多主题的空间。

在人工智能领域中，存在一个子域，我们称之为**机器学习**。ML 可以定义为*结合数据研究算法以开发预测模型*。

在 ML 领域中，还存在另一个子域，我们称之为**深度学习**。我们将 **DL** 定义为*通过使用人工神经网络*来具体应用 ML。

现在我们已经对这些术语之间的区别有了更好的理解，让我们更详细地定义 ML 的概念。根据你询问的对象，你会遇到几种不同的 ML 定义。物理学家倾向于将定义与*性能优化*中的应用联系起来，而数学家倾向于将定义与*统计概率*联系起来，最后，计算机科学家倾向于将定义与*算法*和*代码*联系起来。在一定程度上，这三者在技术上都是正确的。出于本书的目的，我们将把 ML 定义为一个研究领域，涉及使用计算机代码开发数学优化模型，这些模型从历史数据中*学习*或*概括*以获得有用的见解并做出预测。

虽然这个定义可能看起来很简单，但大多数有经验的面试候选人在定义这个概念时仍然倾向于挣扎。记下我们在这里使用的确切措辞，因为它可能会在未来的设置中有用。

在这一章的过程中，我们将访问 ML 的各个方面，我们将回顾开发人员在开发**预测模型**时必须采取的一些最常见的步骤。

在本章中，我们将回顾以下主要主题:

*   理解 ML
*   过度拟合和欠拟合
*   开发一个 ML 模型

考虑到这些，让我们开始吧！

# 技术要求

在本章中，我们将应用我们对`pandas`和`numpy`的理解。此外，我们还会用到一些 ML 库，比如`sklearn`、`tensorflow`。回想一下，安装新库的过程可以通过命令行完成:

```py
$ pip install library-name
```

我们开始吧！

# 了解 ML

在介绍中，我们广义地定义了与本书相关的 ML 概念。记住这个定义，现在让我们看一些例子来详细说明我们的定义。最广义的 ML 可以分为四个区域:**分类**、**回归**、**聚类**、**降维**。这四个类别通常被称为**数据科学**的领域。数据科学是一个非常宽泛的术语，用于指与数据相关的各种应用，以及人工智能领域及其子集。我们可以在*图 5.1* 中看到这些字段之间的关系:

![Figure 5.1 – The domain of AI as it relates to other fields

](img/B17761_05_001.jpg)

图 5.1–人工智能领域与其他领域的关系

记住这些概念，让我们更详细地讨论这四种 ML 方法。

`X`)及其后续输出值(统称为`ŷ`)用于训练一个分类器。这个分类器可以用来对新的和未知的数据进行预测。我们可以在*图 5.2* 中直观地表示出来:

![Figure 5.2 – An example of a classification model

](img/B17761_05_002.jpg)

图 5.2–分类模型示例

**聚类**在某种意义上类似于分类，即模型的结果是一个标签(或类别)，但这里的区别在于，聚类模型不是在预定义类别的列表上训练的，而是基于对象之间的相似性。然后，聚类模型将数据点分组到*聚类*中。形成的集群的总数并不总是提前知道的，这在很大程度上取决于模型被训练的参数。在以下示例中，使用原始数据集形成了三个分类:

![Figure 5.3 – An example of a clustering model

](img/B17761_05_003.jpg)

图 5.3–聚类模型示例

另一方面，当到达`X`时，它们随后的输出值(`ŷ`)用于训练一个*回归变量*。然后，该回归变量可用于对新的和未知的数据进行预测:

![Figure 5.4 – An example of a regression model

](img/B17761_05_004.jpg)

图 5.4-回归模型的一个例子

最后，当涉及到到**维度缩减**时，ML 可以不用于预测值的目的，而是用于将数据从*高维*表示转换为*低维*表示。举个例子，我们在前面的章节中使用了大量的毒性数据集。我们可以应用诸如**主成分分析** ( **PCA** )到的方法，通过*将这些特征的重要性*结合在一起，将 10+列特征减少到只有两三列。我们将在 [*第 7 章*](B17761_07_Final_JM_ePub.xhtml#_idTextAnchor101) 、*了解监督机器学习*中更详细地检验这一点。我们可以在*图 5.5* 中看到它的直观表示:

![Figure 5.5 – An example of a dimensionality reduction model

](img/B17761_05_005.jpg)

图 5.5–降维模型示例

ML 领域庞大而复杂，远远超出了我们刚刚提到的四个基本例子。然而，ML 模型最常见的应用往往集中在*预测类别*、*预测值*，或者*揭示数据中隐藏的洞察力*。

作为科学家，我们总是希望尽可能地组织我们的思想，而碰巧的是，我们刚刚讨论的概念可以分为两大类:`X`和输出(`ŷ`)。我们称之为*监督*方法，因为模型被教导(*监督*)哪个输出标签对应哪个输入值。另一方面，UML 包含 ML 模型，其中只有输入(`X`)是已知的。回顾我们讨论的四种方法，我们可以将它们分为两种学习方法，即**分类**和**回归**属于 SML，而**聚类**和**维度缩减**属于 UML:

![Figure 5.6 – A representation of supervised and unsupervised machine learning

](img/B17761_05_006.jpg)

图 5.6–监督和非监督机器学习的表示

在接下来章节的课程中，我们将探索属于这四大类的许多流行的 ML 模型和算法。在你继续学习的过程中，我鼓励你开发自己的思维导图，并进一步将四个类别中的每一个扩展到你将要学习的所有不同的模型。例如，我们将在本章的*保存用于部署的模型*一节中探索一个*朴素贝叶斯*模型，它可以被添加到*图 5.6* 的**分类**分支中。也许你可以用一些关于模型本身的注释来扩展每个模型。在准备技术面试时，地图或视觉辅助工具可能会很有用。

在我们开发的每个模型中，我们将遵循一组特定的步骤来获取数据，对数据进行预处理，构建模型，评估其性能，最后，如果模型足够，将其部署到我们的最终用户或数据工程师。在我们开始开发我们的模型之前，让我们讨论一下被称为*过拟合*和*欠拟合*的常见危险。

# 过拟合和欠拟合

在 SML 的背景下，我们将通过*用历史数据拟合*来准备我们的模型。拟合模型的过程通常会输出一个度量值，该度量值表示该模型对与训练该模型所依据的数据相似的数据的概括程度。使用这个输出，通常以**精度**、**精度**和**召回**的形式，我们可以确定我们实现的方法或我们改变的参数是否对我们的模型有积极的影响。如果我们重温一下本章前面的 ML 模型的定义，我们会特别提到它们是*从历史数据中学习*或*概括*的模型。能够从历史数据中学习的模型被称为*合适的*模型，在某种意义上，它们能够对新的和看不见的数据进行准确的处理。

存在模型不足的实例。不足的模型通常在数据集上表现不佳，这意味着它们没有学会很好地概括。这些情况通常是由于给定数据集选择了不合适的模型，或者该模型的参数/超参数设置不当。

重要说明

**参数和超参数**:注意虽然参数和超参数是经常互换使用的术语，但两者是有区别的。*超参数*是模型估计器不学习的参数，必须手动调整。

也有模型过度拟合的例子。*过拟合*模型是*对*数据集了解得有点过的模型，这意味着它们不再是*在学习*而是*在记忆*。过度拟合通常发生在模型开始从数据集中的噪声中学习，并且不再能够对新数据进行很好的概括时。在*图 5.7* 中可以看到拟合良好、过度拟合和欠拟合模型之间的差异:

![Figure 5.7 – A representation of overfitting and underfitting data

](img/B17761_05_007.jpg)

图 5.7-过度拟合和欠拟合数据的表示

每个数据科学家的目标是开发一个平衡的模型，当涉及到您感兴趣的指标时，该模型具有最佳性能。确保您正在开发一个不会欠拟合或过拟合的平衡模型的最佳方法之一是提前拆分数据集，并确保模型仅针对数据的子集进行定型。我们可以把数据集分成两类:*训练数据*和*测试数据*(也常被称为*验证数据*)。我们可以使用训练数据集来训练模型，并且可以使用测试数据集来测试(或验证)模型。用于此目的的最常见的类之一是来自`sklearn`的`train_test_split()`类。如果您认为数据集的输入变量是`X`，输出变量是`ŷ`，那么您可以使用下面的代码片段分割数据集。首先，我们导入数据。然后，我们分离出我们感兴趣的特征，输出它们各自的变量。然后，我们实现`train_test_split()`函数来相应地分割数据:

```py
import pandas as pd
from sklearn.model_selection import train_test_split
df = pd.read_csv("../../datasets/dataset_wisc_sd.csv")
X = df.drop(columns = ["id", "diagnosis"])
y = df.diagnosis.values
X_train, X_test, y_train, y_test = train_test_split(X, y)
```

我们可以在*图 5.8* 中看到分割的数据集:

![Figure 5.8 – A visual representation of data that has been split for training and testing

](img/B17761_05_008.jpg)

图 5.8–为训练和测试而拆分的数据的可视化表示

以这种方式分割数据后，我们现在可以使用`X_train`和`y_train`来训练我们的模型，使用`X_test`和`y_test`来测试(或验证)我们的模型。默认的拆分比例是 75%的训练数据对 25%的测试数据；但是，我们可以通过`test_size`参数将其更改为任何其他比率。我们通常希望根据尽可能多的数据进行训练，但仍然保留大量有意义的未知数据，因此 *75/25* 是业内普遍接受的比率。记住这个概念，让我们继续开发一个完整的 ML 模型。

# 开发一个 ML 模型

作为最终用户，我们每天都要与无数的 ML 模型打交道，而我们甚至可能没有意识到这一点。回想一下你今天做的所有活动:浏览社交媒体、查看电子邮件，或者你去了商店或超市。在这些设置中，您很可能与已经部署的 ML 模型进行了交互。在社交媒体上，出现在你的 feed 上的帖子很可能是一个监督的**推荐**模型的输出。您打开的电子邮件可能是使用**分类**模型过滤的垃圾邮件。最后，杂货店中可用的商品数量可能是一个**回归**模型的输出，允许他们预测今天的需求。在每个模型中，都投入了大量的时间和精力来确保它们正常运行。在这些情况下，虽然模型的开发很重要，但最重要的是如何提前准备数据。作为科学家，我们总是倾向于尽可能组织我们的思想和过程，所以让我们为开发 ML 模型的过程组织一个工作流程:

1.  **数据采集**:通过 SQL 查询、本地导入或 API 请求收集数据
2.  **EDA 和预处理**:理解和清理数据集
3.  **模型开发和验证**:训练模型并验证结果
4.  部署:将你的模型提供给最终用户

记住这些步骤，让我们继续开发我们的第一个模型。

我们从导入数据开始。我们将使用一个我们尚未使用过的新数据集，称为`Breast Cancer Wisconsin`数据集。这是一个多变量数据集，发表于 1995 年，包含了数百例乳腺癌肿块。这些质量以我们将用作*特征* ( `X`)的测量形式描述。数据集还包括关于每个实例的恶性程度的信息，我们将把这些信息用于我们的输出*标签* ( `ŷ`)。假设我们既有输入数据又有输出数据，这就需要使用一个*分类*模型。

## 数据采集

让我们导入我们的数据并检查它的整体形状:

```py
import pandas as pd
import numpy as np
df = pd.read_csv("../../datasets/dataset_wisc_sd.csv")
df.shape
```

我们注意到有 569 行(我们通常称之为*观察值*)和 32 列(我们通常称之为*特性*)的数据。我们通常希望我们的数据集有更多的*观察值*而不是*特征*。这两者之间的理想比例并没有黄金法则，但是您通常希望观察值比特性值至少多 10 倍。因此，对于 32 列，您将希望至少有 320 个观察值——我们在本例中就是这样做的！

## 探索性数据分析和预处理:

**探索性数据分析** ( **EDA** )可以说是任何给定的 ML 项目中最重要和最耗时的步骤之一。该步骤通常由许多较小的步骤组成，其目标如下:

*   理解数据及其特征。
*   解决任何不一致或缺少的值。
*   检查特征之间的相关性。

请注意，根据您的数据集，我们执行这些步骤的顺序可能会有所不同。考虑到这些，让我们开始吧！

### 检查数据集

导入数据集后的第一步是快速检查数据的质量。回想一下，我们可以使用方括号(`[]`)来指定感兴趣的列，并且我们可以使用`head()`或`tail()`函数来查看前五行或后五行数据:

```py
df[["id", "diagnosis", "radius_mean", "texture_mean", "concave points_worst"]].head()
```

我们可以在*图 5.9* 中看到这段代码的结果:

![Figure 5.9 – A sample of the Breast Cancer Wisconsin dataset

](img/B17761_05_09.jpg)

图 5.9-乳腺癌威斯康星州数据集的样本

我们可以很快感觉到数据组织得非常好，并且乍一看，它似乎没有任何有问题的值，例如不寻常的字符或缺少的值。查看这些选择列，我们注意到在开头有一个由整数*组成的唯一标识符*，后面是由字符串组成的诊断( **M** = **恶性**和 **B** = **良性**)。其余的列都是特征，它们看起来都是 *float* (decimals)数据类型。我建议您扩展上表的范围，探索该数据集中的所有其他要素。

除了研究这些值，我们还可以研究由`pandas`库中的`describe()`函数提供的一些汇总统计数据。使用此函数，我们可以了解总计数，以及一些描述性统计数据，如平均值、最大值和最小值:

```py
df[["id", "diagnosis", "radius_mean", "texture_mean", "perimeter_mean", "area_mean", "concave points_worst"]].describe()
```

这个函数的输出可以在下面的截图中看到:

![Figure 5.10 – A table of some summary statistics for a DataFrame

](img/B17761_05_10.jpg)

图 5.10–数据帧的一些汇总统计表

仔细查看代码，我们注意到我们请求了七列的统计数据，但是只有五列出现在表中。我们可以看到这里汇总了`id`值(即*主键*或*唯一标识符*)。这些值没有意义，因为一组主键的平均值、最大值和最小值告诉我们什么。我们可以暂时忽略这个专栏。我们还要求提供`diagnosis`栏；然而，`diagnosis`列不使用数值。而是包含*字符串*。最后，我们看到`concave points_worst`特性也没有包含在这个表中，这表明数据类型由于某种原因而不是数字。当我们清理数据时，我们将在下一节中更详细地了解这一点。

### 清除值

清理数据集中的值是处理 ML 项目时最重要的步骤之一。数据科学家在描述模型时有一句名言是*垃圾进，垃圾出*。如果您想要一个强大的预测模型，那么确保支持它的数据质量良好是重要的第一步。

首先，让我们仔细看看数据类型，这里可能有一些不一致的地方。使用下面的代码，我们可以了解 32 列中每一列的数据类型:

```py
df.dtypes
```

我们可以在*图 5.11* 中看到这段代码的输出，其中显示了列名及其各自的数据类型:

![Figure 5.11 – A list of all of the columns in a dataset with their respective data types

](img/B17761_05_011.jpg)

图 5.11–数据集中所有列及其各自数据类型的列表

查看列出的数据类型，我们看到`id`列被列为一个整数而`diagnosis`列被列为一个对象，这似乎与*图 5.9* 中它似乎是一个单字母字符串的事实相一致。看了一下特性，它们都被列为浮动，与我们之前看到的完全一致，除了一个特性:`concave points_worst`。此特征被列为对象，表明它可能是字符串。我们前面提到过，该列由浮点值组成，因此该列本身应该是浮点类型。让我们来看看这种不一致宜早不宜迟。我们可以尝试*将*列转换为浮动类型，而不是使用`astype()`函数:

```py
df['concave points_worst'] = df['concave points_worst'].astype(float)
```

但是，您会发现这段代码会出错，表明有一行中存在`\\n`字符，它无法将字符串转换为浮点数。这就是众所周知的换行符，这是你在处理数据集时要处理的最常见的项目或杂质*之一。让我们继续前进，找出这个角色出现的台词，然后决定如何处理。我们可以使用`contains()`函数来查找特定字符串的所有实例:*

```py
df[df['concave points_worst'].str.contains(r"\\n")]
```

该函数的输出显示只有索引为`146`的行包含该字符。让我们仔细看看`146`行中的特定单元格:

```py
df["concave points_worst"].iloc[146]
```

我们看到单元格包含了`0.1865\\n\\n`字符串。看起来好像字符只在这一行打印了两次。我们可以很容易地打开 CSV 文件，并手动更正这个值，因为它只发生了一次。但是，如果这个字符串出现了 10 次，或者 100 次呢？幸运的是，我们可以用一个`replace()`函数来用*替换*它们。我们可以在`df`上专门链接这个函数，而不是单个列，以确保该函数解析完整的数据帧:

```py
df = df.replace(r'\\n','', regex=True)
```

正则表达式是一个强大的工具，您经常会依赖它来完成各种文本匹配和清理任务。您可以使用 regex 函数删除空格、数字、字符或不常见的字符组合。我们可以通过再次检查特定单元格的值来仔细检查 regex 函数是否成功:

```py
df["concave points_worst"].iloc[146]
```

该值现在只有`0.1865`，表明该功能实际上是成功的。我们现在可以使用`astype()`函数将列的类型转换为浮点型，然后使用`df.dtypes`确认列出了正确的数据类型。

到目前为止，我们能够解决无效字符进入数据集的问题。但是，丢失的项目怎么办？我们可以使用`isna()`函数对数据集进行快速检查，以确定是否有任何值丢失:

```py
df.isna().values.sum()
```

返回的值显示有 7 行数据缺少一个值。回想一下，在第 4 章 、*用 Python 可视化数据*中，我们查看了几种处理缺失值的方法。假设我们有一个足够大的数据集，使用`dropna()`函数简单地删除这几行是合适的:

```py
df = df.dropna()
```

我们可以在实现函数之前和之后检查数据集的形状，以确保确实删除了适当数量的行。

总是建议花些时间提前清理你的数据集，因为这将有助于防止问题和不寻常的错误。检查*数据类型*和*缺失值*总是很重要的。

### 理解数据的含义

现在让我们从第二列中的输出值开始，仔细看看这个数据集中的一些数据。我们知道这些值对应的标签是:恶性的*M*和良性的 B*B*。我们可以使用`value_counts()`函数来确定每个类别的总和:

```py
df['diagnosis'].value_counts()
```

结果显示良性肿块 354 例，恶性肿块 208 例。我们可以使用`seaborn`库来可视化这个比率:

```py
sns.countplot(df['diagnosis'])
```

这段代码的输出如下所示:

![Figure 5.12 – A bar plot showing the number of instances for each class

](img/B17761_05_012.png.jpg)

图 5.12-显示每个类的实例数量的条形图

在大多数 ML 模型中，我们试图确保输出列是*平衡的*，在某种意义上，类别是*大致等于*。在具有例如 95 行恶性观察值和 5 行良性观察值的不平衡数据集上训练模型将导致具有较差性能的不平衡模型。在中，除了可视化诊断或输出列，我们还可以使用我们在 [*第 4 章*](B17761_04_Final_JM_ePub.xhtml#_idTextAnchor066) 、*使用 Python 可视化数据*中查看的`pairplot()`函数可视化特征，以获得任何趋势或相关性的感觉。我们可以通过一些功能来实现这一点:

```py
sns.pairplot(df[["diagnosis", "radius_mean", "concave points_mean", "texture_mean"]], hue = 'diagnosis')
```

下图显示了此的输出:

![Figure 5.13 – A pair plot of selected features

](img/B17761_05_013.png.jpg)

图 5.13–选定特征的配对图

查看最后几张图，我们注意到两组数据之间有明显的区别。从大多数点位于靠近中心的位置，而远离中心的点较少的意义上来说，这些集群似乎呈现出**正态分布**的一些特征。鉴于这种性质，我们可以在该数据集中尝试的第一个模型是**朴素贝叶斯分类器**，它往往适用于这种类型的数据。然而，我们将在本章后面更详细地讨论这个模型。

在每个图中，我们都可以看到这两个类别之间存在一定程度的重叠，这表明仅使用两个色谱柱不足以保持良好的分离度。因此，我们可以确保我们的 ML 模型利用更多的列，或者我们可以尝试消除任何可能导致这种重叠的潜在异常值——或者我们可以双管齐下！

首先，我们可以利用一些描述性的*统计数据。具体来说，我们可以使用`dfm`。然后，我们可以使用`radius_mean`特性定义第一个四分位数(`Q1`)和第三个四分位数(`Q3`):*

```py
dfm = df[df["diagnosis"] == "M"]
Q1 = dfm['radius_mean'].quantile(0.25)
Q3 = dfm['radius_mean'].quantile(0.75)
IQR = Q3 - Q1
```

然后，我们可以打印这些变量的输出，结合`mean()`和`median()`函数来确定 IQR，从而了解数据的分布。我们可以使用`seaborn`中提供的`boxplot()`函数将这些指标与上限和下限一起可视化:

```py
sns.boxplot(x='diagnosis', y='radius_mean', data=df)
```

这给了我们*图 5.14* :

![Figure 5.14 – A box-whisker plot of the radius_mean feature

](img/B17761_05_014.png.jpg)

图 5.14-半径平均值特征的盒须图

使用上限和下限范围，我们可以使用`pandas`库中的`query()`类过滤数据帧，以排除任何超出此范围的数据:

```py
df = df.query('(@Q1 - 1.5 * @IQR) <= radius_mean <= (@Q3 + 1.5 * @IQR)')
```

随着代码的执行，我们已经成功地从数据集中移除了几个异常值。如果我们继续使用前面的散点图之一重新绘制数据，我们将会看到，虽然一些重叠确实减少了，但两个类别之间仍然有相当大的重叠，这表明我们开发的任何未来模型都需要利用多个列来确保在我们开始开发稳健的分类器时有足够的分离。在我们开始训练任何分类器之前，我们首先需要解决特征中任何潜在的相关性。

### 寻找相关性

过滤掉离群值后，我们现在可以开始仔细观察数据集中的特征之间的相关性。假设这个数据集由 30 个要素组成，我们可以利用我们在第 4 章*中实现的`corr()`类，用 Python* 可视化数据。我们可以从`seaborn`中创建一个`corr()`函数和`heatmap()`函数:

```py
f, ax=plt.subplots( figsize = (20,15))
sns.heatmap(df.corr(), annot= True, fmt = ".1f", ax=ax)
plt.xticks(fontsize=18)
plt.yticks(fontsize=18)
plt.title('Breast Cancer Correlation Map', fontsize=18)
plt.show()
```

此代码的输出可以在*图 5.15* 中看到，显示了各种特征的热图，其中最相关的特征以较浅的颜色显示，最不相关的特征以较深的颜色显示:

![Figure 5.15 – A heat map showing the correlation of features

](img/B17761_05_015.png.jpg)

图 5.15–显示特征相关性的热图

当我们查看这张热图时，我们看到该数据集中的多个特征之间存在大量的相关性。例如，`radius_worst`特征与`perimeter_mean`和`area_mean`特征之间非常强的相关性。当数据集中的独立变量或特征之间存在强相关性时，这就是被称为`corr()`函数的，并创建这些值的矩阵。然后我们可以选择上面的三角形(热图的一半)，然后识别相关性大于`0.90:`的特征

```py
corr_matrix = df.corr().abs()
upper = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(np.bool))
to_drop = [column for column in upper.columns if any(upper[column] > 0.90)]
```

`to_drop`变量现在表示应该被删除的列的列表，以确保任何高于我们设置的阈值的相关性都被有效地删除。注意，我们使用了**列表理解**(我们在 [*第 2 章*](B17761_02_Final_JM_ePub.xhtml#_idTextAnchor023) 、*介绍 Python 和命令行*中谈到的概念)来快速有效地迭代这些值。然后，我们可以从数据集中删除这些列:

```py
df.drop(to_drop, axis=1, inplace=True)
```

我们可以再次绘制热图，以确保解决任何潜在的共线性:

![Figure 5.16 – A heat map showing the correlation of features without multicollinearity

](img/B17761_05_016.png.jpg)

图 5.16-显示无多重共线性的要素相关性的热点图

注意高度相关的特征组不再存在。现在解决了相关性问题，我们不仅确保了我们创建的任何潜在模型都不会遇到与*多重共线性*相关的任何性能问题，而且我们还无意中将数据集的大小从 30 列要素减少到只有 19 列，使其更易于处理和可视化！随着数据集现在完全预处理，我们现在准备开始训练和准备一些 ML 模型。

## 开发和验证模型

现在数据准备就绪，我们可以探索几个模型。回想一下，我们在这里的目标是开发一个*分类*模型。因此，我们的第一步将是分离我们的`X`和 *ŷ* 值。

1.  We will create a variable, `X`, representing all of the features within the dataset (excluding the `id` and `diagnosis` columns, as these are not features). We will then create a variable, `y`, representing the output column:

    ```py
    X = df.drop(columns = ["id", "diagnosis"])
    y = df.diagnosis.values
    ```

    在我们将使用的大多数数据集内，我们通常会看到值的*量级*有很大差异，也就是说，一列可能是 1000 左右，而另一列可能是 0.1 左右。这意味着模型会认为值大得多的要素对预测的贡献大得多，但这是不正确的。例如，考虑一个项目，在该项目中，我们试图使用 30 种不同的特征来预测分子的亲脂性，其中一种特征是分子量——这是一种具有非常大的值但贡献不是那么大的特征。

2.  为了应对这一挑战，数据集中的值必须是来自`sklearn`库的`StandardScaler()`函数:

    ```py
    from sklearn.preprocessing import StandardScaler scaler = StandardScaler() X_scaled = pd.DataFrame(scaler.fit_transform(X), columns = X.columns)
    ```

3.  With the features now normalized, our next step is to split the data up into our *training* and *testing* sets. Recall that the purpose of the training set is to train the model, and the testing set is to test the model. This is done to avoid any *overfitting* in the development process:

    ```py
    from sklearn.model_selection import train_test_split
    X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, random_state=40)
    ```

    随着数据现在被分成四个变量，我们现在准备好训练几个模型，从**高斯朴素贝叶斯分类器**开始。该模型是基于贝叶斯定理应用的监督算法。该模型被称为*天真*是因为它假设每个*观测值*的*特征*是相互独立的，而这很少是真实的。不过这款无论如何都倾向于表现强劲。高斯朴素贝叶斯分类器背后的主要思想可以从*概率*的角度来考察。为了解释我们的意思，考虑下面的等式:

    ![](img/Formula_B17761_05_001.jpg)

    这表示标签的概率(给定一些数据)等于数据的概率(给定一个标签-高斯，给定正态分布)乘以标签的概率(先验概率)，再除以数据的概率(预测值先验概率)。鉴于这种模型的简单性，相对于更复杂的模型，朴素贝叶斯分类器可以非常快速地使用。

4.  我们来看看它的实现。我们将从导入我们感兴趣的库开始:

    ```py
       from sklearn.naive_bayes import GaussianNB    from sklearn.metrics import accuracy_score
    ```

5.  接下来，我们可以以变量的形式创建一个实际模型的实例，我们称之为`gnb_clf` :

    ```py
       gnb_clf = GaussianNB()
    ```

6.  然后，我们可以使用之前分离的训练数据集来拟合或训练模型:

    ```py
       gnb_clf.fit(X_train, y_train)
    ```

7.  Finally, we can use the trained model to make predictions on the testing data and compare the results with the known values. We can use a simple accuracy score to test the model:

    ```py
    gnb_pred = gnb_clf.predict(X_test)
       print(accuracy_score(gnb_pred, y_test))
      0.95035
    ```

    这样，我们已经成功地开发了一个准确率大约为 95%的模型——对于我们的第一个模型来说，这是一个不错的开始！

8.  While accuracy is always a fantastic metric, it is not the only metric we can use to assess the performance of a model. We can also use `classification_report()` function provided by `sklearn`:

    ```py
    from sklearn.metrics import classification_report
    print(classification_report(gnb_pred, y_test))
    ```

    查看下面的输出，我们可以看到我们感兴趣的两个类(B 和 M)列出了它们各自的度量:`precision`、`recall`和`f1-score`:

![Figure 5.17 – The classification report of the Naïve Bayes classifier

](img/B17761_05_017.jpg)

图 5.17–朴素贝叶斯分类器的分类报告

我们将在第 7 章 、*了解监督机器学习*中更加详细地讨论这些指标。目前，我们可以看到所有这些指标都很高，表明该模型表现得相当好。

## 保存用于部署的模型

当一个 ML 模型已经被训练并且在一个合理的精确度水平上运行时，我们可能希望将这个模型提供给其他人使用。然而，我们不会直接将数据或代码交付给数据工程师来将模型部署到生产中。相反，我们希望提供一个单一的训练有素的模型，他们可以采取和部署，而不必担心任何移动的部分。对我们来说幸运的是，有一个名为`pickle`的伟大库可以帮助我们*将*模型聚集成一个单一的实体，允许我们*保存*模型。回想一下我们在 [*第二章*](B17761_02_Final_JM_ePub.xhtml#_idTextAnchor023) 、*Python 入门和命令行*中探索过`pickle`库。我们*通过使用`dump()`函数来处理*一个模型，比如我们命名为`gnb_clf`的模型:

```py
import pickle
pickle.dump(gnb_clf, open("../../models/gnb_clf.pickle", 'wb'))
```

为了证明模型确实正确保存，我们可以使用`load()`函数加载它，并且我们可以再次计算准确性分数:

```py
loaded_gnb_clf = pickle.load(open("../../models/gnb_clf.pickle", 'rb'))
loaded_gnb_clf.score(X_test, y_test)
```

请注意，该评分计算的输出结果与我们之前看到的中的值相同(95%)，这表明该模型确实正确保存了数据！

# 总结

在这一章中，我们朝着理解 ML 中一些最重要和最有用的概念迈出了一大步。我们查看了用于描述该领域的各种术语，因为它与人工智能的领域相关，检查了 ML 的主要领域以及管理类别*监督*和*非监督*学习，然后继续探索为给定数据集开发 ML 模型的完整过程。

在开发我们的模型时，我们探索了许多有用的步骤。我们对数据进行了探索和预处理，以消除不一致和缺失值。我们还非常详细地检查了数据，随后我们解决了与*多重共线性*相关的问题。接下来，我们开发了一个*高斯朴素贝叶斯*分类模型，在我们的第一次尝试中，它的准确率高达 95%!最后，我们看了数据科学家将他们完全训练好的模型交给数据工程师以将 ML 模型投入生产的一种最常见的方式。

尽管我们在本章中花了时间在监督分类器的范围内理解 ML，但在下一章中，当我们训练几个非监督模型时，我们将获得对细微差别和差异的更好理解。