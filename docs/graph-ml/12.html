<html><head/><body>


	
		<title>B16069_09_Final_JM_ePub</title>
		
	
	
		<div><h1 id="_idParaDest-131"><a id="_idTextAnchor141"/>第 9 章:构建数据驱动的图形驱动应用程序</h1>
			<p>到目前为止，我们已经为您提供了理论和实践的想法，使您能够设计和实现利用图结构的机器学习模型。除了设计算法之外，将建模/分析管道嵌入到健壮可靠的端到端应用程序中通常也是非常重要的。在工业应用中尤其如此，最终目标通常是设计和实现支持数据驱动决策和/或为用户提供及时信息的生产系统。然而，创建一个依靠图形表示/建模的数据驱动的应用程序确实是一项具有挑战性的任务，它需要一个比简单地导入<code>networkx</code>复杂得多的适当设计。本章旨在为您提供构建基于图形的、可伸缩的、数据驱动的应用程序时使用的关键概念和框架的概述。</p>
			<p>我们将从概述所谓的<strong class="bold">λ架构</strong>开始，它提供了一个框架来构建需要大规模处理和实时更新的可扩展应用。然后，我们将继续在<em class="italic">图驱动的应用</em>的环境中应用这个框架，也就是说，使用本书中描述的技术来利用图结构的应用。我们将描述它们的两个主要分析组件:<strong class="bold">图形处理引擎</strong>和<strong class="bold">图形查询引擎</strong>。我们将介绍在共享内存机器和分布式内存机器中使用的一些技术，概述相似之处和不同之处。本章将涵盖以下主题:</p>
			<ul>
				<li>Lambda 架构概述</li>
				<li>面向图形驱动应用的 Lambda 架构</li>
				<li>图形处理引擎的技术和实例</li>
				<li>图形查询引擎和图形数据库</li>
			</ul>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor142"/>技术要求</h1>
			<p>我们将在所有练习中使用 Python 3.8。在下面的代码块中，您可以使用<code>pip</code>找到本章需要安装的 Python 库的列表。例如，在命令行上运行<code>pip install networkx==2.5</code>，等等:</p>
			<pre>networkx==2.5 
neo4j==4.2.0 
gremlinpython==3.4.6</pre>
			<p>与本章相关的所有代码文件都可以在<a href="https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter09">https://github . com/packt publishing/Graph-Machine-Learning/tree/main/chapter 09</a>获得。</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor143"/>Lambda 架构概述</h1>
			<p><a id="_idIndexMarker885"/>近年来，人们非常关注设计可扩展的架构，一方面允许<em class="italic">处理大量数据</em>，另一方面<em class="italic">使用最新可用信息</em>实时提供答案/警报/行动。</p>
			<p>此外，这些系统还需要能够通过水平(添加更多服务器)或垂直(使用更强大的服务器)增加资源，无缝地向外扩展到更多用户或更多数据。<strong class="bold"> Lambda 架构</strong>是一种特殊的数据处理架构，旨在以非常高效的方式处理大量数据并确保大吞吐量，保持减少的延迟并确保容错和可忽略的错误。</p>
			<p>Lambda 架构由三个不同的层组成:</p>
			<ul>
				<li><strong class="bold">批处理层</strong>:这个<a id="_idIndexMarker886"/>层位于(可能是分布式的和可扩展的)存储系统之上，可以处理和存储所有的历史数据，以及对整个数据集执行<strong class="bold">在线分析处理</strong> ( <strong class="bold"> OLAP </strong>)计算<a id="_idIndexMarker887"/>。新数据不断被接收和存储，就像传统上在数据仓库系统中所做的那样。大规模处理通常是通过大规模并行作业来实现的，这些作业旨在对相关信息进行聚合、结构化和计算。在机器学习的背景下，依赖于历史信息的模型训练通常在这一层完成，从而产生用于批量预测作业或<a id="_idIndexMarker888"/>实时执行的训练模型。</li>
				<li><strong class="bold">速度层</strong>:这是一个<a id="_idIndexMarker889"/>低延迟层，允许实时处理信息，提供及时的更新和信息。它通常由流处理提供，通常涉及不需要长计算时间或负载的快速计算。它生成一个输出，该输出与批处理层生成的数据(近)实时集成，为<strong class="bold">在线事务处理</strong> ( <strong class="bold"> OLTP </strong>)操作提供<a id="_idIndexMarker890"/>支持。速度层也可以很好地使用 OLAP 计算的一些输出，例如训练模型。通常，使用实时机器学习建模的应用程序(例如，信用卡交易中使用的欺诈检测引擎)在其速度层中嵌入经过训练的模型，这些模型可提供即时预测并触发潜在欺诈的实时警报。库可以在事件级(如 Apache Storm)或小批量(如 Spark Streaming)运行，根据使用情况，对延迟、容错和计算速度的要求略有不同。</li>
				<li><code>flask</code>、<code>fastapi</code>或<code>turbogear</code>，它们通过专门设计的<a id="_idIndexMarker892"/>端点提供数据:</li>
			</ul>
			<div><div><img src="img/B16069_09_01.jpg" alt="Figure 9.1 – Functional diagram for an application based on Lambda architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 9.1-基于 Lambda 架构的应用程序的功能图</p>
			<p>Lambda 架构有几个好处，推动和促进了它们的使用，尤其是在大数据应用的环境中。在以下要点中，我们列出了 Lambda 架构的一些主要优点:</p>
			<ul>
				<li><strong class="bold">无服务器管理</strong>:Lambda 架构设计模式通常对功能层进行抽象，不需要安装、维护或管理任何软件/基础设施</li>
				<li><strong class="bold">灵活扩展</strong>:应用可以自动扩展，也可以通过控制批处理层(例如计算节点)和/或速度层(例如 Kafka brokers)中分别使用的处理单元数量来扩展</li>
				<li><strong class="bold">自动化高可用性</strong>:因为它代表了一种无服务器设计，我们已经有了内置的可用性和容错能力</li>
				<li><strong class="bold">业务敏捷性</strong>:对不断变化的业务/市场场景做出实时反应<a id="_idIndexMarker894"/></li>
			</ul>
			<p>尽管非常强大和灵活，Lambda 架构<a id="_idIndexMarker895"/>也有一些限制，主要是因为存在两个相互连接的处理流程:批处理层和速度层。这可能需要开发人员为批处理和流流程构建和维护单独的代码库，从而导致更多的复杂性和代码开销，这可能会导致更难的调试、可能的错位和错误升级。</p>
			<p>在这里，我们提供了 Lambda 架构及其基本构件的简要概述。有关如何设计可扩展架构和最常用的架构模式的更多详细信息，请参考 Tomcy John 和 Pankaj Misra 于 2017 年出版的《企业数据湖》一书。</p>
			<p>在下一节中，我们将向您展示如何为基于图形的应用程序实现 Lambda 架构。特别是，我们将描述主要组件并回顾最常见的技术。</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor144"/>面向图形驱动应用的 Lambda 架构</h1>
			<p>当<a id="_idIndexMarker896"/>处理可扩展、图形驱动、数据驱动的应用时，Lambda 架构的设计也反映在<a id="_idIndexMarker897"/>分析管道的两个关键组件之间的功能分离上，如图<em class="italic">图 9.2 </em>所示:</p>
			<ul>
				<li><strong class="bold">图形处理引擎</strong>对图形结构执行<a id="_idIndexMarker898"/>计算，以便提取特征(例如嵌入)、计算统计数据(例如度分布、边的数量和集团)、计算<a id="_idIndexMarker899"/>度量和<strong class="bold">关键性能指标</strong>(<strong class="bold">KPI</strong>)(例如中心性度量和聚类系数)，并识别经常需要 OLAP 的相关子图(例如社区)。</li>
				<li><strong class="bold">图形查询引擎</strong>允许<a id="_idIndexMarker900"/>用户保存网络数据(通常通过图形数据库完成)，并提供快速信息检索和高效查询以及图形遍历(通常通过图形查询语言)。所有信息都已经保存在一些数据存储中(可能在内存中，也可能不在内存中),除了(可能)一些最终聚合结果之外，不需要任何进一步的计算，对于这些结果，索引对于实现高性能和低延迟至关重要:</li>
			</ul>
			<div><div><img src="img/B16069_09_02.jpg" alt="FigurFigure 9.2 – Graph-based architecture, with the main components &#13;&#10;also reflected in a Lambda architectural pattern"/>
				</div>
			</div>
			<p class="figure-caption">图 9.2-基于图形的架构，主要组件也反映在 Lambda 架构模式中</p>
			<p>图形处理引擎位于批处理层之上，并产生可以在适当的图形数据库中存储和索引的输出。这些数据库是图形查询引擎的后端，它允许轻松快速地检索相关信息，表示服务层使用的操作视图。根据用例和/或图形的大小，在同一基础设施上运行图形处理引擎和图形查询引擎通常是有意义的。</p>
			<p>有一些图形数据库选项可以支持 OLAP 和 OLTP，而不是将图形存储在低级存储层(例如，文件系统、HDFS 或 S3)。在<a id="_idIndexMarker903"/>的同时，它们提供了一个后端<a id="_idIndexMarker904"/>持久层，其中存储了由批处理层处理的历史信息以及来自速度层的实时更新，以及服务层高效查询的信息。</p>
			<p>与其他用例相比，这种情况对于图形驱动、数据驱动的应用程序来说确实非常特殊。历史数据通常提供一个拓扑结构，在此基础上可以存储新的实时更新和 OLAP 输出(KPI、数据聚合、嵌入、社区等)。该数据结构还表示稍后由遍历丰富图的服务层查询的信息。</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor145"/>图形处理引擎</h2>
			<p>要为<strong class="bold">图形处理引擎</strong>选择正确的技术<a id="_idIndexMarker905"/>，与目标架构的容量相比，评估网络的内存大小至关重要。当目标是<a id="_idIndexMarker906"/>快速构建<strong class="bold">最小可行产品</strong> ( <strong class="bold"> MVP </strong>)时，您可以从使用允许在项目的第一阶段快速构建原型的更简单的框架开始。</p>
			<p>当性能和可伸缩性变得更加重要时，这样的框架可以被更高级的工具所替代。微服务模块化方法和这些组件的适当结构将允许技术/库的切换独立于应用程序的其余部分，以针对特定问题，这也将指导后端堆栈的选择。</p>
			<p>图形处理引擎要求快速访问整个图形的信息，也就是说，在内存中拥有所有图形，根据上下文，您可能需要也可能不需要<em class="italic">分布式架构</em>。正如我们在<a href="B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014"> <em class="italic">第 1 章</em> </a>、<em class="italic">图表入门</em>、<code>networkx</code>中看到的，在处理相当小的数据集时，这是一个构建图表处理引擎的很好的例子。当数据集变得越来越大，但它们仍然可以容纳在单个服务器或共享内存机器中时，其他库可能有助于减少计算时间。正如在<a href="B16069_01_Final_JM_ePub.xhtml#_idTextAnchor014"> <em class="italic">第 1 章</em></a><em class="italic">开始使用图形</em>中所看到的，使用除<code>networkx</code>之外的其他库，其中图形算法是用更高性能的语言实现的，如 C++或 Julia，可以显著地将计算速度提高两个数量级以上。</p>
			<p>然而，在有些情况下，数据集增长如此之快，以至于使用容量不断增加的共享内存机器(胖节点)在技术上或经济上都不再可行。在这种情况下，有必要将数据分布在数十或数百个计算节点的集群上，允许水平扩展。在这些情况下，可以支持图形处理引擎的两个最流行的框架如下:</p>
			<ul>
				<li><strong class="bold"> Apache Spark GraphX </strong>，这是<a id="_idIndexMarker908"/>处理图结构的 Spark 库的<a id="_idIndexMarker907"/>模块(【https://spark.apache.org/graphx】)。它包括对顶点和边都使用<strong class="bold">弹性分布式数据集</strong> ( <strong class="bold"> RDDs </strong>)的图<a id="_idIndexMarker909"/>的分布式表示。图在计算节点中的重新划分可以通过<em class="italic">边切割</em>策略来完成，这在逻辑上对应于在多台机器之间划分节点，也可以通过<em class="italic">顶点切割</em>策略来完成，这在逻辑上对应于将边分配给不同的机器并允许顶点跨越多台机器。尽管是用 Scala 编写的，GraphX 的特色是同时使用 R 和 Python 的包装器。GraphX 已经实现了一些算法，比如<em class="italic"> PageRank </em>、<em class="italic">连通分量</em>和<em class="italic">三角形计数</em>。在 GraphX 之上还有其他的库可以用于其他算法，比如<strong class="bold"> SparklingGraph </strong>，它<a id="_idIndexMarker910"/>实现了更多的中心性度量。</li>
				<li><strong class="bold"> Apache Giraph </strong>，这是一个<a id="_idIndexMarker911"/>迭代图形处理系统，为高<a id="_idIndexMarker912"/>可伸缩性(<a href="https://giraph.apache.org/">https://giraph.apache.org/</a>)而构建。它由脸书开发，目前正在使用，用于分析用户及其联系形成的社交图，并建立在 Hadoop 生态系统的基础上，以释放大规模结构化数据集的潜力。Giraph 原生是用 Java 编写的，与 GraphX 类似，也为一些基本的图算法提供了可伸缩的实现，比如<em class="italic"> PageRank </em>和<em class="italic">最短路径</em>。</li>
			</ul>
			<p>当我们考虑向分布式生态系统扩展时，我们应该始终记住，可用的算法选择比共享机器环境中的少得多。这通常是由于两个原因:</p>
			<ul>
				<li>首先，由于节点之间的通信，以分布式方式实现算法比在共享机器中复杂得多，这也降低了整体效率。</li>
				<li>其次，也是更重要的一点，大数据分析的一个基本原则是，只有(几乎)随数据点数量线性扩展的算法才应实施，以确保解决方案的横向可扩展性，即随着数据集的增加而增加计算节点。</li>
			</ul>
			<p>在这方面，Giraph 和 GraphX 都允许您使用基于<strong class="bold"> Pregel </strong>的标准接口<a id="_idIndexMarker913"/>来定义可伸缩的、以顶点为中心的迭代算法，这可以被视为图形的迭代 map-reduce 操作的一种等价物(实际上，迭代 map-reduce 操作应用于三元组节点-边-节点实例)。预凝胶计算由一系列迭代组成，每个迭代称为<strong class="bold">超步骤</strong>，每个<a id="_idIndexMarker914"/>涉及一个节点及其邻居。</p>
			<p>在超级步骤中，<em class="italic"> S </em>，一个用户定义的函数被应用于每个顶点，<em class="italic"> V </em>。该函数将发送到超级步骤<em class="italic">S–1</em>中<em class="italic"> V </em>的消息作为输入，并修改<em class="italic"> V </em>及其输出边沿的状态。这个函数代表映射阶段，可以很容易地并行化。除了计算<em class="italic"> V </em>的新状态，该函数还向连接到<em class="italic"> V </em>的其他顶点发送消息，这些顶点将在超级步骤<em class="italic"> S + 1 </em>接收该信息。消息通常沿着输出边发送，但是消息可以被发送到其标识符已知的任何顶点。在<em class="italic">图 9.3 </em>中，我们展示了 Pregel 算法在计算网络上的最大值时的草图。有关该算法的更多细节，请参考 Malewicz 等人在 2010 年撰写的原始论文<em class="italic">Pregel:A System for Large-Scale Graph Processing</em>:</p>
			<div><div><img src="img/B16069_09_03.jpg" alt="Figure 9.3 – Example of calculating a maximum value over a node property using Pregel &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 9.3–使用 Pregel 计算节点属性最大值的示例</p>
			<p>通过使用 Pregel，您可以以非常高效和通用的方式轻松实现其他算法，如<em class="italic"> PageRank </em>或<em class="italic">连通分量</em>，甚至实现节点嵌入的并行变体(例如，参见<em class="italic">分布式内存顶点中心网络嵌入用于大规模图形</em>，Riazi 和 Norris，2020)。</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor146"/>图形查询图层</h2>
			<p>在过去的十年里，由于<a id="_idIndexMarker915"/>非结构化数据的大量扩散，NoSQL 数据库开始获得相当大的关注和重视。其中，<strong class="bold">图形数据库</strong>在基于实体间的关系存储信息方面<a id="_idIndexMarker916"/>确实非常强大。事实上，在许多应用程序中，数据可以自然地被视为实体，以节点属性的形式与元数据相关联，由边连接，这些边也具有进一步描述实体之间关系的属性。</p>
			<p>图形数据库的例子是诸如 Neo4j、OrientDB、ArangoDB、Amazon Neptune、Cassandra 和 JanusGraph(以前称为 TitanDB)的库或工具。在下面的章节中，我们将简要描述其中的一些，以及允许我们查询和遍历<a id="_idIndexMarker917"/>底层图的语言，它们被称为<strong class="bold">图查询语言</strong>。</p>
			<h3>Neo4j</h3>
			<p>在<a id="_idIndexMarker918"/>撰写本文时，<strong class="bold">Neo4J</strong>(<a href="https://neo4j.com/">https://neo4j.com/</a>)无疑是最常见的图形数据库，有一个大型社区支持它的使用和采用。它有两个版本:</p>
			<ul>
				<li><em class="italic">社区版</em>，在 GPL v3 许可下发布<a id="_idIndexMarker920"/>，允许用户/开发者在他们的应用中公开包含 Neo4j</li>
				<li><em class="italic">企业版</em>，为规模和可用性至关重要的商业部署而设计<a id="_idIndexMarker921"/></li>
			</ul>
			<p>Neo4j 可以通过<strong class="bold">分片</strong>扩展到相当大的数据集，即在多个节点上分发数据，并在数据库的多个实例上并行化查询和<a id="_idIndexMarker922"/>聚合。此外，Neo4j 联邦还允许查询较小的分离图(有时甚至使用不同的模式)，就像它们是一个大图一样。</p>
			<p>Neo4j 的一些优点是它的灵活性(允许模式进化)和用户友好性。特别是 Neo4j 中的很多操作都可以通过它的查询语言来完成，非常直观易学:<strong class="bold"> Cypher </strong>。Cypher 可以被看作是 SQL 在图形数据库中的对等物。</p>
			<p>测试 Neo4j 和 Cypher 非常容易。你可以安装社区版(通过 Docker 见下一节)或者玩一个在线沙盒版本(<a href="https://neo4j.com/sandbox/">https://neo4j.com/sandbox/</a>)。</p>
			<p>通过使用后者，您可以导入一些内置数据集，比如电影数据集，并开始使用 Cypher 查询语言对其进行查询。电影数据集由 38 部电影和 133 名参与、导演、编剧、评论和制作这些电影的人组成。内部版本和在线版本都配备了用户友好的用户界面，允许用户查询和可视化数据(参见<em class="italic">图 9.4 </em>)。我们首先列出电影数据集中的 10 个演员，只需查询以下内容:</p>
			<pre>MATCH (p: Person) RETURN p LIMIT 10</pre>
			<p>但是现在让我们利用关于数据点之间关系的信息。我们看到数据库中出现的演员之一是山谬·里维。我们可能想知道他在列出的电影中合作过的演员都是谁。使用以下查询可以很容易地检索到该信息:</p>
			<pre>MATCH (k: Person {name:"Keanu Reeves"})-[:ACTED_IN]-(m: Movie)-[:ACTED_IN]-(a: Person) RETURN k, m, a</pre>
			<p>如下图所示，该查询通过声明我们感兴趣的路径，直观并图形化地在其语法中指示了如何遍历图形:</p>
			<div><div><img src="img/B16069_09_04.jpg" alt="Figure 9.4 – Example of the Neo4j UI with the Cypher query to retrieve the co-actors of Keanu Reeves in the Movie dataset"/>
				</div>
			</div>
			<p class="figure-caption">图 9.4–Neo4j 用户界面示例，使用 Cypher 查询在电影数据集中检索山谬·里维的合作演员</p>
			<p>除了 Cypher，还可以使用<a id="_idIndexMarker925"/> Gremlin 查询数据。这将被描述为图形数据库的一个公共接口。</p>
			<p>Neo4j <a id="_idIndexMarker926"/>还提供了与几种编程语言的绑定，如 Python、JavaScript、Java、Go、Spring 和. NET，特别是对于 Python，有几个库实现了与 Neo4j 的连接，如<code>neo4j</code>、<code>py2neo</code>和<code>neomodel</code>，其中<code>neo4j</code>是官方支持的，通过二进制协议提供与数据库的直接连接。创建到数据库的连接并运行查询只需要几行代码:</p>
			<pre>from neo4j import GraphDatabase
driver = GraphDatabase("bolt://localhost:7687", "my-user", "my-password")
def run_query(tx, query):
    return tx.run(query)
with driver.session() as session:
    session.write_transaction(run_query, query)</pre>
			<p>查询可以是任何密码查询，例如，以前编写的检索山谬·里维的合作者的查询。</p>
			<h3>Janus graph——一个可以扩展到超大型数据集的图形数据库</h3>
			<p>Neo4j 是一款非常棒的软件，当你想快速完成工作时，它是无与伦比的，这要归功于它直观的界面和查询语言。Neo4j 确实是一个适合生产的图形数据库，但在敏捷性至关重要的 MVP 中尤其出色。然而，随着数据的增加，基于分片和将大图分解成更小的子图的可伸缩性可能不是最佳选择。</p>
			<p>当数据量大幅增加时，您可能应该开始考虑其他图形数据库选项。同样，只有当用例需求开始触及 Neo4j 的可伸缩性限制时，才应该这样做，因为需求是从 MVP 初始需求发展而来的。</p>
			<p>在这种情况下，有几种选择。其中一些是商业产品，如亚马逊 Neptune 或 Cassandra。然而，开源选项也是可用的。其中，我们认为值得<a id="_idIndexMarker927"/>提一下<strong class="bold">Janus graph</strong>(<a href="https://janusgraph.org/">https://janusgraph.org/</a>)，这是一款特别有趣的软件。JanusGraph 是一个以前被称为<strong class="bold"> TitanDB </strong>的开源项目的演变，现在是 Linux 基金会下的一个官方项目<a id="_idIndexMarker928"/>，也得到技术领域顶级玩家的支持，如 IBM、Google、Hortonworks、Amazon、Expero 和 Grakn Labs。</p>
			<p>JanusGraph <a id="_idIndexMarker929"/>是一个可扩展的图形数据库，旨在存储和查询分布在具有数千亿个顶点和边的多机器集群上的图形。事实上，JanusGraph 本身没有存储层，而是一个用 Java 编写的组件，位于其他数据存储层之上，例如:</p>
			<ul>
				<li><strong class="bold">Google Cloud Bigtable</strong>(<a href="https://cloud.google.com/bigtable">https://cloud.google.com/bigtable</a>)，这是基于 Google 文件系统构建的专有<a id="_idIndexMarker930"/>数据存储系统的云版本，旨在扩展分布在数据中心的海量数据(<em class="italic"> Bigtable:一个用于结构化数据的分布式存储系统</em>，Fay Chang 等人，2006)。</li>
				<li><strong class="bold">Apache h base</strong>(<a href="https://hbase.apache.org/">https://hbase.apache.org/</a>)，这是一个非关系数据库，其<a id="_idIndexMarker931"/>在 Hadoop 和 HDFS 之上具有大表功能，从而确保类似的可伸缩性和容错性。</li>
				<li><strong class="bold">Apache Cassandra</strong>(<a href="https://cassandra.apache.org/">https://cassandra.apache.org/</a>)，这是一个开源的分布式 NoSQL <a id="_idIndexMarker932"/>数据库，允许处理大量数据，跨越多个数据中心。</li>
				<li>专门为实时应用设计的 ScyllaDB(<a href="https://www.scylladb.com/">https://www.scylladb.com/</a>)与 Apache Cassandra】兼容，同时实现了显著更高的吞吐量和更低的延迟。</li>
			</ul>
			<p>因此，JanusGraph 从可伸缩的解决方案中继承了所有好的特性，比如可伸缩性、高可用性和容错，在它们之上抽象出一个图形视图。</p>
			<p>通过与 ScyllaDB 的集成，Janu <a id="_idTextAnchor147"/> sGraph 处理速度极快、可伸缩且高吞吐量的应用程序。此外，JanusGraph 还集成了基于 Apache Lucene、Apache Solr 和 Elasticsearch 的索引层，以便在图形中实现更快的信息检索和搜索功能。</p>
			<p>高度分布式后端和索引层的使用允许 JanusGraph 扩展到巨大的<a id="_idIndexMarker934"/>图，具有数千亿个节点和边，有效地处理所谓的<strong class="bold">超级节点</strong>——换句话说，具有极大程度的节点，这在现实世界的应用程序中经常出现(记住，真实网络的一个非常著名的模型是<a id="_idIndexMarker935"/><em class="italic">bara basi-Albert</em>模型，它基于优先附件，使集线器自然地出现在图中)。</p>
			<p>在大型图中，超级节点通常是应用程序的潜在瓶颈，尤其是当业务逻辑需要遍历经过它们的图时。在遍历图的过程中，拥有有助于快速过滤相关边的属性可以极大地加快进程并获得更好的性能。</p>
			<p>JanusGraph 公开了一个标准的 API 来通过<strong class="bold"> Apache TinkerPop </strong>库(<a href="https://tinkerpop.apache.org/">https://tinkerpop.apache.org/</a>)进行<a id="_idIndexMarker936"/>查询和遍历图形，这是一个开源的、与供应商无关的图形计算框架。TinkerPop 提供了一个使用<a id="_idIndexMarker937"/><strong class="bold">Gremlin</strong>图遍历语言查询和分析底层图的标准接口。因此，所有兼容 TinkerPop 的图形数据库系统可以彼此无缝集成。因此，TinkerPop 允许您构建不依赖于后端技术的“标准”服务层，让您可以根据自己的实际需要，自由地为您的应用程序选择/更改合适的图形技术。事实上，现在大多数图形数据库(甚至包括我们之前看到的 Neo4j)都集成了 TinkerPop，使得后端图形数据库之间的切换无缝，避免了任何供应商锁定。</p>
			<p>除了 Java 连接器，Gremlin 还拥有直接的 Python 绑定，这要归功于<code>gremlinpython</code>库，它允许 Python 应用程序连接和遍历图形。为了查询图形结构，我们首先需要使用以下方法连接到数据库:</p>
			<pre>from gremlin_python.driver.driver_remote_connection import DriverRemoteConnection
connection = DriverRemoteConnection(
    'ws://localhost:8182/gremlin', 'g'
)</pre>
			<p>一旦创建了连接，我们就可以实例化<code>GraphTraversalSource</code>，它是所有 Gremlin 遍历的基础，并将它绑定到我们刚刚创建的连接:</p>
			<pre>from gremlin_python.structure.graph import Graph
from gremlin_python.process.graph_traversal import __ 
graph = Graph()
g = graph.traversal().withRemote(connection)</pre>
			<p>一旦<code>GraphTraversalSource</code>被实例化，我们就可以在应用程序中重用它来查询图形数据库。假设我们已经将之前描述的电影图表数据库导入到 JanusGraph 中；我们可以重写之前使用的 Cypher 查询，使用 Gremlin 查找山谬·里维的所有合作者:</p>
			<pre>co_actors = g.V().has('Person', 'name', 'Keanu Reeves').out("ACTED_IN").in("ACTED_IN").values("name")</pre>
			<p>从前面的代码行可以看出，Gremlin 是一种函数式语言，通过它可以将操作符组合在一起，形成类似路径的表达式。</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor148"/>在 Neo4j 和 GraphX 之间选择</h2>
			<p>Neo4j 还是 GraphX？这是一个经常被问到的问题。然而，正如我们简要描述的，这两个软件并不是真正的竞争对手，而是针对不同的需求。Neo4j 允许我们以类似图形的结构存储信息并查询数据，而<a id="_idIndexMarker938"/> GraphX 使<a id="_idIndexMarker939"/>分析处理图形成为可能(特别是对于大尺寸的图形)。虽然您也可以使用 Neo4j 作为处理引擎(事实上，Neo4j 生态系统提供了一个图形数据科学库，这是一个实际的处理引擎),并且 GraphX 也可以用作内存中存储的图形，但是不鼓励使用这种方法。</p>
			<p>图形处理引擎通常会计算存储在图形数据库层中的 KPI(可能会进行索引，以使查询和排序变得高效),供以后使用。因此，GraphX 等技术不会与 Neo4j 等图形数据库竞争，它们可以很好地共存于同一应用程序中，以服务于不同的目的。正如我们在介绍中强调的，即使在 MVP 和早期阶段，最好将两个组件——图形处理引擎和图形查询引擎——分开，并为每个组件使用适当的技术。</p>
			<p>在这两种情况下都存在简单易用的库和工具，我们强烈建议您明智地使用它们，以便构建一个可以无缝扩展的可靠的应用程序。</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor149"/>总结</h1>
			<p>在本节中，我们向您提供了如何设计、实现和部署数据驱动的应用程序的基本概念，这些应用程序采用图建模和利用图结构。我们强调了模块化方法的重要性，这通常是无缝扩展任何数据驱动用例的关键，从早期的 MVP 到可以处理大量数据和高计算性能的生产系统。</p>
			<p>我们已经概述了主要的体系结构模式，这将为您设计数据驱动应用程序的主干结构提供指导。然后，我们继续描述基于图形的应用程序的主要组件:<em class="italic">图形处理引擎</em>、<em class="italic">图形数据库</em>和<em class="italic">图形查询语言</em>。对于每个组件，我们都提供了最常用工具和库的概述，以及帮助您构建和实现解决方案的实际示例。因此，到目前为止，您应该对现有的主要技术及其用途有了一个很好的了解。</p>
			<p>在下一章中，我们将转向一些最近的发展和最新的研究，即机器学习应用于图形的趋势。特别是，我们将描述科学文献中可用的一些最新技术(如生成神经网络)和应用(如应用于神经科学的图论)，提供一些实际例子和可能的应用。</p>
		</div>
	

</body></html>