<html><head/><body>


	
		<title>B18024_03_ePub</title>
		
	
	
		<div><h1 id="_idParaDest-51">第 3 章:功能存储基础、术语和用法</h1>
			<p>在上一章中，我们讨论了将特性引入生产环境的必要性和不同的实现方式，以及这些方式的常见问题和特性库如何解决这些问题。我们已经对功能商店建立了很多期望，是时候了解它们是如何工作的了。如上一章所述，特征存储不同于传统数据库——它是一种用于管理机器学习特征的数据存储服务，是一种混合系统，可用于存储和检索历史特征以进行模型训练。它还可以以低延迟提供最新功能，用于实时预测，并以亚秒延迟提供批量预测。</p>
			<p>在这一章中，我们将讨论什么是特征库，它是如何工作的，以及特征库世界中使用的一系列术语。对于这一章，我们将使用最广泛使用的开源特性商店之一，叫做<strong class="bold">盛宴</strong>。本章的目标是让你理解 Feast 特性库术语和 API 的基本用法，并对其内部工作原理有一个简单的了解。</p>
			<p>在本章中，我们将讨论以下主题:</p>
			<ul>
				<li>盛宴和装置介绍</li>
				<li>盛宴术语和定义</li>
				<li>盛宴初始化</li>
				<li>宴会用法</li>
				<li>幕后盛宴</li>
			</ul>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/>技术要求</h1>
			<p>要理解本章中的代码示例，您只需要熟悉 Python 和任何笔记本环境，可以是本地设置(如 Jupyter)或在线笔记本环境(如 Google Colab 或 Kaggle)。你可以从下面的 GitHub 链接下载本章的代码示例:<a href="https://github.com/PacktPublishing/Feature-Store-for-Machine-Learning/tree/main/Chapter03">https://GitHub . com/packt publishing/Feature-Store-for-Machine-Learning/tree/main/chapter 03</a>。</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>盛宴与装置介绍</h1>
			<p><strong class="bold"> Feast </strong>是<a id="_idIndexMarker103"/>一个用于服务和管理 ML 特性的开源特性管理系统。这是<em class="italic"> Google </em>和<em class="italic"> Gojek </em>的合作，然后被<em class="italic"> Linux Foundation AI 和 Data </em>采用。Feast 最初是为<strong class="bold">谷歌云平台(GCP) </strong>构建的，然后<a id="_idIndexMarker104"/>扩展到在其他云<a id="_idIndexMarker105"/>平台上运行，如<strong class="bold">亚马逊网络服务(AWS) </strong>和<strong class="bold">微软 Azure </strong>。今天，您也可以在本地基础设施上运行盛宴。云不可知论是 Feast 相对于其他功能商店的最大优势。</p>
			<p>然而，Feast 是一个自我管理的基础设施。根据您的组织结构，您需要一个团队来创建和管理 Feast 的基础设施。这里需要注意的另一个关键点是将<a id="_idIndexMarker107"/>从<strong class="bold">面向服务的架构(SOA) </strong>转移到了<strong class="bold">软件开发工具包(SDK)/命令行界面(CLI) </strong>的基础上。这使得小团队能够快速安装、运行和<a id="_idIndexMarker108"/>试验 Feast for projects，而无需在初始设置上花费大量时间，然后才意识到 Feast 并不合适。然而，对于生产环境，工程团队可能必须管理多个基础设施来运行他们的项目集。如果您对自我管理的基础设施不感兴趣，可以选择 Feast。其中包括<em class="italic"> Tecton </em>，它是今日盛宴的主要贡献者之一，<em class="italic"> SageMaker 功能商店</em>，它是 AWS 管理的功能商店，<em class="italic"> Databricks 功能商店，</em>等等。</p>
			<p>现在我们简单地知道了什么是盛宴，让我们看看装置。与其他需要在云上运行服务或向云提供商注册的功能商店不同，Feast 可以安装在笔记本电脑环境中，而无需设置任何附加服务。</p>
			<p>以下命令<a id="_idIndexMarker109"/>在您的笔记本环境中安装最新版本的 Feast:</p>
			<pre class="source-code">!pip install feast</pre>
			<p>是的，如果你想试用的话，这就是你安装并运行 Feast 所需要做的一切。然而，为了与团队、开发人员、阶段和生产环境合作，设置涉及一些额外的步骤。我们将在下一章中讲到这一点。现在，这足以让我们看看 API、术语和项目结构。</p>
			<p>在下一节中，让我们看看 Feast 术语、初始化和一些 API。</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>盛宴术语和定义</h1>
			<p>软件应用中的新发现通常会产生新的术语，或者在新软件的上下文中重新定义一些现有的术语。例如<a id="_idIndexMarker112"/>中的<strong class="bold">有向无环图(DAG) </strong>一般表示一类图；而在气流的上下文中(假设你熟悉它)，这意味着定义一组任务和它们的<a id="_idIndexMarker113"/>依赖关系。类似地，Feast 和更广泛的特性存储上下文有一组经常使用的术语。让我们在本节中了解它们是什么。</p>
			<p><strong class="bold">实体</strong> : <em class="italic">实体是语义相关特征的集合</em>。实体是特征可以映射到的域对象<a id="_idIndexMarker114"/>。在打车服务中，<em class="italic">客户</em>和<em class="italic">司机</em>可以是实体，然后功能可以与它们对应的实体分组。</p>
			<p>以下代码块是实体定义的一个示例:</p>
			<pre class="source-code">driver = Entity(name='driver', value_type=ValueType.STRING,</pre>
			<pre class="source-code">                join_key='driver_id')</pre>
			<p>实体是特征视图的一部分，在特征摄取和检索过程中充当主键。<strong class="bold">时间点</strong>连接<a id="_idIndexMarker115"/>和特征查找可以分别在模型训练和预测期间在主键上完成。</p>
			<p><strong class="bold">特征</strong> : <em class="italic">特征是个体可测量的属性</em>。<em class="italic">它通常是在特定实体上观察到的属性，但不必与实体相关联。</em>例如，<a id="_idIndexMarker116"/>顾客在网站上花费的平均时间可能是一个特征。一个不相关的特征可能是今天网站上新客户的数量。以下<a id="_idIndexMarker117"/>代码块是一个特征定义示例:</p>
			<pre class="source-code">trips_today = Feature(name="trips_today", </pre>
			<pre class="source-code">                      dtype=ValueType.INT64)</pre>
			<p>特征<a id="_idIndexMarker118"/>代表底层特征数据的列。正如您在前面的例子中看到的，它有<code>name</code>和<code>dtype</code>属性。</p>
			<p><strong class="bold">数据源</strong>:数据源<a id="_idIndexMarker119"/>代表底层数据。Feast 支持<a id="_idIndexMarker120"/>范围的<a id="_idIndexMarker121"/>数据源<a id="_idIndexMarker122"/>，包括<strong class="bold">文件源</strong>(本地、S3、GCS)<strong class="bold">大查询</strong>和<strong class="bold">红移</strong>。</p>
			<p>以下截图是一个<a id="_idIndexMarker123"/>示例数据源:</p>
			<div><div><img src="img/B18024_03_001.jpg" alt="Figure 3.1 – Data source&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 3.1-数据源</p>
			<p>如上图所示，数据集有一个<code>driver_id</code>实体、<code>trips_today</code>和<code>rating</code>特征，以及一个<code>timestamp</code>列。你在<em class="italic">图 3.1 </em>中看到的表格数据结构是一个<em class="italic">特征视图</em>。</p>
			<p><strong class="bold">特征视图</strong>:一个<a id="_idIndexMarker124"/>特征视图就像一个数据库表，它代表了源特征数据的结构。特征视图由实体、一个或多个特征以及数据源组成。特征视图通常是围绕类似于数据库对象的领域对象建模的。有些情况下，特征视图可以是无实体的。</p>
			<p>下面的代码块是<a id="_idIndexMarker125"/>的一个例子<code>FeatureView</code>定义:</p>
			<pre class="source-code">driver_stats_fv = FeatureView(</pre>
			<pre class="source-code">    name="driver_activity",</pre>
			<pre class="source-code">    entities=["driver"],</pre>
			<pre class="source-code">    ttl=timedelta(hours=2),</pre>
			<pre class="source-code">    features=[</pre>
			<pre class="source-code">        Feature(name="trips_today", dtype=ValueType.INT64),</pre>
			<pre class="source-code">        Feature(name="rating", dtype=ValueType.FLOAT),</pre>
			<pre class="source-code">    ],</pre>
			<pre class="source-code">    batch_source=BigQuerySource(</pre>
			<pre class="source-code">        table_ref="feast-oss.demo_data.driver_activity"</pre>
			<pre class="source-code">    )</pre>
			<pre class="source-code">)</pre>
			<p>正如您在<a id="_idIndexMarker126"/>中看到的，前面的代码块<code>FeatureView</code>有一个<code>driver</code>实体、<code>trips_today</code>和<code>rating</code>特性，以及作为数据源的<code>BigQuerySource</code>。根据功能存储，功能视图有其他同义词。例如，在 SageMaker 特征库中，它是<a id="_idIndexMarker127"/>称为<strong class="bold">特征组</strong>，在 Databricks 特征库中，它是<a id="_idIndexMarker128"/>称为<strong class="bold">特征表</strong>，在旧版 Feast 中，它是<a id="_idIndexMarker129"/>称为<strong class="bold">特征集</strong>和<strong class="bold">特征表</strong>。</p>
			<p><code>timestamp</code>列存储特定事件发生的时间信息(即系统中产生特定事件的时间)。除此之外，特性存储还提供了添加额外列的灵活性，例如<em class="italic">创建时间</em>、<em class="italic">摄取 API 调用时间</em>等等。这使得数据科学家和数据工程师能够重现系统在过去任何时候的状态。为了再现过去的状态，系统执行<strong class="bold">时间点连接</strong>。在 Feast 中，这种功能是作为一个 API 现成可用的。在其他情况下，用户可能不得不为它编写代码。</p>
			<p>让我们看一个实践中的时间点连接的例子。以下数据集的模式与图 3.1 中定义的<code>FeatureView</code>相匹配。</p>
			<div><div><img src="img/B18024_03_002.jpg" alt="Figure 3.2 – Point-in-time join dataset&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 3.2–时间点连接数据集</p>
			<p>正如您将在后面的<a id="_idIndexMarker131"/>章节中看到的，要获取历史数据，您需要一个实体数据帧，如下所示:</p>
			<div><div><img src="img/B18024_03_003.jpg" alt="Figure 3.3 – Point-in-time join entity DataFrame&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 3.3–时间点连接实体数据框架</p>
			<p>当用户调用<code>store.get_historical_features()</code>时，用<em class="italic">图 3.3 </em>中的实体数据框和一个特性列表，Feast 执行一个<code>2022-01-01 23:52:20</code>。<strong class="bold">时间点连接</strong>寻找带有最新时间戳的驱动程序特性。</p>
			<p>下面的截图<a id="_idIndexMarker132"/>显示了<strong class="bold">时间点连接</strong>的运行情况:</p>
			<div><div><img src="img/B18024_03_004.jpg" alt="Figure 3.4 – Point-in-time join&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 3.4–时间点连接</p>
			<p><code>FeatureView</code>是 2 小时。这表示从事件发生的<a id="_idIndexMarker134"/>时间(<code>event_timestamp + 2 hours</code>窗口)起，功能仅存在 2 小时。时间点连接的逻辑是<code>timestamp_in_data &gt;= timestamp_in_entity_dataframe</code>和<code>timestamp_in_entity_dataframe &lt;= timestamp_in_data + ttl (2 hours)</code>。正如您在<em class="italic">图 3.4 </em>中所看到的，第一行在数据中没有匹配窗口，而实体数据帧的第二、第三和第四行分别在<code>2022-01-02 1:00:00</code>、<code>2022-01-01 4:00:00</code>和<code>2022-01-01 5:00:00</code>发生的事件有匹配窗口。按照同样的逻辑，实体数据帧中的最后一行在数据中没有任何匹配的窗口。</p>
			<p>时间点连接的<a id="_idIndexMarker135"/>输出数据帧如下:</p>
			<div><div><img src="img/B18024_03_005.jpg" alt="Figure 3.5 – Point-in-time join output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 3.5–时间点连接输出</p>
			<p>如<em class="italic">图 3.5 </em>所示，对于没有匹配窗口的行，特征值为<code>NULL</code>，对于有匹配窗口的行，特征可用。</p>
			<p>在下一节中，让我们学习如何初始化一个盛宴项目，它的内容是什么，以及基本的 API 用法。</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/>盛宴初始化</h1>
			<p>让我们打开<a id="_idIndexMarker136"/>一个新的笔记本，安装一个特定版本的<code>feast</code>和<code>Pygments</code>库，以便在查看文件时得到一个格式更好的视图。以下代码安装所需的库:</p>
			<pre class="source-code">!pip install feast==0.18.1</pre>
			<pre class="source-code">!pip install Pygments</pre>
			<p>让我们初始化 Feast 项目，查看文件夹结构和文件。下面的代码块初始化一个名为<code>demo</code>的盛宴项目:</p>
			<pre class="source-code">!feast init <strong class="bold">demo</strong></pre>
			<p>前面的代码将输出以下几行:</p>
			<pre class="source-code">Feast is an open source project that collects anonymized error reporting and usage statistics. To opt out or learn more see https://docs.feast.dev/reference/usage</pre>
			<pre class="source-code">Creating a new Feast repository in /content/demo.</pre>
			<p>让我们忽略第一行中的警告消息。在第二行中，您可以看到 Feast repo 是在哪里初始化的。如果你正在使用 Google Colab，你会看到一个类似的路径，<code>/content/&lt;repo_name&gt;</code>；否则，将在当前工作目录中创建回购。</p>
			<p>为了理解<code>feast init</code>命令在后台做了什么，我们需要查看该命令创建的文件夹。您可以使用 Google Colab 左侧的导航栏来浏览文件或使用 CLI:</p>
			<div><div><img src="img/B18024_03_006.jpg" alt="Figure 3.6 – Folder structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 3.6–文件夹结构</p>
			<p><em class="italic">图 3.6 </em>是来自 Google Colab 的快照。如您所见，<code>feast init</code>命令为初学者创建了一个示例<a id="_idIndexMarker137"/>项目回购。在<code>data</code>文件夹中有一个<code>driver_stats.parquet</code>文件，还有一个<code>example.py</code>和<code>feature_store.yaml</code>文件。让我们仔细检查一下文件，看看里面有什么。最容易理解的文件是<code>data</code>文件夹中的<code>driver_stats.parquet</code>文件。正如文件夹所说，它包含了演示项目的样本数据。</p>
			<p>以下代码块加载<code>driver_stats.parquet</code>中的数据集，并显示其中的前十行:</p>
			<pre class="source-code">import pandas as pd</pre>
			<pre class="source-code">df = pd.read_parquet("demo/data/driver_stats.parquet")</pre>
			<pre class="source-code">df.head(10)</pre>
			<p>前面的代码块产生以下输出:</p>
			<div><div><img src="img/B18024_03_007.jpg" alt="Figure 3.7 – Sample dataset&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 3.7–样本数据集</p>
			<p><code>driver_stats.parquet</code>文件是一个样本特征数据集，如您在<em class="italic">图 3.7 </em>中所见。包含<code>conv_rate</code>和<code>avg_daily_trips</code>等驱动特征。它还具有附加的<a id="_idIndexMarker138"/>列，例如<code>event_timestamp</code>和<code>created</code>。这些是用于执行时间点连接的特殊列，如前一节所述。</p>
			<p>接下来我们来看看<code>feature_store.yaml</code>文件。以下命令打印文件内容:</p>
			<pre class="source-code">!pygmentize demo/feature_store.yaml</pre>
			<p>前面的命令输出以下内容:</p>
			<pre class="source-code">project: demo</pre>
			<pre class="source-code">registry: data/registry.db</pre>
			<pre class="source-code">provider: local</pre>
			<pre class="source-code">online_store:</pre>
			<pre class="source-code">    path: data/online_store.db</pre>
			<p><code>feature_store.yaml</code>文件包含以下变量:</p>
			<ul>
				<li><code>project</code>:这是<a id="_idIndexMarker139"/>项目名称。它使用<code>feast init</code>命令的输入作为项目名称。我们运行了<code>feast init demo</code>，因此项目名称为<code>demo</code>。</li>
				<li><code>registry</code>:该<a id="_idIndexMarker140"/>变量存储项目的特征注册表路径。注册表存储了项目的所有元数据，包括<code>FeatureView</code>、<code>Entity</code>、<code>DataSources</code>等等。如你所见，<code>registry.db</code>文件还不存在于<code>data</code>文件夹中。它是在我们运行<code>apply</code>命令时创建的；我们将在<em class="italic">宴会用法</em>一节中查看它。</li>
				<li><code>provider</code>:这个<a id="_idIndexMarker141"/>变量定义了特性库将在哪里运行。该值被设置为<code>local</code>，这表示基础设施将在本地系统上运行。其他可能的值有<code>aws</code>、<code>gcp</code>等等。对于<code>aws</code>和<code>gcp</code>提供者，需要安装额外的依赖项，并且需要将额外的参数传递给<code>feast init</code>命令。</li>
				<li><code>online_store</code>:如<code>online_store</code>参数的<a id="_idIndexMarker142"/>名称所示，用于存储和提供低延迟特性。默认情况下，它使用 SQLite，但 Feast 为在线商店提供了多种选择，从<em class="italic"> DynamoDB </em>到<em class="italic">定制商店</em>。以下页面列出了在线商店支持的选项:<a href="https://docs.feast.dev/roadmap">https://docs.feast.dev/roadmap</a>。</li>
				<li><code>offline_store</code>:你<a id="_idIndexMarker143"/>在<code>feature_store.yaml</code>文件中看不到这个变量。然而，这是用于从可用选项中设置<em class="italic">历史存储</em>的另一个重要参数。同样，Feast 在这里提供了很大的灵活性:你可以从<em class="italic">文件存储</em>到<em class="italic">雪花</em>中选择任何东西。前面项目符号中的链接包含有关受支持的离线商店的信息。</li>
			</ul>
			<p>除了前面提到的<a id="_idIndexMarker144"/>之外，每个变量可能包括一些额外的设置，这取决于为该选项选择了什么。例如，如果选择 Snowflake 作为离线存储，它需要额外的输入，比如模式名、表名、Snowflake URL 等等。</p>
			<p>让我们看看<code>example.py</code>文件由什么组成。以下命令打印文件的内容:</p>
			<pre class="source-code">!pygmentize -f terminal16m demo/example.py</pre>
			<p>前面命令的输出非常长，所以我们不会一次查看所有内容，而是将它分成几个部分。以下代码块包含文件的第一部分:</p>
			<pre class="source-code"># This is an example feature definition file</pre>
			<pre class="source-code">from google.protobuf.duration_pb2 import Duration</pre>
			<pre class="source-code">from feast import Entity, Feature, FeatureView, FileSource, ValueType</pre>
			<pre class="source-code">""" Read data from parquet files. Parquet is convenient for local development mode. For production, you can use your favorite DWH, such as BigQuery. See Feast documentation for more info."""</pre>
			<pre class="source-code">Driver_hourly_stats = FileSource(</pre>
			<pre class="source-code">    path="/content/demo/data/driver_stats.parquet",</pre>
			<pre class="source-code">    event_timestamp_column="event_timestamp",</pre>
			<pre class="source-code">    created_timestamp_column="created",</pre>
			<pre class="source-code">)</pre>
			<p>在前面的块中，有几个来自已安装库的导入，但是导入之后的内容是我们特别感兴趣的。代码定义了一个类型为<code>FileSource</code>的数据源，并提供了<em class="italic">图 3.7 </em>中样本数据的路径。如前所述，<code>event_timestamp_column</code>和<code>created_timestamp_column</code>列是特殊的列，它们分别指示特定事件(数据中的行)何时发生，以及该行何时被接收到数据源中。</p>
			<p>以下代码块包含文件的第二部分:</p>
			<pre class="source-code"># Define an entity for the driver. You can think of entity as a primary key used to fetch features.</pre>
			<pre class="source-code">Driver = Entity(name="driver_id", </pre>
			<pre class="source-code">                value_type=ValueType.INT64, </pre>
			<pre class="source-code">                description="driver id",)</pre>
			<p>在前面的<a id="_idIndexMarker146"/>代码块中，定义了一个<code>driver_id</code>实体及其值类型和描述。</p>
			<p>以下代码块包含文件的最后一部分:</p>
			<pre class="source-code">""" Our parquet files contain sample data that includes a driver_id column, timestamps and three feature column. Here we define a Feature View that will allow us to serve this data to our model online."""</pre>
			<pre class="source-code">Driver_hourly_stats_view = FeatureView(</pre>
			<pre class="source-code">    name="driver_hourly_stats",</pre>
			<pre class="source-code">    entities=["driver_id"],</pre>
			<pre class="source-code">    ttl=Duration(seconds=86400 * 1),</pre>
			<pre class="source-code">    features=[</pre>
			<pre class="source-code">        Feature(name="conv_rate", dtype=ValueType.FLOAT),</pre>
			<pre class="source-code">        Feature(name="acc_rate", dtype=ValueType.FLOAT),</pre>
			<pre class="source-code">        Feature(name="avg_daily_trips", </pre>
			<pre class="source-code">                dtype=ValueType.INT64),</pre>
			<pre class="source-code">    ],</pre>
			<pre class="source-code">    online=True,</pre>
			<pre class="source-code">    batch_source=driver_hourly_stats,</pre>
			<pre class="source-code">    tags={},</pre>
			<pre class="source-code">)</pre>
			<p>前面的块包含一个<code>FeatureView</code>。该定义包含三个特性，<code>conv_rate</code>、<code>acc_rate</code>和<code>avg_daily_trips</code>，并使用文件第二部分定义的<code>driver_id</code>实体和文件第一部分定义的<code>driver_hourly_stats</code>批处理源。除此之外，还有其他变量:<code>ttl</code>、<code>online</code>和<code>tags</code>。<code>ttl</code>定义特性的寿命。例如，如果您将<code>ttl</code>设置为 60 秒，它将仅在从事件时间开始的 60 秒内出现在检索中。之后，它被认为是一个过期的功能。<code>online</code>变量表示在线商店是否为<code>FeatureView</code>启用了<a id="_idIndexMarker147"/>。<code>Tags</code>用于存储关于<code>FeatureView</code>的附加信息，如团队、所有者等，这些信息可能在特性发现中有用。</p>
			<p>简而言之，<code>example.py</code>文件由<code>demo</code>项目的实体、特征视图和数据源组成。这只是一个演示的入门模板。我们可以添加额外的实体、特征视图和数据源。</p>
			<p>既然我们已经理解了基础和基本的项目结构，让我们熟悉一下 Feast APIs。</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>盛宴用法</h1>
			<p>在本节中，让我们继续使用之前初始化<code>demo</code>项目的笔记本，注册特性视图和实体，并使用 Feast API 来检索特性。</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>注册特征定义</h2>
			<p>下面的<a id="_idIndexMarker149"/>代码块注册了在<code>example.py</code>文件中定义的所有实体和特征视图:</p>
			<pre class="source-code">%cd demo</pre>
			<pre class="source-code">!feast apply</pre>
			<p>上述代码产生以下输出:</p>
			<pre class="source-code">/content/demo</pre>
			<pre class="source-code">Created entity <strong class="bold">driver_id</strong></pre>
			<pre class="source-code">Created feature view <strong class="bold">driver_hourly_stats</strong></pre>
			<pre class="source-code">Created sqlite table <strong class="bold">demo_driver_hourly_stats</strong></pre>
			<p><a id="_idIndexMarker150"/>输出消息很简单，除了最后一行，它说<code>FeatureView</code>中设置了<code>online=True</code>。<code>apply</code>命令创建<code>registry.db</code>和<code>online_store.db</code>文件，这些文件已经在<code>feature_store.yaml</code>中设置好了。</p>
			<p>既然已经注册了实体和特性视图，我们可以连接到特性存储并浏览现有的定义。</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>浏览功能商店</h2>
			<p>下面的<a id="_idIndexMarker151"/>代码连接到特征库并列出所有实体:</p>
			<pre class="source-code">from feast import FeatureStore</pre>
			<pre class="source-code">store = FeatureStore(repo_path=".")</pre>
			<pre class="source-code">for entity in store.list_entities():</pre>
			<pre class="source-code">    print(entity.to_dict())</pre>
			<p>前面的代码块在当前目录中查找<code>feature_store.yaml</code>文件，并使用<code>store.list_entities()</code> API 获取所有实体。类似地，<code>store.list_feature_views()</code> API 可以用来获取所有可用的特性视图。我会把它留给你做练习。</p>
			<p>让我们向功能库添加一个新的实体和功能视图。</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>添加实体和特征视图</h2>
			<p>要添加新的<a id="_idIndexMarker152"/>实体<a id="_idIndexMarker153"/>和特征视图，我们需要一个特征数据集。现在，让我们使用<code>numpy</code>库生成一个合成数据集，并将其用作需要定义实体和特征视图的新特征。</p>
			<p>下面的<a id="_idIndexMarker154"/>代码<a id="_idIndexMarker155"/>生成合成特征数据:</p>
			<pre class="source-code">import pandas as pd</pre>
			<pre class="source-code">import numpy as np</pre>
			<pre class="source-code">from pytz import timezone, utc</pre>
			<pre class="source-code">from datetime import datetime, timedelta</pre>
			<pre class="source-code">import random</pre>
			<pre class="source-code">days = [datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0).replace(tzinfo=utc) \</pre>
			<pre class="source-code">        - timedelta(day) for day in range(10)][::-1]</pre>
			<pre class="source-code">customers = [1001, 1002, 1003, 1004, 1005]</pre>
			<pre class="source-code">customer_features = pd.DataFrame(</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        "datetime": [day for day in days for customer in customers], # Datetime is required</pre>
			<pre class="source-code">        "customer_id": [customer for day in days for customer in customers], # Customer is the entity</pre>
			<pre class="source-code">        "daily_transactions": [np.random.rand() * 10 for _ in range(len(days) * len(customers))], # Feature 1</pre>
			<pre class="source-code">        "total_transactions": [np.random.randint(100) for _ in range(len(days) * len(customers))], # Feature 2</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">)</pre>
			<pre class="source-code"><strong class="bold">customer_features.to_parquet("/content/demo/data/customer_features.parquet")</strong></pre>
			<pre class="source-code">customer_features.head(5)</pre>
			<p>前面的代码生成一个包含四列的数据集，并将该数据集写入<code>/content/demo/data/</code>。如果您在本地系统上运行它，那么相应地为<code>customer_features.to_parquet</code> API 调用设置路径，它在前面的代码块中突出显示。</p>
			<p>前面的代码<a id="_idIndexMarker156"/>产生<a id="_idIndexMarker157"/>如图<em class="italic">图 3.8 </em>所示的数据集:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/B18024_03_008.jpg" alt="Figure 3.8 – Synthetic customer data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 3.8–综合客户数据</p>
			<p><em class="italic">图 3.4 </em>中数据集的<code>Entity</code>和<code>FeatureView</code>的定义可以添加到现有的<code>example.py</code>文件中，或者您可以创建一个新的 Python 文件并添加以下代码块中的行。</p>
			<p>以下代码块定义了<em class="italic">图 3.8 </em>中数据集所需的<code>Entity</code>、<code>DataSource</code>和<code>FeatureView</code>:</p>
			<pre class="source-code">from google.protobuf.duration_pb2 import Duration</pre>
			<pre class="source-code">from feast import Entity, Feature, FeatureView, FileSource, ValueType</pre>
			<pre class="source-code">#Customer data source</pre>
			<pre class="source-code">customer_features = FileSource(</pre>
			<pre class="source-code">    path="/content/demo/data/customer_features.parquet",</pre>
			<pre class="source-code">    event_timestamp_column="datetime"</pre>
			<pre class="source-code">)</pre>
			<pre class="source-code">#Customer Entity</pre>
			<pre class="source-code">customer = Entity(name="customer_id", </pre>
			<pre class="source-code">                  value_type=ValueType.INT64, </pre>
			<pre class="source-code">                  description="customer id",)</pre>
			<pre class="source-code"># Customer Feature view</pre>
			<pre class="source-code">customer_features_view = FeatureView(</pre>
			<pre class="source-code">    name="customer_features",</pre>
			<pre class="source-code">    entities=["customer_id"],</pre>
			<pre class="source-code">    ttl=Duration(seconds=86400 * 1),</pre>
			<pre class="source-code">    features=[</pre>
			<pre class="source-code">        Feature(name="daily_transactions",</pre>
			<pre class="source-code">                dtype=ValueType.FLOAT),</pre>
			<pre class="source-code">        Feature(name="total_transactions", </pre>
			<pre class="source-code">                dtype=ValueType.INT64),</pre>
			<pre class="source-code">    ],</pre>
			<pre class="source-code">    online=True,</pre>
			<pre class="source-code">    batch_source=customer_features,</pre>
			<pre class="source-code">    tags={},</pre>
			<pre class="source-code">)</pre>
			<p>和我们<a id="_idIndexMarker158"/>遇到的<code>example.py</code>文件一样，这个文件有对<code>customer_features</code>数据源、<code>customer</code>实体和<code>customer_features_view</code>的定义<a id="_idIndexMarker159"/>。将新创建的文件或更新的<code>example.py</code>文件上传到项目根目录(与现有<code>example.py</code>文件相同的目录)。</p>
			<p class="callout-heading">重要说明</p>
			<p class="callout">不要删除<code>example.py</code>或替换内容，而是在文件中添加新实体或上传新文件。运行<code>feast apply</code>后，你应该有两个实体<code>driver_id</code>和<code>customer_id</code>以及两个特征视图<code>driver_hourly_stats</code>和<code>customer_features</code>。</p>
			<p>在<a id="_idIndexMarker160"/>将文件上传/复制<a id="_idIndexMarker161"/>到根目录后，运行以下命令应用新定义:</p>
			<pre class="source-code">!feast apply</pre>
			<p>前面的代码块产生以下输出:</p>
			<pre class="source-code">Created entity <strong class="bold">customer_id</strong></pre>
			<pre class="source-code">Created feature view <strong class="bold">customer_features</strong></pre>
			<pre class="source-code">Created sqlite table <strong class="bold">demo_customer_features</strong></pre>
			<p>类似于前面的<code>apply</code>命令的输出，输出很简单。如果您再次浏览功能库，您将看到更新的定义。我们将把它作为一个练习留给你。</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>生成训练数据</h2>
			<p>在<a id="_idIndexMarker162"/>运行上一节的<code>apply</code>命令后，特征库包含两个实体:<code>driver_id</code>和<code>customer_id</code>，以及两个特征视图:<code>driver_hourly_stats</code>和<code>customer_features</code>。我们可以通过使用相应的实体查询任一或两个特征视图的历史存储来生成训练数据。在本例中，我们将查询<code>driver_hourly_stats</code>特征视图。请随意在<code>customer_features</code>上试用<code>get_historical_features</code> API。</p>
			<p>要生成训练数据，需要实体数据框架。实体数据框必须<a id="_idIndexMarker163"/>有以下两列:</p>
			<ul>
				<li><code>entity_id</code>:这个<a id="_idIndexMarker164"/>是特征库中定义的实体的 id。例如，要获取驱动程序特性，您需要<code>driver_id</code>列和历史特性所需的值列表。</li>
				<li><code>event_timestamp</code>:时间点连接的每个<code>driver_id</code>的<a id="_idIndexMarker165"/>时间戳。</li>
			</ul>
			<p>下面的<a id="_idIndexMarker166"/>代码块产生一个实体数据帧来获取驱动程序特征:</p>
			<pre class="source-code">from datetime import datetime, timedelta</pre>
			<pre class="source-code">import pandas as pd</pre>
			<pre class="source-code">from feast import FeatureStore</pre>
			<pre class="source-code"># The entity DataFrame is the DataFrame we want to enrich with feature values</pre>
			<pre class="source-code">entity_df = pd.DataFrame.from_dict(</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        "driver_id": [1001, 1002, 1003],</pre>
			<pre class="source-code">        "event_timestamp": [</pre>
			<pre class="source-code">            datetime.now() – timedelta(minutes=11),</pre>
			<pre class="source-code">            datetime.now() – timedelta(minutes=36),</pre>
			<pre class="source-code">            datetime.now() – timedelta(minutes=73),</pre>
			<pre class="source-code">        ],</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">)</pre>
			<pre class="source-code">entity_df.head()</pre>
			<p>前面的代码生成以下实体数据帧:</p>
			<div><div><img src="img/B18024_03_009.jpg" alt="Figure 3.9 – Entity DataFrame&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 3.9-实体数据框架</p>
			<p>一旦有了实体数据框架，从历史存储中获取数据就很简单了。所需要做的就是连接到特性库，并使用前面代码块中创建的实体数据帧和所需特性列表调用<code>store.get_historical_features()</code> API。</p>
			<p>以下代码块连接到功能存储区并获取实体的历史功能:</p>
			<pre class="source-code">store = FeatureStore(repo_path=".")</pre>
			<pre class="source-code">training_df = store.get_historical_features(</pre>
			<pre class="source-code">    entity_df=entity_df,</pre>
			<pre class="source-code">    features=[</pre>
			<pre class="source-code">        "driver_hourly_stats:conv_rate",</pre>
			<pre class="source-code">        "driver_hourly_stats:acc_rate",</pre>
			<pre class="source-code">        "driver_hourly_stats:avg_daily_trips",</pre>
			<pre class="source-code">    ],</pre>
			<pre class="source-code">).to_df()</pre>
			<pre class="source-code">training_df.head()</pre>
			<p>您可能会注意到，API 的输入之一是特性列表。列表中元素的格式为<code>&lt;FeatureViewName&gt;:&lt;FeatureName&gt;</code>。例如，要获取<code>conv_rate</code>特征，它是<code>driver_hourly_stats </code>特征视图的一部分，列表中的元素应该是<code>driver_hourly_stats:conv_rate</code>。</p>
			<p>前面的<a id="_idIndexMarker168"/>代码块产生以下输出:</p>
			<div><div><img src="img/B18024_03_010.jpg" alt="Figure 3.10 – Get the historical features output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 3.10-获取历史特征输出</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>将功能加载到在线商店</h2>
			<p><a id="_idIndexMarker169"/>历史数据源用于生成训练数据集，该数据集也可用于批量模型中的预测。但是，我们已经知道，对于在线模型，低延迟功能服务是必需的。要实现这一点，需要从历史数据源获取最新的特性，并将这些特性加载到在线商店中。这可以通过 Feast 中的一个命令来完成。</p>
			<p>以下命令将最新功能加载到在线商店:</p>
			<pre class="source-code">!feast materialize-incremental {datetime.now().isoformat()}</pre>
			<p>该命令将时间戳作为输入之一，获取输入时间戳时的最新要素，并将要素加载到在线商店。在本例中，它是一个 SQLite 数据库。</p>
			<p>前面的代码行输出以下信息:</p>
			<div><div><img src="img/B18024_03_011.jpg" alt="Figure 3.11 – Feast materializing the output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 3.11–实现输出的盛宴</p>
			<p>既然在线商店中提供了这些要素，就可以在低延迟的模型预测过程中获取它们。使用<code>store.get_online_features()</code>并传递与传递用于查询历史数据的<a id="_idIndexMarker170"/>列表格式相同的特性列表，可以查询在线商店。</p>
			<p class="callout-heading">重要说明</p>
			<p class="callout"><code>feast materialize-incremental</code>命令将所有现有的功能视图同步到在线商店(在本例中是 SQLite)。在<em class="italic">图 3.11 </em>所示的输出中，可以看到两个特征视图:<code>driver_hourly_stats</code>和<code>customer_features</code>。您可以查询其中任何一个。在本例中，我们正在查询<code>driver_hourly_stats</code>。</p>
			<p>以下代码块为<code>id</code>值为<code>1001</code>和<code>1004</code>的驱动程序提取<code>conv_rate</code>和<code>avg_daily_trips</code>:</p>
			<pre class="source-code">store = FeatureStore(repo_path=".")</pre>
			<pre class="source-code">feature_vector = store.get_online_features(</pre>
			<pre class="source-code">    features=[</pre>
			<pre class="source-code">        "driver_hourly_stats:conv_rate",</pre>
			<pre class="source-code">        "driver_hourly_stats:avg_daily_trips",</pre>
			<pre class="source-code">    ],</pre>
			<pre class="source-code">    entity_rows=[</pre>
			<pre class="source-code">        {"driver_id": 1004},</pre>
			<pre class="source-code">        {"driver_id": 1005},</pre>
			<pre class="source-code">    ],</pre>
			<pre class="source-code">).to_dict()</pre>
			<pre class="source-code">feature_vector</pre>
			<p>前面的代码块产生以下输出。如果特定实体行的值不存在，它将返回<code>NULL</code>值:</p>
			<pre class="source-code">{'avg_daily_trips': [34, 256],</pre>
			<pre class="source-code"> 'conv_rate': [0.9326972365379333, 0.07134518772363663],</pre>
			<pre class="source-code"> 'driver_id': [1004, 1005]}</pre>
			<p>现在我们已经了解了盛宴的基本原理，是时候简单了解一下幕后发生了什么来让它工作了。在下一节中，让我们看看 Feast 组件，并为将 Feast 合并到项目中做好准备。</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor061"/>幕后盛宴</h1>
			<p>下图<a id="_idIndexMarker172"/>显示了构成 Feast 架构的不同组件:</p>
			<div><div><img src="img/B18024_03_012.jpg" alt="Figure 3.12 – Feast architecture (v0.18)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图 3.12–盛宴架构(v0.18)</p>
			<p>如上图所示，Feast 中包含了许多组件。让我们逐一分解一下:</p>
			<ul>
				<li><code>data</code>文件夹是可选的；定义特征存储配置的<code>feature_store.yml</code>文件和定义特征定义的<code>example.py</code>文件构成了一个特征报告。</li>
				<li><code>feast apply</code>)，将功能从线下加载到线上商店(<code>feast materialize</code>)，并提供了一套很棒的 API 供用户通过 Feast 浏览和查询线上线下商店。我们在用法部分使用了一些 Feast SDK APIs。</li>
				<li><strong class="bold">Feast Registry</strong>:Feast Registry<a id="_idIndexMarker175"/>使用对象存储来保存特性定义，可以使用 Feast SDK 浏览这些特性定义。</li>
				<li><strong class="bold">在线商店</strong>:<a id="_idIndexMarker176"/>在线商店是一个低延迟的数据库，用于提供模型预测的最新功能。用户可以使用 Feast SDK 加载最新功能或查询在线商店。流媒体源也可用于将功能加载到在线商店。</li>
				<li><strong class="bold">线下存储</strong>:线下存储<a id="_idIndexMarker177"/>用于历史数据的存储和检索。它还用于模型训练和批量评分。在 Feast 中，离线商店中的数据是由用户管理的。</li>
			</ul>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>盛宴中的数据流</h2>
			<p>以下步骤<a id="_idIndexMarker178"/>给出了 Feast 中数据流的<a id="_idIndexMarker179"/>示例:</p>
			<ol>
				<li>数据工程师构建 ETL/数据管道来生成特性，并将其加载到 Feast 支持的离线存储中。</li>
				<li>Feature definitions are created, the Feast store configuration is defined, and the <code>feast apply</code> command is run. <p class="callout-heading">重要说明</p><p class="callout">特性存储配置涉及到定义基础设施细节，因此它也可能涉及到基础设施的创建。</p></li>
				<li>使用 Feast SDK，数据科学家/数据工程师连接到 Feast repo，并为模型生成训练数据。模型经过训练，如果不符合验收标准，可以通过添加额外的数据管道来生成新的特征。</li>
				<li>Steps <em class="italic">1-3</em> will be executed again. <p class="callout-heading">重要说明</p><p class="callout">在<em class="italic">步骤 2 </em>中，只需要添加新的实体和特征定义。</p></li>
				<li>使用<a id="_idIndexMarker181"/>命令<code>feast materialize</code>将功能<a id="_idIndexMarker180"/>从离线加载到在线商店。该命令可以按计划运行，以使用编排工具(如<a id="_idIndexMarker182"/>和<strong class="bold">气流</strong>)加载最新功能。</li>
				<li>经过训练的模型与 Feast SDK 代码一起打包，以便在预测期间获取模型评分所需的特征。打包的模型被部署到生产中。</li>
				<li>在预测过程中，模型使用 Feast SDK 获取所需的特性，运行预测，并返回结果。</li>
				<li>可以监控离线商店的数据漂移，以确定是否需要重新训练模型。</li>
			</ol>
			<p>接下来让我们总结一下我们在本章中学到的东西，然后继续在我们的实际项目中使用 Feast。</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/>摘要</h1>
			<p>在这一章中，我们讨论了功能商店世界中使用的术语，特别是与<em class="italic">盛宴</em>相关的术语。但是，请记住，许多现有的功能库使用类似的术语，所以如果您熟悉其中一个，就很容易理解其他的。我们还讨论了<em class="italic">时间点连接</em>如何在 Feast 中工作，以及 Feast 的基础知识，比如安装、初始化、项目结构和 API 使用。最后，我们探索了 Feast 的组件以及模型的操作化如何与 Feast 一起工作。</p>
			<p>在下一章中，我们将在第一章 、<em class="italic">机器学习生命周期概述</em>中构建的模型中使用 Feast，了解它如何改变数据科学家和工程师的工作方式，并了解它如何为我们的 ML 模型的功能共享、监控和轻松生产打开新的机会之门。</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>延伸阅读</h1>
			<ul>
				<li><em class="italic">盛宴介绍</em>:<a href="https://docs.feast.dev/">https://docs.feast.dev/</a></li>
				<li><em class="italic">盛宴概述</em>:<a href="https://github.com/feast-dev/feast/blob/v0.18.1/examples/quickstart/quickstart.ipynb">https://github . com/Feast-dev/Feast/blob/v 0 . 18 . 1/examples/quick start/quick start . ipynb</a></li>
			</ul>
		</div>
	

</body></html>